// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CloudProjectAlertingResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"creation_date": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "Alerting creation date",
				MarkdownDescription: "Alerting creation date",
			},
			"delay": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Required:            true,
				Description:         "Possible values for delay between two alerts in seconds",
				MarkdownDescription: "Possible values for delay between two alerts in seconds",
				Validators: []validator.Int64{
					int64validator.OneOf(
						10800,
						172800,
						21600,
						259200,
						3600,
						43200,
						604800,
						86400,
					),
				},
			},
			"email": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "Email to contact",
				MarkdownDescription: "Email to contact",
			},
			"formatted_monthly_threshold": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"currency_code": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Computed:   true,
					},
					"text": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Computed:   true,
					},
					"value": schema.NumberAttribute{
						CustomType: ovhtypes.TfNumberType{},
						Computed:   true,
					},
				},
				CustomType: FormattedMonthlyThresholdType{
					ObjectType: types.ObjectType{
						AttrTypes: FormattedMonthlyThresholdValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Formatted monthly threshold for this alerting",
				MarkdownDescription: "Formatted monthly threshold for this alerting",
			},
			"id": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "Alerting unique UUID",
				MarkdownDescription: "Alerting unique UUID",
			},
			"monthly_threshold": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Required:            true,
				Description:         "Monthly threshold for this alerting in currency",
				MarkdownDescription: "Monthly threshold for this alerting in currency",
			},
			"service_name": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "The project id",
				MarkdownDescription: "The project id",
			},
		},
	}
}

type CloudProjectAlertingModel struct {
	CreationDate              ovhtypes.TfStringValue         `tfsdk:"creation_date" json:"creationDate"`
	Delay                     ovhtypes.TfInt64Value          `tfsdk:"delay" json:"delay"`
	Email                     ovhtypes.TfStringValue         `tfsdk:"email" json:"email"`
	FormattedMonthlyThreshold FormattedMonthlyThresholdValue `tfsdk:"formatted_monthly_threshold" json:"formattedMonthlyThreshold"`
	Id                        ovhtypes.TfStringValue         `tfsdk:"id" json:"id"`
	MonthlyThreshold          ovhtypes.TfInt64Value          `tfsdk:"monthly_threshold" json:"monthlyThreshold"`
	ServiceName               ovhtypes.TfStringValue         `tfsdk:"service_name" json:"serviceName"`
}

func (v *CloudProjectAlertingModel) MergeWith(other *CloudProjectAlertingModel) {

	if (v.CreationDate.IsUnknown() || v.CreationDate.IsNull()) && !other.CreationDate.IsUnknown() {
		v.CreationDate = other.CreationDate
	}

	if (v.Delay.IsUnknown() || v.Delay.IsNull()) && !other.Delay.IsUnknown() {
		v.Delay = other.Delay
	}

	if (v.Email.IsUnknown() || v.Email.IsNull()) && !other.Email.IsUnknown() {
		v.Email = other.Email
	}

	if v.FormattedMonthlyThreshold.IsUnknown() && !other.FormattedMonthlyThreshold.IsUnknown() {
		v.FormattedMonthlyThreshold = other.FormattedMonthlyThreshold
	} else if !other.FormattedMonthlyThreshold.IsUnknown() {
		v.FormattedMonthlyThreshold.MergeWith(&other.FormattedMonthlyThreshold)
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.MonthlyThreshold.IsUnknown() || v.MonthlyThreshold.IsNull()) && !other.MonthlyThreshold.IsUnknown() {
		v.MonthlyThreshold = other.MonthlyThreshold
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

}

type CloudProjectAlertingWritableModel struct {
	Delay            *ovhtypes.TfInt64Value  `tfsdk:"delay" json:"delay,omitempty"`
	Email            *ovhtypes.TfStringValue `tfsdk:"email" json:"email,omitempty"`
	MonthlyThreshold *ovhtypes.TfInt64Value  `tfsdk:"monthly_threshold" json:"monthlyThreshold,omitempty"`
}

func (v CloudProjectAlertingModel) ToCreate() *CloudProjectAlertingWritableModel {
	res := &CloudProjectAlertingWritableModel{}

	if !v.Delay.IsUnknown() {
		res.Delay = &v.Delay
	}

	if !v.Email.IsUnknown() {
		res.Email = &v.Email
	}

	if !v.MonthlyThreshold.IsUnknown() {
		res.MonthlyThreshold = &v.MonthlyThreshold
	}

	return res
}

func (v CloudProjectAlertingModel) ToUpdate() *CloudProjectAlertingWritableModel {
	res := &CloudProjectAlertingWritableModel{}

	if !v.Delay.IsUnknown() {
		res.Delay = &v.Delay
	}

	if !v.Email.IsUnknown() {
		res.Email = &v.Email
	}

	if !v.MonthlyThreshold.IsUnknown() {
		res.MonthlyThreshold = &v.MonthlyThreshold
	}

	return res
}

var _ basetypes.ObjectTypable = FormattedMonthlyThresholdType{}

type FormattedMonthlyThresholdType struct {
	basetypes.ObjectType
}

func (t FormattedMonthlyThresholdType) Equal(o attr.Type) bool {
	other, ok := o.(FormattedMonthlyThresholdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FormattedMonthlyThresholdType) String() string {
	return "FormattedMonthlyThresholdType"
}

func (t FormattedMonthlyThresholdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currencyCodeAttribute, ok := attributes["currency_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency_code is missing from object`)

		return nil, diags
	}

	currencyCodeVal, ok := currencyCodeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency_code expected to be ovhtypes.TfStringValue, was: %T`, currencyCodeAttribute))
	}

	textAttribute, ok := attributes["text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`text is missing from object`)

		return nil, diags
	}

	textVal, ok := textAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`text expected to be ovhtypes.TfStringValue, was: %T`, textAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfNumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfNumberValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FormattedMonthlyThresholdValue{
		CurrencyCode: currencyCodeVal,
		Text:         textVal,
		Value:        valueVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewFormattedMonthlyThresholdValueNull() FormattedMonthlyThresholdValue {
	return FormattedMonthlyThresholdValue{
		state: attr.ValueStateNull,
	}
}

func NewFormattedMonthlyThresholdValueUnknown() FormattedMonthlyThresholdValue {
	return FormattedMonthlyThresholdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFormattedMonthlyThresholdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FormattedMonthlyThresholdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FormattedMonthlyThresholdValue Attribute Value",
				"While creating a FormattedMonthlyThresholdValue value, a missing attribute value was detected. "+
					"A FormattedMonthlyThresholdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FormattedMonthlyThresholdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FormattedMonthlyThresholdValue Attribute Type",
				"While creating a FormattedMonthlyThresholdValue value, an invalid attribute value was detected. "+
					"A FormattedMonthlyThresholdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FormattedMonthlyThresholdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FormattedMonthlyThresholdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FormattedMonthlyThresholdValue Attribute Value",
				"While creating a FormattedMonthlyThresholdValue value, an extra attribute value was detected. "+
					"A FormattedMonthlyThresholdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FormattedMonthlyThresholdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFormattedMonthlyThresholdValueUnknown(), diags
	}

	currencyCodeAttribute, ok := attributes["currency_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency_code is missing from object`)

		return NewFormattedMonthlyThresholdValueUnknown(), diags
	}

	currencyCodeVal, ok := currencyCodeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency_code expected to be ovhtypes.TfStringValue, was: %T`, currencyCodeAttribute))
	}

	textAttribute, ok := attributes["text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`text is missing from object`)

		return NewFormattedMonthlyThresholdValueUnknown(), diags
	}

	textVal, ok := textAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`text expected to be ovhtypes.TfStringValue, was: %T`, textAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewFormattedMonthlyThresholdValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfNumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfNumberValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewFormattedMonthlyThresholdValueUnknown(), diags
	}

	return FormattedMonthlyThresholdValue{
		CurrencyCode: currencyCodeVal,
		Text:         textVal,
		Value:        valueVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewFormattedMonthlyThresholdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FormattedMonthlyThresholdValue {
	object, diags := NewFormattedMonthlyThresholdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFormattedMonthlyThresholdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FormattedMonthlyThresholdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFormattedMonthlyThresholdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFormattedMonthlyThresholdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFormattedMonthlyThresholdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFormattedMonthlyThresholdValueMust(FormattedMonthlyThresholdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FormattedMonthlyThresholdType) ValueType(ctx context.Context) attr.Value {
	return FormattedMonthlyThresholdValue{}
}

var _ basetypes.ObjectValuable = FormattedMonthlyThresholdValue{}

type FormattedMonthlyThresholdValue struct {
	CurrencyCode ovhtypes.TfStringValue `tfsdk:"currency_code" json:"currencyCode"`
	Text         ovhtypes.TfStringValue `tfsdk:"text" json:"text"`
	Value        ovhtypes.TfNumberValue `tfsdk:"value" json:"value"`
	state        attr.ValueState
}

func (v *FormattedMonthlyThresholdValue) UnmarshalJSON(data []byte) error {
	type JsonFormattedMonthlyThresholdValue FormattedMonthlyThresholdValue

	var tmp JsonFormattedMonthlyThresholdValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CurrencyCode = tmp.CurrencyCode
	v.Text = tmp.Text
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *FormattedMonthlyThresholdValue) MergeWith(other *FormattedMonthlyThresholdValue) {

	if (v.CurrencyCode.IsUnknown() || v.CurrencyCode.IsNull()) && !other.CurrencyCode.IsUnknown() {
		v.CurrencyCode = other.CurrencyCode
	}

	if (v.Text.IsUnknown() || v.Text.IsNull()) && !other.Text.IsUnknown() {
		v.Text = other.Text
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v FormattedMonthlyThresholdValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"currencyCode": v.CurrencyCode,
		"text":         v.Text,
		"value":        v.Value,
	}
}
func (v FormattedMonthlyThresholdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["currency_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["text"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CurrencyCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency_code"] = val

		val, err = v.Text.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["text"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FormattedMonthlyThresholdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FormattedMonthlyThresholdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FormattedMonthlyThresholdValue) String() string {
	return "FormattedMonthlyThresholdValue"
}

func (v FormattedMonthlyThresholdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"currency_code": ovhtypes.TfStringType{},
			"text":          ovhtypes.TfStringType{},
			"value":         ovhtypes.TfNumberType{},
		},
		map[string]attr.Value{
			"currency_code": v.CurrencyCode,
			"text":          v.Text,
			"value":         v.Value,
		})

	return objVal, diags
}

func (v FormattedMonthlyThresholdValue) Equal(o attr.Value) bool {
	other, ok := o.(FormattedMonthlyThresholdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrencyCode.Equal(other.CurrencyCode) {
		return false
	}

	if !v.Text.Equal(other.Text) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v FormattedMonthlyThresholdValue) Type(ctx context.Context) attr.Type {
	return FormattedMonthlyThresholdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FormattedMonthlyThresholdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"currency_code": ovhtypes.TfStringType{},
		"text":          ovhtypes.TfStringType{},
		"value":         ovhtypes.TfNumberType{},
	}
}
