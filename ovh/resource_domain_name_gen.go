// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
)

func DomainNameResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"checksum": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Computed hash used to control concurrent modification requests. Here, it represents the current target specification value",
			MarkdownDescription: "Computed hash used to control concurrent modification requests. Here, it represents the current target specification value",
		},
		"current_state": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"additional_states": schema.ListAttribute{
					CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Domain additional states",
					MarkdownDescription: "Domain additional states",
				},
				"dns_configuration": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"configuration_type": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "The type of DNS configuration of the domain",
							MarkdownDescription: "The type of DNS configuration of the domain",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"ANYCAST",
									"DEDICATED",
									"EMPTY",
									"EXTERNAL",
									"HOLD",
									"HOSTING",
									"MIXED",
									"PARKING",
								),
							},
						},
						"glue_record_ipv6supported": schema.BoolAttribute{
							CustomType:          ovhtypes.TfBoolType{},
							Computed:            true,
							Description:         "Whether the registry supports IPv6 or not",
							MarkdownDescription: "Whether the registry supports IPv6 or not",
						},
						"host_supported": schema.BoolAttribute{
							CustomType:          ovhtypes.TfBoolType{},
							Computed:            true,
							Description:         "Whether the registry accepts hosts or not",
							MarkdownDescription: "Whether the registry accepts hosts or not",
						},
						"max_dns": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "The maximum number of name servers allowed by the registry",
							MarkdownDescription: "The maximum number of name servers allowed by the registry",
						},
						"min_dns": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "The minimum number of name servers allowed by the registry",
							MarkdownDescription: "The minimum number of name servers allowed by the registry",
						},
						"name_servers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ipv4": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "The IPv4 associated to the name server",
										MarkdownDescription: "The IPv4 associated to the name server",
									},
									"ipv6": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "The IPv6 associated to the name server",
										MarkdownDescription: "The IPv6 associated to the name server",
									},
									"name_server": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "The host name",
										MarkdownDescription: "The host name",
									},
									"name_server_type": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "The type of name server",
										MarkdownDescription: "The type of name server",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"ANYCAST",
												"DEDICATED",
												"EMPTY",
												"EXTERNAL",
												"HOLD",
												"HOSTING",
												"MIXED",
												"PARKING",
											),
										},
									},
								},
								CustomType: CurrentStateDnsConfigurationNameServersType{
									ObjectType: types.ObjectType{
										AttrTypes: CurrentStateDnsConfigurationNameServersValue{}.AttributeTypes(ctx),
									},
								},
							},
							CustomType:          ovhtypes.NewTfListNestedType[CurrentStateDnsConfigurationNameServersValue](ctx),
							Computed:            true,
							Description:         "The name servers used by the domain name",
							MarkdownDescription: "The name servers used by the domain name",
						},
					},
					CustomType: CurrentStateDnsConfigurationType{
						ObjectType: types.ObjectType{
							AttrTypes: CurrentStateDnsConfigurationValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "The domain DNS configuration",
					MarkdownDescription: "The domain DNS configuration",
				},
				"extension": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Extension of the domain name",
					MarkdownDescription: "Extension of the domain name",
				},
				"main_state": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Domain main state",
					MarkdownDescription: "Domain main state",
					Validators: []validator.String{
						stringvalidator.OneOf(
							"DELETED",
							"EXPIRED",
							"OK",
							"PENDING_CREATE",
							"PENDING_DELETE",
							"PENDING_INTERNAL_TRANSFER",
							"PENDING_OUTGOING_TRANSFER",
							"RESTORABLE",
							"TO_DELETE",
						),
					},
				},
				"name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Domain name",
					MarkdownDescription: "Domain name",
				},
				"protection_state": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Domain protection state",
					MarkdownDescription: "Domain protection state",
					Validators: []validator.String{
						stringvalidator.OneOf(
							"PROTECTED",
							"UNPROTECTED",
						),
					},
				},
				"suspension_state": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Domain suspension state",
					MarkdownDescription: "Domain suspension state",
					Validators: []validator.String{
						stringvalidator.OneOf(
							"NOT_SUSPENDED",
							"SUSPENDED",
						),
					},
				},
			},
			CustomType: CurrentStateType{
				ObjectType: types.ObjectType{
					AttrTypes: CurrentStateValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Current state of the domain name",
			MarkdownDescription: "Current state of the domain name",
		},
		"current_tasks": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Identifier of the current task",
						MarkdownDescription: "Identifier of the current task",
					},
					"link": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Link to the task details",
						MarkdownDescription: "Link to the task details",
					},
					"status": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Current global status of the current task",
						MarkdownDescription: "Current global status of the current task",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ERROR",
								"PENDING",
								"RUNNING",
								"SCHEDULED",
							),
						},
					},
					"type": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Type of the current task",
						MarkdownDescription: "Type of the current task",
					},
				},
				CustomType: CurrentTasksType{
					ObjectType: types.ObjectType{
						AttrTypes: CurrentTasksValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[CurrentTasksValue](ctx),
			Computed:            true,
			Description:         "Ongoing asynchronous tasks related to the domain name resource",
			MarkdownDescription: "Ongoing asynchronous tasks related to the domain name resource",
		},
		"domain_name": schema.StringAttribute{
			CustomType: ovhtypes.TfStringType{},
			Required:   true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
			Description:         "Domain name",
			MarkdownDescription: "Domain name",
		},
		"iam": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Resource display name",
					MarkdownDescription: "Resource display name",
				},
				"id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique identifier of the resource",
					MarkdownDescription: "Unique identifier of the resource",
				},
				"tags": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Resource tags. Tags that were internally computed are prefixed with ovh:",
					MarkdownDescription: "Resource tags. Tags that were internally computed are prefixed with ovh:",
				},
				"urn": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique resource name used in policies",
					MarkdownDescription: "Unique resource name used in policies",
				},
			},
			CustomType: IamType{
				ObjectType: types.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "IAM resource metadata",
			MarkdownDescription: "IAM resource metadata",
		},
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Unique identifier for the resource. Here, the domain name itself is used as an identifier",
			MarkdownDescription: "Unique identifier for the resource. Here, the domain name itself is used as an identifier",
		},
		"resource_status": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Reflects the readiness of the domain name resource. A new target specification request will be accepted only in `READY`, `UPDATING` or `ERROR` status",
			MarkdownDescription: "Reflects the readiness of the domain name resource. A new target specification request will be accepted only in `READY`, `UPDATING` or `ERROR` status",
			Validators: []validator.String{
				stringvalidator.OneOf(
					"CREATING",
					"DELETING",
					"ERROR",
					"READY",
					"UPDATING",
				),
			},
		},
		"target_spec": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"dns_configuration": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"name_servers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ipv4": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "The IPv4 associated to the name server",
										MarkdownDescription: "The IPv4 associated to the name server",
									},
									"ipv6": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "The IPv6 associated to the name server",
										MarkdownDescription: "The IPv6 associated to the name server",
									},
									"name_server": schema.StringAttribute{
										CustomType: ovhtypes.TfStringType{},
										// Required:            true,
										Optional:            true,
										Computed:            true,
										Description:         "The host name",
										MarkdownDescription: "The host name",
									},
								},
								CustomType: TargetSpecDnsConfigurationNameServersType{
									ObjectType: types.ObjectType{
										AttrTypes: TargetSpecDnsConfigurationNameServersValue{}.AttributeTypes(ctx),
									},
								},
							},
							CustomType:          ovhtypes.NewTfListNestedType[TargetSpecDnsConfigurationNameServersValue](ctx),
							Optional:            true,
							Description:         "The name servers to update",
							MarkdownDescription: "The name servers to update",
						},
					},
					CustomType: TargetSpecDnsConfigurationType{
						ObjectType: types.ObjectType{
							AttrTypes: TargetSpecDnsConfigurationValue{}.AttributeTypes(ctx),
						},
					},
					Optional:            true,
					Computed:            true,
					Description:         "The domain DNS configuration",
					MarkdownDescription: "The domain DNS configuration",
				},
			},
			CustomType: TargetSpecType{
				ObjectType: types.ObjectType{
					AttrTypes: TargetSpecValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "Latest target specification of the domain name resource.",
			MarkdownDescription: "Latest target specification of the domain name resource.",
		},
	}
	for k, v := range OrderResourceSchema(ctx).Attributes {
		attrs[k] = v
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type DomainNameModel struct {
	Checksum       ovhtypes.TfStringValue                        `tfsdk:"checksum" json:"checksum"`
	CurrentState   CurrentStateValue                             `tfsdk:"current_state" json:"currentState"`
	CurrentTasks   ovhtypes.TfListNestedValue[CurrentTasksValue] `tfsdk:"current_tasks" json:"currentTasks"`
	DomainName     ovhtypes.TfStringValue                        `tfsdk:"domain_name" json:"domainName"`
	Iam            IamValue                                      `tfsdk:"iam" json:"iam"`
	Id             ovhtypes.TfStringValue                        `tfsdk:"id" json:"id"`
	ResourceStatus ovhtypes.TfStringValue                        `tfsdk:"resource_status" json:"resourceStatus"`
	TargetSpec     TargetSpecValue                               `tfsdk:"target_spec" json:"targetSpec"`
	Order          OrderValue                                    `tfsdk:"order" json:"order"`
	OvhSubsidiary  ovhtypes.TfStringValue                        `tfsdk:"ovh_subsidiary" json:"ovhSubsidiary"`
	Plan           ovhtypes.TfListNestedValue[PlanValue]         `tfsdk:"plan" json:"plan"`
	PlanOption     ovhtypes.TfListNestedValue[PlanOptionValue]   `tfsdk:"plan_option" json:"planOption"`
}

func (v *DomainNameModel) MergeWith(other *DomainNameModel, overrideChecksum bool) {
	if overrideChecksum {
		v.Checksum = other.Checksum
	}

	if v.CurrentState.IsUnknown() && !other.CurrentState.IsUnknown() {
		v.CurrentState = other.CurrentState
	} else if !other.CurrentState.IsUnknown() {
		v.CurrentState.MergeWith(&other.CurrentState)
	}

	if (v.CurrentTasks.IsUnknown() || v.CurrentTasks.IsNull()) && !other.CurrentTasks.IsUnknown() {
		v.CurrentTasks = other.CurrentTasks
	} else if !other.CurrentTasks.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.CurrentTasks.Elements()
		newElems := other.CurrentTasks.Elements()

		if len(elems) != len(newElems) {
			v.CurrentTasks = other.CurrentTasks
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentTasksValue)
				tmp2 := newElems[idx].(CurrentTasksValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.CurrentTasks = ovhtypes.TfListNestedValue[CurrentTasksValue]{
				ListValue: basetypes.NewListValueMust(CurrentTasksValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.DomainName.IsUnknown() || v.DomainName.IsNull()) && !other.DomainName.IsUnknown() {
		v.DomainName = other.DomainName
	}

	if v.Iam.IsUnknown() && !other.Iam.IsUnknown() {
		v.Iam = other.Iam
	} else if !other.Iam.IsUnknown() {
		v.Iam.MergeWith(&other.Iam)
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.ResourceStatus.IsUnknown() || v.ResourceStatus.IsNull()) && !other.ResourceStatus.IsUnknown() {
		v.ResourceStatus = other.ResourceStatus
	}

	if v.TargetSpec.IsUnknown() && !other.TargetSpec.IsUnknown() {
		v.TargetSpec = other.TargetSpec
	} else if !other.TargetSpec.IsUnknown() {
		v.TargetSpec.MergeWith(&other.TargetSpec)
	}

	if (v.Order.IsUnknown() || v.Order.IsNull()) && !other.Order.IsUnknown() {
		v.Order = other.Order
	}

	if (v.OvhSubsidiary.IsUnknown() || v.OvhSubsidiary.IsNull()) && !other.OvhSubsidiary.IsUnknown() {
		v.OvhSubsidiary = other.OvhSubsidiary
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	}

	if (v.PlanOption.IsUnknown() || v.PlanOption.IsNull()) && !other.PlanOption.IsUnknown() {
		v.PlanOption = other.PlanOption
	}

}

func (v *DomainNameModel) ToOrder() *OrderModel {
	return &OrderModel{
		Order:         v.Order,
		OvhSubsidiary: v.OvhSubsidiary,
		Plan:          v.Plan,
		PlanOption:    v.PlanOption,
	}
}

type DomainNameWritableModel struct {
	Checksum   *ovhtypes.TfStringValue  `tfsdk:"checksum" json:"checksum,omitempty"`
	TargetSpec *TargetSpecWritableValue `tfsdk:"target_spec" json:"targetSpec,omitempty"`
}

func (v DomainNameModel) ToCreate() *DomainNameWritableModel {
	res := &DomainNameWritableModel{}

	if !v.Checksum.IsUnknown() {
		res.Checksum = &v.Checksum
	}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = v.TargetSpec.ToCreate()
	}

	return res
}

func (v DomainNameModel) ToUpdate() *DomainNameWritableModel {
	res := &DomainNameWritableModel{}

	if !v.Checksum.IsUnknown() {
		res.Checksum = &v.Checksum
	}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = v.TargetSpec.ToUpdate()
	}

	return res
}

var _ basetypes.ObjectTypable = CurrentStateType{}

type CurrentStateType struct {
	basetypes.ObjectType
}

func (t CurrentStateType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateType) String() string {
	return "CurrentStateType"
}

func (t CurrentStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalStatesAttribute, ok := attributes["additional_states"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_states is missing from object`)

		return nil, diags
	}

	additionalStatesVal, ok := additionalStatesAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_states expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, additionalStatesAttribute))
	}

	dnsConfigurationAttribute, ok := attributes["dns_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_configuration is missing from object`)

		return nil, diags
	}

	dnsConfigurationVal, ok := dnsConfigurationAttribute.(CurrentStateDnsConfigurationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_configuration expected to be CurrentStateDnsConfigurationValue, was: %T`, dnsConfigurationAttribute))
	}

	extensionAttribute, ok := attributes["extension"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extension is missing from object`)

		return nil, diags
	}

	extensionVal, ok := extensionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extension expected to be ovhtypes.TfStringValue, was: %T`, extensionAttribute))
	}

	mainStateAttribute, ok := attributes["main_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`main_state is missing from object`)

		return nil, diags
	}

	mainStateVal, ok := mainStateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`main_state expected to be ovhtypes.TfStringValue, was: %T`, mainStateAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protectionStateAttribute, ok := attributes["protection_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protection_state is missing from object`)

		return nil, diags
	}

	protectionStateVal, ok := protectionStateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protection_state expected to be ovhtypes.TfStringValue, was: %T`, protectionStateAttribute))
	}

	suspensionStateAttribute, ok := attributes["suspension_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`suspension_state is missing from object`)

		return nil, diags
	}

	suspensionStateVal, ok := suspensionStateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`suspension_state expected to be ovhtypes.TfStringValue, was: %T`, suspensionStateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateValue{
		AdditionalStates: additionalStatesVal,
		DnsConfiguration: dnsConfigurationVal,
		Extension:        extensionVal,
		MainState:        mainStateVal,
		Name:             nameVal,
		ProtectionState:  protectionStateVal,
		SuspensionState:  suspensionStateVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateValueNull() CurrentStateValue {
	return CurrentStateValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateValueUnknown() CurrentStateValue {
	return CurrentStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateValue Attribute Value",
				"While creating a CurrentStateValue value, a missing attribute value was detected. "+
					"A CurrentStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateValue Attribute Type",
				"While creating a CurrentStateValue value, an invalid attribute value was detected. "+
					"A CurrentStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateValue Attribute Value",
				"While creating a CurrentStateValue value, an extra attribute value was detected. "+
					"A CurrentStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateValueUnknown(), diags
	}

	additionalStatesAttribute, ok := attributes["additional_states"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_states is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	additionalStatesVal, ok := additionalStatesAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_states expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, additionalStatesAttribute))
	}

	dnsConfigurationAttribute, ok := attributes["dns_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_configuration is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	dnsConfigurationVal, ok := dnsConfigurationAttribute.(CurrentStateDnsConfigurationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_configuration expected to be CurrentStateDnsConfigurationValue, was: %T`, dnsConfigurationAttribute))
	}

	extensionAttribute, ok := attributes["extension"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extension is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	extensionVal, ok := extensionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extension expected to be ovhtypes.TfStringValue, was: %T`, extensionAttribute))
	}

	mainStateAttribute, ok := attributes["main_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`main_state is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	mainStateVal, ok := mainStateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`main_state expected to be ovhtypes.TfStringValue, was: %T`, mainStateAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protectionStateAttribute, ok := attributes["protection_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protection_state is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	protectionStateVal, ok := protectionStateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protection_state expected to be ovhtypes.TfStringValue, was: %T`, protectionStateAttribute))
	}

	suspensionStateAttribute, ok := attributes["suspension_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`suspension_state is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	suspensionStateVal, ok := suspensionStateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`suspension_state expected to be ovhtypes.TfStringValue, was: %T`, suspensionStateAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateValueUnknown(), diags
	}

	return CurrentStateValue{
		AdditionalStates: additionalStatesVal,
		DnsConfiguration: dnsConfigurationVal,
		Extension:        extensionVal,
		MainState:        mainStateVal,
		Name:             nameVal,
		ProtectionState:  protectionStateVal,
		SuspensionState:  suspensionStateVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateValue {
	object, diags := NewCurrentStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateValueMust(CurrentStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateValue{}
}

var _ basetypes.ObjectValuable = CurrentStateValue{}

type CurrentStateValue struct {
	AdditionalStates ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"additional_states" json:"additionalStates"`
	DnsConfiguration CurrentStateDnsConfigurationValue                  `tfsdk:"dns_configuration" json:"dnsConfiguration"`
	Extension        ovhtypes.TfStringValue                             `tfsdk:"extension" json:"extension"`
	MainState        ovhtypes.TfStringValue                             `tfsdk:"main_state" json:"mainState"`
	Name             ovhtypes.TfStringValue                             `tfsdk:"name" json:"name"`
	ProtectionState  ovhtypes.TfStringValue                             `tfsdk:"protection_state" json:"protectionState"`
	SuspensionState  ovhtypes.TfStringValue                             `tfsdk:"suspension_state" json:"suspensionState"`
	state            attr.ValueState
}

func (v *CurrentStateValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateValue CurrentStateValue

	var tmp JsonCurrentStateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.AdditionalStates = tmp.AdditionalStates
	v.DnsConfiguration = tmp.DnsConfiguration
	v.Extension = tmp.Extension
	v.MainState = tmp.MainState
	v.Name = tmp.Name
	v.ProtectionState = tmp.ProtectionState
	v.SuspensionState = tmp.SuspensionState

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateValue) MergeWith(other *CurrentStateValue) {

	if (v.AdditionalStates.IsUnknown() || v.AdditionalStates.IsNull()) && !other.AdditionalStates.IsUnknown() {
		v.AdditionalStates = other.AdditionalStates
	}

	if v.DnsConfiguration.IsUnknown() && !other.DnsConfiguration.IsUnknown() {
		v.DnsConfiguration = other.DnsConfiguration
	} else if !other.DnsConfiguration.IsUnknown() {
		v.DnsConfiguration.MergeWith(&other.DnsConfiguration)
	}

	if (v.Extension.IsUnknown() || v.Extension.IsNull()) && !other.Extension.IsUnknown() {
		v.Extension = other.Extension
	}

	if (v.MainState.IsUnknown() || v.MainState.IsNull()) && !other.MainState.IsUnknown() {
		v.MainState = other.MainState
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.ProtectionState.IsUnknown() || v.ProtectionState.IsNull()) && !other.ProtectionState.IsUnknown() {
		v.ProtectionState = other.ProtectionState
	}

	if (v.SuspensionState.IsUnknown() || v.SuspensionState.IsNull()) && !other.SuspensionState.IsUnknown() {
		v.SuspensionState = other.SuspensionState
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"additionalStates": v.AdditionalStates,
		"dnsConfiguration": v.DnsConfiguration,
		"extension":        v.Extension,
		"mainState":        v.MainState,
		"name":             v.Name,
		"protectionState":  v.ProtectionState,
		"suspensionState":  v.SuspensionState,
	}
}
func (v CurrentStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["additional_states"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_configuration"] = basetypes.ObjectType{
		AttrTypes: CurrentStateDnsConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["extension"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["main_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protection_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["suspension_state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AdditionalStates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_states"] = val

		val, err = v.DnsConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_configuration"] = val

		val, err = v.Extension.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extension"] = val

		val, err = v.MainState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["main_state"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ProtectionState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protection_state"] = val

		val, err = v.SuspensionState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["suspension_state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateValue) String() string {
	return "CurrentStateValue"
}

func (v CurrentStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"additional_states": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
			"dns_configuration": CurrentStateDnsConfigurationType{
				basetypes.ObjectType{
					AttrTypes: CurrentStateDnsConfigurationValue{}.AttributeTypes(ctx),
				},
			},
			"extension":        ovhtypes.TfStringType{},
			"main_state":       ovhtypes.TfStringType{},
			"name":             ovhtypes.TfStringType{},
			"protection_state": ovhtypes.TfStringType{},
			"suspension_state": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"additional_states": v.AdditionalStates,
			"dns_configuration": v.DnsConfiguration,
			"extension":         v.Extension,
			"main_state":        v.MainState,
			"name":              v.Name,
			"protection_state":  v.ProtectionState,
			"suspension_state":  v.SuspensionState,
		})

	return objVal, diags
}

func (v CurrentStateValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalStates.Equal(other.AdditionalStates) {
		return false
	}

	if !v.DnsConfiguration.Equal(other.DnsConfiguration) {
		return false
	}

	if !v.Extension.Equal(other.Extension) {
		return false
	}

	if !v.MainState.Equal(other.MainState) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ProtectionState.Equal(other.ProtectionState) {
		return false
	}

	if !v.SuspensionState.Equal(other.SuspensionState) {
		return false
	}

	return true
}

func (v CurrentStateValue) Type(ctx context.Context) attr.Type {
	return CurrentStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_states": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		"dns_configuration": CurrentStateDnsConfigurationValue{}.Type(ctx),
		"extension":         ovhtypes.TfStringType{},
		"main_state":        ovhtypes.TfStringType{},
		"name":              ovhtypes.TfStringType{},
		"protection_state":  ovhtypes.TfStringType{},
		"suspension_state":  ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateDnsConfigurationType{}

type CurrentStateDnsConfigurationType struct {
	basetypes.ObjectType
}

func (t CurrentStateDnsConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateDnsConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateDnsConfigurationType) String() string {
	return "CurrentStateDnsConfigurationType"
}

func (t CurrentStateDnsConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configurationTypeAttribute, ok := attributes["configuration_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration_type is missing from object`)

		return nil, diags
	}

	configurationTypeVal, ok := configurationTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration_type expected to be ovhtypes.TfStringValue, was: %T`, configurationTypeAttribute))
	}

	glueRecordIpv6supportedAttribute, ok := attributes["glue_record_ipv6supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`glue_record_ipv6supported is missing from object`)

		return nil, diags
	}

	glueRecordIpv6supportedVal, ok := glueRecordIpv6supportedAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`glue_record_ipv6supported expected to be ovhtypes.TfBoolValue, was: %T`, glueRecordIpv6supportedAttribute))
	}

	hostSupportedAttribute, ok := attributes["host_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_supported is missing from object`)

		return nil, diags
	}

	hostSupportedVal, ok := hostSupportedAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_supported expected to be ovhtypes.TfBoolValue, was: %T`, hostSupportedAttribute))
	}

	maxDnsAttribute, ok := attributes["max_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_dns is missing from object`)

		return nil, diags
	}

	maxDnsVal, ok := maxDnsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_dns expected to be ovhtypes.TfInt64Value, was: %T`, maxDnsAttribute))
	}

	minDnsAttribute, ok := attributes["min_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_dns is missing from object`)

		return nil, diags
	}

	minDnsVal, ok := minDnsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_dns expected to be ovhtypes.TfInt64Value, was: %T`, minDnsAttribute))
	}

	nameServersAttribute, ok := attributes["name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_servers is missing from object`)

		return nil, diags
	}

	nameServersVal, ok := nameServersAttribute.(ovhtypes.TfListNestedValue[CurrentStateDnsConfigurationNameServersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_servers expected to be ovhtypes.TfListNestedValue[CurrentStateDnsConfigurationNameServersValue], was: %T`, nameServersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateDnsConfigurationValue{
		ConfigurationType:       configurationTypeVal,
		GlueRecordIpv6supported: glueRecordIpv6supportedVal,
		HostSupported:           hostSupportedVal,
		MaxDns:                  maxDnsVal,
		MinDns:                  minDnsVal,
		NameServers:             nameServersVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateDnsConfigurationValueNull() CurrentStateDnsConfigurationValue {
	return CurrentStateDnsConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateDnsConfigurationValueUnknown() CurrentStateDnsConfigurationValue {
	return CurrentStateDnsConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateDnsConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateDnsConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateDnsConfigurationValue Attribute Value",
				"While creating a CurrentStateDnsConfigurationValue value, a missing attribute value was detected. "+
					"A CurrentStateDnsConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateDnsConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateDnsConfigurationValue Attribute Type",
				"While creating a CurrentStateDnsConfigurationValue value, an invalid attribute value was detected. "+
					"A CurrentStateDnsConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateDnsConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateDnsConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateDnsConfigurationValue Attribute Value",
				"While creating a CurrentStateDnsConfigurationValue value, an extra attribute value was detected. "+
					"A CurrentStateDnsConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateDnsConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	configurationTypeAttribute, ok := attributes["configuration_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration_type is missing from object`)

		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	configurationTypeVal, ok := configurationTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration_type expected to be ovhtypes.TfStringValue, was: %T`, configurationTypeAttribute))
	}

	glueRecordIpv6supportedAttribute, ok := attributes["glue_record_ipv6supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`glue_record_ipv6supported is missing from object`)

		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	glueRecordIpv6supportedVal, ok := glueRecordIpv6supportedAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`glue_record_ipv6supported expected to be ovhtypes.TfBoolValue, was: %T`, glueRecordIpv6supportedAttribute))
	}

	hostSupportedAttribute, ok := attributes["host_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_supported is missing from object`)

		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	hostSupportedVal, ok := hostSupportedAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_supported expected to be ovhtypes.TfBoolValue, was: %T`, hostSupportedAttribute))
	}

	maxDnsAttribute, ok := attributes["max_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_dns is missing from object`)

		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	maxDnsVal, ok := maxDnsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_dns expected to be ovhtypes.TfInt64Value, was: %T`, maxDnsAttribute))
	}

	minDnsAttribute, ok := attributes["min_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_dns is missing from object`)

		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	minDnsVal, ok := minDnsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_dns expected to be ovhtypes.TfInt64Value, was: %T`, minDnsAttribute))
	}

	nameServersAttribute, ok := attributes["name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_servers is missing from object`)

		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	nameServersVal, ok := nameServersAttribute.(ovhtypes.TfListNestedValue[CurrentStateDnsConfigurationNameServersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_servers expected to be ovhtypes.TfListNestedValue[CurrentStateDnsConfigurationNameServersValue], was: %T`, nameServersAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateDnsConfigurationValueUnknown(), diags
	}

	return CurrentStateDnsConfigurationValue{
		ConfigurationType:       configurationTypeVal,
		GlueRecordIpv6supported: glueRecordIpv6supportedVal,
		HostSupported:           hostSupportedVal,
		MaxDns:                  maxDnsVal,
		MinDns:                  minDnsVal,
		NameServers:             nameServersVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateDnsConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateDnsConfigurationValue {
	object, diags := NewCurrentStateDnsConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateDnsConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateDnsConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateDnsConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateDnsConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateDnsConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateDnsConfigurationValueMust(CurrentStateDnsConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateDnsConfigurationType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateDnsConfigurationValue{}
}

var _ basetypes.ObjectValuable = CurrentStateDnsConfigurationValue{}

type CurrentStateDnsConfigurationValue struct {
	ConfigurationType       ovhtypes.TfStringValue                                                   `tfsdk:"configuration_type" json:"configurationType"`
	GlueRecordIpv6supported ovhtypes.TfBoolValue                                                     `tfsdk:"glue_record_ipv6supported" json:"glueRecordIpv6supported"`
	HostSupported           ovhtypes.TfBoolValue                                                     `tfsdk:"host_supported" json:"hostSupported"`
	MaxDns                  ovhtypes.TfInt64Value                                                    `tfsdk:"max_dns" json:"maxDns"`
	MinDns                  ovhtypes.TfInt64Value                                                    `tfsdk:"min_dns" json:"minDns"`
	NameServers             ovhtypes.TfListNestedValue[CurrentStateDnsConfigurationNameServersValue] `tfsdk:"name_servers" json:"nameServers"`
	state                   attr.ValueState
}

type CurrentStateDnsConfigurationWritableValue struct {
	*CurrentStateDnsConfigurationValue `json:"-"`
	GlueRecordIpv6supported            *ovhtypes.TfBoolValue `json:"glueRecordIpv6supported,omitempty"`
	HostSupported                      *ovhtypes.TfBoolValue `json:"hostSupported,omitempty"`
}

func (v CurrentStateDnsConfigurationValue) ToCreate() *CurrentStateDnsConfigurationWritableValue {
	res := &CurrentStateDnsConfigurationWritableValue{}

	if !v.GlueRecordIpv6supported.IsNull() {
		res.GlueRecordIpv6supported = &v.GlueRecordIpv6supported
	}

	if !v.HostSupported.IsNull() {
		res.HostSupported = &v.HostSupported
	}

	return res
}

func (v *CurrentStateDnsConfigurationValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateDnsConfigurationValue CurrentStateDnsConfigurationValue

	var tmp JsonCurrentStateDnsConfigurationValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.ConfigurationType = tmp.ConfigurationType
	v.GlueRecordIpv6supported = tmp.GlueRecordIpv6supported
	v.HostSupported = tmp.HostSupported
	v.MaxDns = tmp.MaxDns
	v.MinDns = tmp.MinDns
	v.NameServers = tmp.NameServers

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateDnsConfigurationValue) MergeWith(other *CurrentStateDnsConfigurationValue) {

	if (v.ConfigurationType.IsUnknown() || v.ConfigurationType.IsNull()) && !other.ConfigurationType.IsUnknown() {
		v.ConfigurationType = other.ConfigurationType
	}

	if (v.GlueRecordIpv6supported.IsUnknown() || v.GlueRecordIpv6supported.IsNull()) && !other.GlueRecordIpv6supported.IsUnknown() {
		v.GlueRecordIpv6supported = other.GlueRecordIpv6supported
	}

	if (v.HostSupported.IsUnknown() || v.HostSupported.IsNull()) && !other.HostSupported.IsUnknown() {
		v.HostSupported = other.HostSupported
	}

	if (v.MaxDns.IsUnknown() || v.MaxDns.IsNull()) && !other.MaxDns.IsUnknown() {
		v.MaxDns = other.MaxDns
	}

	if (v.MinDns.IsUnknown() || v.MinDns.IsNull()) && !other.MinDns.IsUnknown() {
		v.MinDns = other.MinDns
	}

	if (v.NameServers.IsUnknown() || v.NameServers.IsNull()) && !other.NameServers.IsUnknown() {
		v.NameServers = other.NameServers
	} else if !other.NameServers.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.NameServers.Elements()
		newElems := other.NameServers.Elements()

		if len(elems) != len(newElems) {
			v.NameServers = other.NameServers
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentStateDnsConfigurationNameServersValue)
				tmp2 := newElems[idx].(CurrentStateDnsConfigurationNameServersValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.NameServers = ovhtypes.TfListNestedValue[CurrentStateDnsConfigurationNameServersValue]{
				ListValue: basetypes.NewListValueMust(CurrentStateDnsConfigurationNameServersValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateDnsConfigurationValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"configurationType":       v.ConfigurationType,
		"glueRecordIpv6supported": v.GlueRecordIpv6supported,
		"hostSupported":           v.HostSupported,
		"maxDns":                  v.MaxDns,
		"minDns":                  v.MinDns,
		"nameServers":             v.NameServers,
	}
}
func (v CurrentStateDnsConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["configuration_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["glue_record_ipv6supported"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host_supported"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_dns"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_dns"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name_servers"] = basetypes.ListType{
		ElemType: CurrentStateDnsConfigurationNameServersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.ConfigurationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configuration_type"] = val

		val, err = v.GlueRecordIpv6supported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["glue_record_ipv6supported"] = val

		val, err = v.HostSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host_supported"] = val

		val, err = v.MaxDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_dns"] = val

		val, err = v.MinDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_dns"] = val

		val, err = v.NameServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_servers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateDnsConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateDnsConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateDnsConfigurationValue) String() string {
	return "CurrentStateDnsConfigurationValue"
}

func (v CurrentStateDnsConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"configuration_type":        ovhtypes.TfStringType{},
			"glue_record_ipv6supported": ovhtypes.TfBoolType{},
			"host_supported":            ovhtypes.TfBoolType{},
			"max_dns":                   ovhtypes.TfInt64Type{},
			"min_dns":                   ovhtypes.TfInt64Type{},
			"name_servers":              ovhtypes.NewTfListNestedType[CurrentStateDnsConfigurationNameServersValue](ctx),
		},
		map[string]attr.Value{
			"configuration_type":        v.ConfigurationType,
			"glue_record_ipv6supported": v.GlueRecordIpv6supported,
			"host_supported":            v.HostSupported,
			"max_dns":                   v.MaxDns,
			"min_dns":                   v.MinDns,
			"name_servers":              v.NameServers,
		})

	return objVal, diags
}

func (v CurrentStateDnsConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateDnsConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfigurationType.Equal(other.ConfigurationType) {
		return false
	}

	if !v.GlueRecordIpv6supported.Equal(other.GlueRecordIpv6supported) {
		return false
	}

	if !v.HostSupported.Equal(other.HostSupported) {
		return false
	}

	if !v.MaxDns.Equal(other.MaxDns) {
		return false
	}

	if !v.MinDns.Equal(other.MinDns) {
		return false
	}

	if !v.NameServers.Equal(other.NameServers) {
		return false
	}

	return true
}

func (v CurrentStateDnsConfigurationValue) Type(ctx context.Context) attr.Type {
	return CurrentStateDnsConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateDnsConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configuration_type":        ovhtypes.TfStringType{},
		"glue_record_ipv6supported": ovhtypes.TfBoolType{},
		"host_supported":            ovhtypes.TfBoolType{},
		"max_dns":                   ovhtypes.TfInt64Type{},
		"min_dns":                   ovhtypes.TfInt64Type{},
		"name_servers":              ovhtypes.NewTfListNestedType[CurrentStateDnsConfigurationNameServersValue](ctx),
	}
}

var _ basetypes.ObjectTypable = CurrentStateDnsConfigurationNameServersType{}

type CurrentStateDnsConfigurationNameServersType struct {
	basetypes.ObjectType
}

func (t CurrentStateDnsConfigurationNameServersType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateDnsConfigurationNameServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateDnsConfigurationNameServersType) String() string {
	return "CurrentStateDnsConfigurationNameServersType"
}

func (t CurrentStateDnsConfigurationNameServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return nil, diags
	}

	ipv4Val, ok := ipv4Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be ovhtypes.TfStringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return nil, diags
	}

	ipv6Val, ok := ipv6Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be ovhtypes.TfStringValue, was: %T`, ipv6Attribute))
	}

	nameServerAttribute, ok := attributes["name_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_server is missing from object`)

		return nil, diags
	}

	nameServerVal, ok := nameServerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_server expected to be ovhtypes.TfStringValue, was: %T`, nameServerAttribute))
	}

	nameServerTypeAttribute, ok := attributes["name_server_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_server_type is missing from object`)

		return nil, diags
	}

	nameServerTypeVal, ok := nameServerTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_server_type expected to be ovhtypes.TfStringValue, was: %T`, nameServerTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateDnsConfigurationNameServersValue{
		Ipv4:           ipv4Val,
		Ipv6:           ipv6Val,
		NameServer:     nameServerVal,
		NameServerType: nameServerTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateDnsConfigurationNameServersValueNull() CurrentStateDnsConfigurationNameServersValue {
	return CurrentStateDnsConfigurationNameServersValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateDnsConfigurationNameServersValueUnknown() CurrentStateDnsConfigurationNameServersValue {
	return CurrentStateDnsConfigurationNameServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateDnsConfigurationNameServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateDnsConfigurationNameServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateDnsConfigurationNameServersValue Attribute Value",
				"While creating a CurrentStateDnsConfigurationNameServersValue value, a missing attribute value was detected. "+
					"A CurrentStateDnsConfigurationNameServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateDnsConfigurationNameServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateDnsConfigurationNameServersValue Attribute Type",
				"While creating a CurrentStateDnsConfigurationNameServersValue value, an invalid attribute value was detected. "+
					"A CurrentStateDnsConfigurationNameServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateDnsConfigurationNameServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateDnsConfigurationNameServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateDnsConfigurationNameServersValue Attribute Value",
				"While creating a CurrentStateDnsConfigurationNameServersValue value, an extra attribute value was detected. "+
					"A CurrentStateDnsConfigurationNameServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateDnsConfigurationNameServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateDnsConfigurationNameServersValueUnknown(), diags
	}

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return NewCurrentStateDnsConfigurationNameServersValueUnknown(), diags
	}

	ipv4Val, ok := ipv4Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be ovhtypes.TfStringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return NewCurrentStateDnsConfigurationNameServersValueUnknown(), diags
	}

	ipv6Val, ok := ipv6Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be ovhtypes.TfStringValue, was: %T`, ipv6Attribute))
	}

	nameServerAttribute, ok := attributes["name_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_server is missing from object`)

		return NewCurrentStateDnsConfigurationNameServersValueUnknown(), diags
	}

	nameServerVal, ok := nameServerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_server expected to be ovhtypes.TfStringValue, was: %T`, nameServerAttribute))
	}

	nameServerTypeAttribute, ok := attributes["name_server_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_server_type is missing from object`)

		return NewCurrentStateDnsConfigurationNameServersValueUnknown(), diags
	}

	nameServerTypeVal, ok := nameServerTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_server_type expected to be ovhtypes.TfStringValue, was: %T`, nameServerTypeAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateDnsConfigurationNameServersValueUnknown(), diags
	}

	return CurrentStateDnsConfigurationNameServersValue{
		Ipv4:           ipv4Val,
		Ipv6:           ipv6Val,
		NameServer:     nameServerVal,
		NameServerType: nameServerTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateDnsConfigurationNameServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateDnsConfigurationNameServersValue {
	object, diags := NewCurrentStateDnsConfigurationNameServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateDnsConfigurationNameServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateDnsConfigurationNameServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateDnsConfigurationNameServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateDnsConfigurationNameServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateDnsConfigurationNameServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateDnsConfigurationNameServersValueMust(CurrentStateDnsConfigurationNameServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateDnsConfigurationNameServersType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateDnsConfigurationNameServersValue{}
}

var _ basetypes.ObjectValuable = CurrentStateDnsConfigurationNameServersValue{}

type CurrentStateDnsConfigurationNameServersValue struct {
	Ipv4           ovhtypes.TfStringValue `tfsdk:"ipv4" json:"ipv4"`
	Ipv6           ovhtypes.TfStringValue `tfsdk:"ipv6" json:"ipv6"`
	NameServer     ovhtypes.TfStringValue `tfsdk:"name_server" json:"nameServer"`
	NameServerType ovhtypes.TfStringValue `tfsdk:"name_server_type" json:"nameServerType"`
	state          attr.ValueState
}

func (v *CurrentStateDnsConfigurationNameServersValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateDnsConfigurationNameServersValue CurrentStateDnsConfigurationNameServersValue

	var tmp JsonCurrentStateDnsConfigurationNameServersValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Ipv4 = tmp.Ipv4
	v.Ipv6 = tmp.Ipv6
	v.NameServer = tmp.NameServer
	v.NameServerType = tmp.NameServerType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateDnsConfigurationNameServersValue) MergeWith(other *CurrentStateDnsConfigurationNameServersValue) {

	if (v.Ipv4.IsUnknown() || v.Ipv4.IsNull()) && !other.Ipv4.IsUnknown() {
		v.Ipv4 = other.Ipv4
	}

	if (v.Ipv6.IsUnknown() || v.Ipv6.IsNull()) && !other.Ipv6.IsUnknown() {
		v.Ipv6 = other.Ipv6
	}

	if (v.NameServer.IsUnknown() || v.NameServer.IsNull()) && !other.NameServer.IsUnknown() {
		v.NameServer = other.NameServer
	}

	if (v.NameServerType.IsUnknown() || v.NameServerType.IsNull()) && !other.NameServerType.IsUnknown() {
		v.NameServerType = other.NameServerType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateDnsConfigurationNameServersValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"ipv4":           v.Ipv4,
		"ipv6":           v.Ipv6,
		"nameServer":     v.NameServer,
		"nameServerType": v.NameServerType,
	}
}
func (v CurrentStateDnsConfigurationNameServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name_server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name_server_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Ipv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4"] = val

		val, err = v.Ipv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6"] = val

		val, err = v.NameServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_server"] = val

		val, err = v.NameServerType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_server_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateDnsConfigurationNameServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateDnsConfigurationNameServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateDnsConfigurationNameServersValue) String() string {
	return "CurrentStateDnsConfigurationNameServersValue"
}

func (v CurrentStateDnsConfigurationNameServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ipv4":             ovhtypes.TfStringType{},
			"ipv6":             ovhtypes.TfStringType{},
			"name_server":      ovhtypes.TfStringType{},
			"name_server_type": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"ipv4":             v.Ipv4,
			"ipv6":             v.Ipv6,
			"name_server":      v.NameServer,
			"name_server_type": v.NameServerType,
		})

	return objVal, diags
}

func (v CurrentStateDnsConfigurationNameServersValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateDnsConfigurationNameServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv4.Equal(other.Ipv4) {
		return false
	}

	if !v.Ipv6.Equal(other.Ipv6) {
		return false
	}

	if !v.NameServer.Equal(other.NameServer) {
		return false
	}

	if !v.NameServerType.Equal(other.NameServerType) {
		return false
	}

	return true
}

func (v CurrentStateDnsConfigurationNameServersValue) Type(ctx context.Context) attr.Type {
	return CurrentStateDnsConfigurationNameServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateDnsConfigurationNameServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv4":             ovhtypes.TfStringType{},
		"ipv6":             ovhtypes.TfStringType{},
		"name_server":      ovhtypes.TfStringType{},
		"name_server_type": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentTasksType{}

type CurrentTasksType struct {
	basetypes.ObjectType
}

func (t CurrentTasksType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentTasksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentTasksType) String() string {
	return "CurrentTasksType"
}

func (t CurrentTasksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return nil, diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentTasksValue{
		Id:               idVal,
		Link:             linkVal,
		Status:           statusVal,
		CurrentTasksType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentTasksValueNull() CurrentTasksValue {
	return CurrentTasksValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentTasksValueUnknown() CurrentTasksValue {
	return CurrentTasksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentTasksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentTasksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentTasksValue Attribute Value",
				"While creating a CurrentTasksValue value, a missing attribute value was detected. "+
					"A CurrentTasksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentTasksValue Attribute Type",
				"While creating a CurrentTasksValue value, an invalid attribute value was detected. "+
					"A CurrentTasksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentTasksValue Attribute Value",
				"While creating a CurrentTasksValue value, an extra attribute value was detected. "+
					"A CurrentTasksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentTasksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentTasksValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewCurrentTasksValueUnknown(), diags
	}

	return CurrentTasksValue{
		Id:               idVal,
		Link:             linkVal,
		Status:           statusVal,
		CurrentTasksType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentTasksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentTasksValue {
	object, diags := NewCurrentTasksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentTasksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentTasksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentTasksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentTasksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentTasksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentTasksValueMust(CurrentTasksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentTasksType) ValueType(ctx context.Context) attr.Value {
	return CurrentTasksValue{}
}

var _ basetypes.ObjectValuable = CurrentTasksValue{}

type CurrentTasksValue struct {
	Id               ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	Link             ovhtypes.TfStringValue `tfsdk:"link" json:"link"`
	Status           ovhtypes.TfStringValue `tfsdk:"status" json:"status"`
	CurrentTasksType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state            attr.ValueState
}

func (v *CurrentTasksValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentTasksValue CurrentTasksValue

	var tmp JsonCurrentTasksValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id
	v.Link = tmp.Link
	v.Status = tmp.Status
	v.CurrentTasksType = tmp.CurrentTasksType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentTasksValue) MergeWith(other *CurrentTasksValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Link.IsUnknown() || v.Link.IsNull()) && !other.Link.IsUnknown() {
		v.Link = other.Link
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.CurrentTasksType.IsUnknown() || v.CurrentTasksType.IsNull()) && !other.CurrentTasksType.IsUnknown() {
		v.CurrentTasksType = other.CurrentTasksType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentTasksValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id":     v.Id,
		"link":   v.Link,
		"status": v.Status,
		"type":   v.CurrentTasksType,
	}
}
func (v CurrentTasksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Link.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.CurrentTasksType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentTasksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentTasksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentTasksValue) String() string {
	return "CurrentTasksValue"
}

func (v CurrentTasksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":     ovhtypes.TfStringType{},
			"link":   ovhtypes.TfStringType{},
			"status": ovhtypes.TfStringType{},
			"type":   ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id":     v.Id,
			"link":   v.Link,
			"status": v.Status,
			"type":   v.CurrentTasksType,
		})

	return objVal, diags
}

func (v CurrentTasksValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentTasksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Link.Equal(other.Link) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.CurrentTasksType.Equal(other.CurrentTasksType) {
		return false
	}

	return true
}

func (v CurrentTasksValue) Type(ctx context.Context) attr.Type {
	return CurrentTasksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentTasksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":     ovhtypes.TfStringType{},
		"link":   ovhtypes.TfStringType{},
		"status": ovhtypes.TfStringType{},
		"type":   ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TargetSpecType{}

type TargetSpecType struct {
	basetypes.ObjectType
}

func (t TargetSpecType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecType) String() string {
	return "TargetSpecType"
}

func (t TargetSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsConfigurationAttribute, ok := attributes["dns_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_configuration is missing from object`)

		return nil, diags
	}

	dnsConfigurationVal, ok := dnsConfigurationAttribute.(TargetSpecDnsConfigurationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_configuration expected to be TargetSpecDnsConfigurationValue, was: %T`, dnsConfigurationAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecValue{
		DnsConfiguration: dnsConfigurationVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecValueNull() TargetSpecValue {
	return TargetSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecValueUnknown() TargetSpecValue {
	return TargetSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecValue Attribute Value",
				"While creating a TargetSpecValue value, a missing attribute value was detected. "+
					"A TargetSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecValue Attribute Type",
				"While creating a TargetSpecValue value, an invalid attribute value was detected. "+
					"A TargetSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecValue Attribute Value",
				"While creating a TargetSpecValue value, an extra attribute value was detected. "+
					"A TargetSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecValueUnknown(), diags
	}

	dnsConfigurationAttribute, ok := attributes["dns_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_configuration is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	dnsConfigurationVal, ok := dnsConfigurationAttribute.(TargetSpecDnsConfigurationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_configuration expected to be TargetSpecDnsConfigurationValue, was: %T`, dnsConfigurationAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecValueUnknown(), diags
	}

	return TargetSpecValue{
		DnsConfiguration: dnsConfigurationVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecValue {
	object, diags := NewTargetSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecValueMust(TargetSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecValue{}
}

var _ basetypes.ObjectValuable = TargetSpecValue{}

type TargetSpecValue struct {
	DnsConfiguration TargetSpecDnsConfigurationValue `tfsdk:"dns_configuration" json:"dnsConfiguration"`
	state            attr.ValueState
}

type TargetSpecWritableValue struct {
	*TargetSpecValue `json:"-"`
	DnsConfiguration *TargetSpecDnsConfigurationWritableValue `json:"dnsConfiguration,omitempty"`
}

func (v TargetSpecValue) ToCreate() *TargetSpecWritableValue {
	res := &TargetSpecWritableValue{}

	if !v.DnsConfiguration.IsNull() {
		res.DnsConfiguration = v.DnsConfiguration.ToCreate()
	}

	return res
}

func (v TargetSpecValue) ToUpdate() *TargetSpecWritableValue {
	res := &TargetSpecWritableValue{}

	if !v.DnsConfiguration.IsNull() {
		res.DnsConfiguration = v.DnsConfiguration.ToUpdate()
	}

	return res
}

func (v *TargetSpecValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecValue TargetSpecValue

	var tmp JsonTargetSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DnsConfiguration = tmp.DnsConfiguration

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecValue) MergeWith(other *TargetSpecValue) {

	if v.DnsConfiguration.IsUnknown() && !other.DnsConfiguration.IsUnknown() {
		v.DnsConfiguration = other.DnsConfiguration
	} else if !other.DnsConfiguration.IsUnknown() {
		v.DnsConfiguration.MergeWith(&other.DnsConfiguration)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"dnsConfiguration": v.DnsConfiguration,
	}
}
func (v TargetSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["dns_configuration"] = basetypes.ObjectType{
		AttrTypes: TargetSpecDnsConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DnsConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_configuration"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecValue) String() string {
	return "TargetSpecValue"
}

func (v TargetSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"dns_configuration": TargetSpecDnsConfigurationType{
				basetypes.ObjectType{
					AttrTypes: TargetSpecDnsConfigurationValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"dns_configuration": v.DnsConfiguration,
		})

	return objVal, diags
}

func (v TargetSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DnsConfiguration.Equal(other.DnsConfiguration) {
		return false
	}

	return true
}

func (v TargetSpecValue) Type(ctx context.Context) attr.Type {
	return TargetSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns_configuration": TargetSpecDnsConfigurationValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = TargetSpecDnsConfigurationType{}

type TargetSpecDnsConfigurationType struct {
	basetypes.ObjectType
}

func (t TargetSpecDnsConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecDnsConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecDnsConfigurationType) String() string {
	return "TargetSpecDnsConfigurationType"
}

func (t TargetSpecDnsConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameServersAttribute, ok := attributes["name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_servers is missing from object`)

		return nil, diags
	}

	nameServersVal, ok := nameServersAttribute.(ovhtypes.TfListNestedValue[TargetSpecDnsConfigurationNameServersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_servers expected to be ovhtypes.TfListNestedValue[TargetSpecDnsConfigurationNameServersValue], was: %T`, nameServersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecDnsConfigurationValue{
		NameServers: nameServersVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecDnsConfigurationValueNull() TargetSpecDnsConfigurationValue {
	return TargetSpecDnsConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecDnsConfigurationValueUnknown() TargetSpecDnsConfigurationValue {
	return TargetSpecDnsConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecDnsConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecDnsConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecDnsConfigurationValue Attribute Value",
				"While creating a TargetSpecDnsConfigurationValue value, a missing attribute value was detected. "+
					"A TargetSpecDnsConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecDnsConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecDnsConfigurationValue Attribute Type",
				"While creating a TargetSpecDnsConfigurationValue value, an invalid attribute value was detected. "+
					"A TargetSpecDnsConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecDnsConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecDnsConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecDnsConfigurationValue Attribute Value",
				"While creating a TargetSpecDnsConfigurationValue value, an extra attribute value was detected. "+
					"A TargetSpecDnsConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecDnsConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecDnsConfigurationValueUnknown(), diags
	}

	nameServersAttribute, ok := attributes["name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_servers is missing from object`)

		return NewTargetSpecDnsConfigurationValueUnknown(), diags
	}

	nameServersVal, ok := nameServersAttribute.(ovhtypes.TfListNestedValue[TargetSpecDnsConfigurationNameServersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_servers expected to be ovhtypes.TfListNestedValue[TargetSpecDnsConfigurationNameServersValue], was: %T`, nameServersAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecDnsConfigurationValueUnknown(), diags
	}

	return TargetSpecDnsConfigurationValue{
		NameServers: nameServersVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecDnsConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecDnsConfigurationValue {
	object, diags := NewTargetSpecDnsConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecDnsConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecDnsConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecDnsConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecDnsConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecDnsConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecDnsConfigurationValueMust(TargetSpecDnsConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecDnsConfigurationType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecDnsConfigurationValue{}
}

var _ basetypes.ObjectValuable = TargetSpecDnsConfigurationValue{}

type TargetSpecDnsConfigurationValue struct {
	NameServers ovhtypes.TfListNestedValue[TargetSpecDnsConfigurationNameServersValue] `tfsdk:"name_servers" json:"nameServers"`
	state       attr.ValueState
}

type TargetSpecDnsConfigurationWritableValue struct {
	*TargetSpecDnsConfigurationValue `json:"-"`
	NameServers                      *ovhtypes.TfListNestedValue[TargetSpecDnsConfigurationNameServersValue] `json:"nameServers,omitempty"`
}

func (v TargetSpecDnsConfigurationValue) ToCreate() *TargetSpecDnsConfigurationWritableValue {
	res := &TargetSpecDnsConfigurationWritableValue{}

	if !v.NameServers.IsNull() {
		res.NameServers = &v.NameServers
	}

	return res
}

func (v TargetSpecDnsConfigurationValue) ToUpdate() *TargetSpecDnsConfigurationWritableValue {
	res := &TargetSpecDnsConfigurationWritableValue{}

	if !v.NameServers.IsNull() {
		res.NameServers = &v.NameServers
	}

	return res
}

func (v *TargetSpecDnsConfigurationValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecDnsConfigurationValue TargetSpecDnsConfigurationValue

	var tmp JsonTargetSpecDnsConfigurationValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.NameServers = tmp.NameServers

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecDnsConfigurationValue) MergeWith(other *TargetSpecDnsConfigurationValue) {

	if (v.NameServers.IsUnknown() || v.NameServers.IsNull()) && !other.NameServers.IsUnknown() {
		v.NameServers = other.NameServers
	} else if !other.NameServers.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.NameServers.Elements()
		newElems := other.NameServers.Elements()

		if len(elems) != len(newElems) {
			v.NameServers = other.NameServers
		} else {
			for idx, e := range elems {
				tmp := e.(TargetSpecDnsConfigurationNameServersValue)
				tmp2 := newElems[idx].(TargetSpecDnsConfigurationNameServersValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.NameServers = ovhtypes.TfListNestedValue[TargetSpecDnsConfigurationNameServersValue]{
				ListValue: basetypes.NewListValueMust(TargetSpecDnsConfigurationNameServersValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecDnsConfigurationValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"nameServers": v.NameServers,
	}
}
func (v TargetSpecDnsConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name_servers"] = basetypes.ListType{
		ElemType: TargetSpecDnsConfigurationNameServersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.NameServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_servers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecDnsConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecDnsConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecDnsConfigurationValue) String() string {
	return "TargetSpecDnsConfigurationValue"
}

func (v TargetSpecDnsConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name_servers": ovhtypes.NewTfListNestedType[TargetSpecDnsConfigurationNameServersValue](ctx),
		},
		map[string]attr.Value{
			"name_servers": v.NameServers,
		})

	return objVal, diags
}

func (v TargetSpecDnsConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecDnsConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NameServers.Equal(other.NameServers) {
		return false
	}

	return true
}

func (v TargetSpecDnsConfigurationValue) Type(ctx context.Context) attr.Type {
	return TargetSpecDnsConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecDnsConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name_servers": ovhtypes.NewTfListNestedType[TargetSpecDnsConfigurationNameServersValue](ctx),
	}
}

var _ basetypes.ObjectTypable = TargetSpecDnsConfigurationNameServersType{}

type TargetSpecDnsConfigurationNameServersType struct {
	basetypes.ObjectType
}

func (t TargetSpecDnsConfigurationNameServersType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecDnsConfigurationNameServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecDnsConfigurationNameServersType) String() string {
	return "TargetSpecDnsConfigurationNameServersType"
}

func (t TargetSpecDnsConfigurationNameServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return nil, diags
	}

	ipv4Val, ok := ipv4Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be ovhtypes.TfStringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return nil, diags
	}

	ipv6Val, ok := ipv6Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be ovhtypes.TfStringValue, was: %T`, ipv6Attribute))
	}

	nameServerAttribute, ok := attributes["name_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_server is missing from object`)

		return nil, diags
	}

	nameServerVal, ok := nameServerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_server expected to be ovhtypes.TfStringValue, was: %T`, nameServerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecDnsConfigurationNameServersValue{
		Ipv4:       ipv4Val,
		Ipv6:       ipv6Val,
		NameServer: nameServerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecDnsConfigurationNameServersValueNull() TargetSpecDnsConfigurationNameServersValue {
	return TargetSpecDnsConfigurationNameServersValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecDnsConfigurationNameServersValueUnknown() TargetSpecDnsConfigurationNameServersValue {
	return TargetSpecDnsConfigurationNameServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecDnsConfigurationNameServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecDnsConfigurationNameServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecDnsConfigurationNameServersValue Attribute Value",
				"While creating a TargetSpecDnsConfigurationNameServersValue value, a missing attribute value was detected. "+
					"A TargetSpecDnsConfigurationNameServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecDnsConfigurationNameServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecDnsConfigurationNameServersValue Attribute Type",
				"While creating a TargetSpecDnsConfigurationNameServersValue value, an invalid attribute value was detected. "+
					"A TargetSpecDnsConfigurationNameServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecDnsConfigurationNameServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecDnsConfigurationNameServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecDnsConfigurationNameServersValue Attribute Value",
				"While creating a TargetSpecDnsConfigurationNameServersValue value, an extra attribute value was detected. "+
					"A TargetSpecDnsConfigurationNameServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecDnsConfigurationNameServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecDnsConfigurationNameServersValueUnknown(), diags
	}

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return NewTargetSpecDnsConfigurationNameServersValueUnknown(), diags
	}

	ipv4Val, ok := ipv4Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be ovhtypes.TfStringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return NewTargetSpecDnsConfigurationNameServersValueUnknown(), diags
	}

	ipv6Val, ok := ipv6Attribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be ovhtypes.TfStringValue, was: %T`, ipv6Attribute))
	}

	nameServerAttribute, ok := attributes["name_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_server is missing from object`)

		return NewTargetSpecDnsConfigurationNameServersValueUnknown(), diags
	}

	nameServerVal, ok := nameServerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_server expected to be ovhtypes.TfStringValue, was: %T`, nameServerAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecDnsConfigurationNameServersValueUnknown(), diags
	}

	return TargetSpecDnsConfigurationNameServersValue{
		Ipv4:       ipv4Val,
		Ipv6:       ipv6Val,
		NameServer: nameServerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecDnsConfigurationNameServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecDnsConfigurationNameServersValue {
	object, diags := NewTargetSpecDnsConfigurationNameServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecDnsConfigurationNameServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecDnsConfigurationNameServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecDnsConfigurationNameServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecDnsConfigurationNameServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecDnsConfigurationNameServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecDnsConfigurationNameServersValueMust(TargetSpecDnsConfigurationNameServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecDnsConfigurationNameServersType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecDnsConfigurationNameServersValue{}
}

var _ basetypes.ObjectValuable = TargetSpecDnsConfigurationNameServersValue{}

type TargetSpecDnsConfigurationNameServersValue struct {
	Ipv4       ovhtypes.TfStringValue `tfsdk:"ipv4" json:"ipv4"`
	Ipv6       ovhtypes.TfStringValue `tfsdk:"ipv6" json:"ipv6"`
	NameServer ovhtypes.TfStringValue `tfsdk:"name_server" json:"nameServer"`
	state      attr.ValueState
}

type TargetSpecDnsConfigurationNameServersWritableValue struct {
	*TargetSpecDnsConfigurationNameServersValue `json:"-"`
	Ipv4                                        *ovhtypes.TfStringValue `json:"ipv4,omitempty"`
	Ipv6                                        *ovhtypes.TfStringValue `json:"ipv6,omitempty"`
	NameServer                                  *ovhtypes.TfStringValue `json:"nameServer,omitempty"`
}

func (v TargetSpecDnsConfigurationNameServersValue) ToCreate() *TargetSpecDnsConfigurationNameServersWritableValue {
	res := &TargetSpecDnsConfigurationNameServersWritableValue{}

	if !v.Ipv4.IsNull() {
		res.Ipv4 = &v.Ipv4
	}

	if !v.Ipv6.IsNull() {
		res.Ipv6 = &v.Ipv6
	}

	if !v.NameServer.IsNull() {
		res.NameServer = &v.NameServer
	}

	return res
}

func (v TargetSpecDnsConfigurationNameServersValue) ToUpdate() *TargetSpecDnsConfigurationNameServersWritableValue {
	res := &TargetSpecDnsConfigurationNameServersWritableValue{}

	if !v.Ipv4.IsNull() {
		res.Ipv4 = &v.Ipv4
	}

	if !v.Ipv6.IsNull() {
		res.Ipv6 = &v.Ipv6
	}

	if !v.NameServer.IsNull() {
		res.NameServer = &v.NameServer
	}

	return res
}

func (v *TargetSpecDnsConfigurationNameServersValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecDnsConfigurationNameServersValue TargetSpecDnsConfigurationNameServersValue

	var tmp JsonTargetSpecDnsConfigurationNameServersValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Ipv4 = tmp.Ipv4
	v.Ipv6 = tmp.Ipv6
	v.NameServer = tmp.NameServer

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecDnsConfigurationNameServersValue) MergeWith(other *TargetSpecDnsConfigurationNameServersValue) {

	if (v.Ipv4.IsUnknown() || v.Ipv4.IsNull()) && !other.Ipv4.IsUnknown() {
		v.Ipv4 = other.Ipv4
	}

	if (v.Ipv6.IsUnknown() || v.Ipv6.IsNull()) && !other.Ipv6.IsUnknown() {
		v.Ipv6 = other.Ipv6
	}

	if (v.NameServer.IsUnknown() || v.NameServer.IsNull()) && !other.NameServer.IsUnknown() {
		v.NameServer = other.NameServer
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecDnsConfigurationNameServersValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"ipv4":       v.Ipv4,
		"ipv6":       v.Ipv6,
		"nameServer": v.NameServer,
	}
}
func (v TargetSpecDnsConfigurationNameServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name_server"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Ipv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4"] = val

		val, err = v.Ipv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6"] = val

		val, err = v.NameServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_server"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecDnsConfigurationNameServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecDnsConfigurationNameServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecDnsConfigurationNameServersValue) String() string {
	return "TargetSpecDnsConfigurationNameServersValue"
}

func (v TargetSpecDnsConfigurationNameServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ipv4":        ovhtypes.TfStringType{},
			"ipv6":        ovhtypes.TfStringType{},
			"name_server": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"ipv4":        v.Ipv4,
			"ipv6":        v.Ipv6,
			"name_server": v.NameServer,
		})

	return objVal, diags
}

func (v TargetSpecDnsConfigurationNameServersValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecDnsConfigurationNameServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv4.Equal(other.Ipv4) {
		return false
	}

	if !v.Ipv6.Equal(other.Ipv6) {
		return false
	}

	if !v.NameServer.Equal(other.NameServer) {
		return false
	}

	return true
}

func (v TargetSpecDnsConfigurationNameServersValue) Type(ctx context.Context) attr.Type {
	return TargetSpecDnsConfigurationNameServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecDnsConfigurationNameServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv4":        ovhtypes.TfStringType{},
		"ipv6":        ovhtypes.TfStringType{},
		"name_server": ovhtypes.TfStringType{},
	}
}
