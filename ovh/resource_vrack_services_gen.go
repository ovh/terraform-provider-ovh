// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func VrackServicesResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"checksum": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Description:         "Computed hash used to control concurrent modification requests. Here, it represents the target specification value the request is based on",
			MarkdownDescription: "Computed hash used to control concurrent modification requests. Here, it represents the target specification value the request is based on",
		},
		"created_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Date of the vRack Services delivery",
			MarkdownDescription: "Date of the vRack Services delivery",
		},
		"current_state": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Display name of the vRack Services",
					MarkdownDescription: "Display name of the vRack Services",
				},
				"product_status": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Product status of the vRack Services",
					MarkdownDescription: "Product status of the vRack Services",
				},
				"region": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Region of the vRack Services. List of compatible regions can be retrieved from /reference/region",
					MarkdownDescription: "Region of the vRack Services. List of compatible regions can be retrieved from /reference/region",
				},
				"subnets": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"cidr": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "IP address range of the subnet in CIDR format",
								MarkdownDescription: "IP address range of the subnet in CIDR format",
							},
							"display_name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Display name of the subnet",
								MarkdownDescription: "Display name of the subnet",
							},
							"service_endpoints": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"endpoints": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"description": schema.StringAttribute{
														CustomType:          ovhtypes.TfStringType{},
														Computed:            true,
														Description:         "IP description defined in the managed service",
														MarkdownDescription: "IP description defined in the managed service",
													},
													"ip": schema.StringAttribute{
														CustomType:          ovhtypes.TfStringType{},
														Computed:            true,
														Description:         "IP address assigned by OVHcloud",
														MarkdownDescription: "IP address assigned by OVHcloud",
													},
												},
												CustomType: CurrentStateSubnetsServiceEndpointsEndpointsType{
													ObjectType: types.ObjectType{
														AttrTypes: CurrentStateSubnetsServiceEndpointsEndpointsValue{}.AttributeTypes(ctx),
													},
												},
											},
											CustomType:          ovhtypes.NewTfListNestedType[CurrentStateSubnetsServiceEndpointsEndpointsValue](ctx),
											Computed:            true,
											Description:         "Endpoints representing the IPs assigned to the managed services",
											MarkdownDescription: "Endpoints representing the IPs assigned to the managed services",
										},
										"managed_service_urn": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Computed:            true,
											Description:         "IAM Resource URN of the managed service. Compatible managed service types are listed by /reference/compatibleManagedServiceType call.",
											MarkdownDescription: "IAM Resource URN of the managed service. Compatible managed service types are listed by /reference/compatibleManagedServiceType call.",
										},
									},
									CustomType: CurrentStateSubnetsServiceEndpointsType{
										ObjectType: types.ObjectType{
											AttrTypes: CurrentStateSubnetsServiceEndpointsValue{}.AttributeTypes(ctx),
										},
									},
								},
								CustomType:          ovhtypes.NewTfListNestedType[CurrentStateSubnetsServiceEndpointsValue](ctx),
								Computed:            true,
								Description:         "Service endpoints of the subnet",
								MarkdownDescription: "Service endpoints of the subnet",
							},
							"service_range": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"cidr": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "CIDR dedicated to the subnet's services",
										MarkdownDescription: "CIDR dedicated to the subnet's services",
									},
									"remaining_ips": schema.Int64Attribute{
										CustomType:          ovhtypes.TfInt64Type{},
										Computed:            true,
										Description:         "Number of remaining IPs in the service range",
										MarkdownDescription: "Number of remaining IPs in the service range",
									},
									"reserved_ips": schema.Int64Attribute{
										CustomType:          ovhtypes.TfInt64Type{},
										Computed:            true,
										Description:         "Number of service range IPs reserved by OVHcloud",
										MarkdownDescription: "Number of service range IPs reserved by OVHcloud",
									},
									"used_ips": schema.Int64Attribute{
										CustomType:          ovhtypes.TfInt64Type{},
										Computed:            true,
										Description:         "Number of service range IPs assigned to the managed services",
										MarkdownDescription: "Number of service range IPs assigned to the managed services",
									},
								},
								CustomType: CurrentStateSubnetsServiceRangeType{
									ObjectType: types.ObjectType{
										AttrTypes: CurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Defines a smaller subnet dedicated to the managed services IPs",
								MarkdownDescription: "Defines a smaller subnet dedicated to the managed services IPs",
							},
							"vlan": schema.Int64Attribute{
								CustomType:          ovhtypes.TfInt64Type{},
								Computed:            true,
								Description:         "Unique inner VLAN that allows subnets segregation",
								MarkdownDescription: "Unique inner VLAN that allows subnets segregation",
							},
						},
						CustomType: CurrentStateSubnetsType{
							ObjectType: types.ObjectType{
								AttrTypes: CurrentStateSubnetsValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[CurrentStateSubnetsValue](ctx),
					Computed:            true,
					Description:         "Subnets of the current vRack Services",
					MarkdownDescription: "Subnets of the current vRack Services",
				},
				"vrack_id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "vRack associated to the vRack Services",
					MarkdownDescription: "vRack associated to the vRack Services",
				},
			},
			CustomType: CurrentStateType{
				ObjectType: types.ObjectType{
					AttrTypes: CurrentStateValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Current configuration applied to the vRack Services",
			MarkdownDescription: "Current configuration applied to the vRack Services",
		},
		"current_tasks": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Identifier of the current task",
						MarkdownDescription: "Identifier of the current task",
					},
					"link": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Link to the related resource",
						MarkdownDescription: "Link to the related resource",
					},
					"status": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Current global status of the current task",
						MarkdownDescription: "Current global status of the current task",
					},
					"type": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Type of the current task",
						MarkdownDescription: "Type of the current task",
					},
				},
				CustomType: CurrentTasksType{
					ObjectType: types.ObjectType{
						AttrTypes: CurrentTasksValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[CurrentTasksValue](ctx),
			Computed:            true,
			Description:         "Asynchronous operations ongoing on the vRack Services",
			MarkdownDescription: "Asynchronous operations ongoing on the vRack Services",
		},
		"iam": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Resource display name",
					MarkdownDescription: "Resource display name",
				},
				"id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique identifier of the resource",
					MarkdownDescription: "Unique identifier of the resource",
				},
				"tags": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Resource tags. Tags that were internally computed are prefixed with ovh:",
					MarkdownDescription: "Resource tags. Tags that were internally computed are prefixed with ovh:",
				},
				"urn": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique resource name used in policies",
					MarkdownDescription: "Unique resource name used in policies",
				},
			},
			CustomType: IamType{
				ObjectType: types.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "IAM resource metadata",
			MarkdownDescription: "IAM resource metadata",
		},
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Unique identifier",
			MarkdownDescription: "Unique identifier",
		},
		"resource_status": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Reflects the readiness of the vRack Services. A new target specification request will be accepted only in `READY` status",
			MarkdownDescription: "Reflects the readiness of the vRack Services. A new target specification request will be accepted only in `READY` status",
		},
		"target_spec": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Target display name of the vRack Services. Format must follow `^[a-zA-Z0-9-_.]{0,40}$`",
					MarkdownDescription: "Target display name of the vRack Services. Format must follow `^[a-zA-Z0-9-_.]{0,40}$`",
				},
				"subnets": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"cidr": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "IPv4 CIDR notation (e.g., 192.0.2.0/24)",
								MarkdownDescription: "IPv4 CIDR notation (e.g., 192.0.2.0/24)",
							},
							"display_name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Display name of the subnet. Format must follow `^[a-zA-Z0-9-_.]{0,40}$`",
								MarkdownDescription: "Display name of the subnet. Format must follow `^[a-zA-Z0-9-_.]{0,40}$`",
							},
							"service_endpoints": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"managed_service_urn": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Required:            true,
											Description:         "IAM Resource URN of the managed service. Managed service Region must match vRack Services Region. Compatible managed service types are listed by /reference/compatibleManagedServiceType call",
											MarkdownDescription: "IAM Resource URN of the managed service. Managed service Region must match vRack Services Region. Compatible managed service types are listed by /reference/compatibleManagedServiceType call",
										},
									},
									CustomType: TargetSpecSubnetsServiceEndpointsType{
										ObjectType: types.ObjectType{
											AttrTypes: TargetSpecSubnetsServiceEndpointsValue{}.AttributeTypes(ctx),
										},
									},
								},
								CustomType:          ovhtypes.NewTfListNestedType[TargetSpecSubnetsServiceEndpointsValue](ctx),
								Required:            true,
								Description:         "Target specification of the Service Endpoints",
								MarkdownDescription: "Target specification of the Service Endpoints",
							},
							"service_range": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"cidr": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "IPv4 CIDR notation (e.g., 192.0.2.0/24)",
										MarkdownDescription: "IPv4 CIDR notation (e.g., 192.0.2.0/24)",
									},
								},
								CustomType: TargetSpecSubnetsServiceRangeType{
									ObjectType: types.ObjectType{
										AttrTypes: TargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx),
									},
								},
								Required:            true,
								Description:         "Target specification of the range dedicated to the subnet's services",
								MarkdownDescription: "Target specification of the range dedicated to the subnet's services",
							},
							"vlan": schema.Int64Attribute{
								CustomType:          ovhtypes.TfInt64Type{},
								Optional:            true,
								Computed:            true,
								Description:         "Unique inner VLAN that allows subnets segregation. Authorized values: [2 - 4094] and `null` (untagged traffic)",
								MarkdownDescription: "Unique inner VLAN that allows subnets segregation. Authorized values: [2 - 4094] and `null` (untagged traffic)",
							},
						},
						CustomType: TargetSpecSubnetsType{
							ObjectType: types.ObjectType{
								AttrTypes: TargetSpecSubnetsValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[TargetSpecSubnetsValue](ctx),
					Required:            true,
					Description:         "Target specification of the subnets. Maximum one subnet per vRack Services",
					MarkdownDescription: "Target specification of the subnets. Maximum one subnet per vRack Services",
				},
			},
			CustomType: TargetSpecType{
				ObjectType: types.ObjectType{
					AttrTypes: TargetSpecValue{}.AttributeTypes(ctx),
				},
			},
			Required:            true,
			Description:         "Target specification of the vRack Services",
			MarkdownDescription: "Target specification of the vRack Services",
		},
		"updated_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Date of the Last vRack Services update",
			MarkdownDescription: "Date of the Last vRack Services update",
		},
		"vrack_services_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Description:         "Vrack services ID",
			MarkdownDescription: "Vrack services ID",
		},
	}
	for k, v := range OrderResourceSchema(ctx).Attributes {
		attrs[k] = v
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type VrackServicesModel struct {
	Checksum        ovhtypes.TfStringValue                        `tfsdk:"checksum" json:"checksum"`
	CreatedAt       ovhtypes.TfStringValue                        `tfsdk:"created_at" json:"createdAt"`
	CurrentState    CurrentStateValue                             `tfsdk:"current_state" json:"currentState"`
	CurrentTasks    ovhtypes.TfListNestedValue[CurrentTasksValue] `tfsdk:"current_tasks" json:"currentTasks"`
	Iam             IamValue                                      `tfsdk:"iam" json:"iam"`
	Id              ovhtypes.TfStringValue                        `tfsdk:"id" json:"id"`
	ResourceStatus  ovhtypes.TfStringValue                        `tfsdk:"resource_status" json:"resourceStatus"`
	TargetSpec      TargetSpecValue                               `tfsdk:"target_spec" json:"targetSpec"`
	UpdatedAt       ovhtypes.TfStringValue                        `tfsdk:"updated_at" json:"updatedAt"`
	VrackServicesId ovhtypes.TfStringValue                        `tfsdk:"vrack_services_id" json:"vrackServicesId"`
	Order           OrderValue                                    `tfsdk:"order" json:"order"`
	OvhSubsidiary   ovhtypes.TfStringValue                        `tfsdk:"ovh_subsidiary" json:"ovhSubsidiary"`
	Plan            ovhtypes.TfListNestedValue[PlanValue]         `tfsdk:"plan" json:"plan"`
	PlanOption      ovhtypes.TfListNestedValue[PlanOptionValue]   `tfsdk:"plan_option" json:"planOption"`
}

func (v *VrackServicesModel) MergeWith(other *VrackServicesModel) {

	if (v.Checksum.IsUnknown() || v.Checksum.IsNull()) && !other.Checksum.IsUnknown() {
		v.Checksum = other.Checksum
	}

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if v.CurrentState.IsUnknown() && !other.CurrentState.IsUnknown() {
		v.CurrentState = other.CurrentState
	} else if !other.CurrentState.IsUnknown() {
		v.CurrentState.MergeWith(&other.CurrentState)
	}

	if (v.CurrentTasks.IsUnknown() || v.CurrentTasks.IsNull()) && !other.CurrentTasks.IsUnknown() {
		v.CurrentTasks = other.CurrentTasks
	} else if !other.CurrentTasks.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.CurrentTasks.Elements()
		newElems := other.CurrentTasks.Elements()

		if len(elems) != len(newElems) {
			v.CurrentTasks = other.CurrentTasks
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentTasksValue)
				tmp2 := newElems[idx].(CurrentTasksValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.CurrentTasks = ovhtypes.TfListNestedValue[CurrentTasksValue]{
				ListValue: basetypes.NewListValueMust(CurrentTasksValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if v.Iam.IsUnknown() && !other.Iam.IsUnknown() {
		v.Iam = other.Iam
	} else if !other.Iam.IsUnknown() {
		v.Iam.MergeWith(&other.Iam)
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.ResourceStatus.IsUnknown() || v.ResourceStatus.IsNull()) && !other.ResourceStatus.IsUnknown() {
		v.ResourceStatus = other.ResourceStatus
	}

	if v.TargetSpec.IsUnknown() && !other.TargetSpec.IsUnknown() {
		v.TargetSpec = other.TargetSpec
	} else if !other.TargetSpec.IsUnknown() {
		v.TargetSpec.MergeWith(&other.TargetSpec)
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

	if (v.VrackServicesId.IsUnknown() || v.VrackServicesId.IsNull()) && !other.VrackServicesId.IsUnknown() {
		v.VrackServicesId = other.VrackServicesId
	}

	if (v.Order.IsUnknown() || v.Order.IsNull()) && !other.Order.IsUnknown() {
		v.Order = other.Order
	}

	if (v.OvhSubsidiary.IsUnknown() || v.OvhSubsidiary.IsNull()) && !other.OvhSubsidiary.IsUnknown() {
		v.OvhSubsidiary = other.OvhSubsidiary
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	}

	if (v.PlanOption.IsUnknown() || v.PlanOption.IsNull()) && !other.PlanOption.IsUnknown() {
		v.PlanOption = other.PlanOption
	}

}

func (v *VrackServicesModel) ToOrder() *OrderModel {
	return &OrderModel{
		Order:         v.Order,
		OvhSubsidiary: v.OvhSubsidiary,
		Plan:          v.Plan,
		PlanOption:    v.PlanOption,
	}
}

type VrackServicesWritableModel struct {
	Checksum   *ovhtypes.TfStringValue  `tfsdk:"checksum" json:"checksum,omitempty"`
	TargetSpec *TargetSpecWritableValue `tfsdk:"target_spec" json:"targetSpec,omitempty"`
}

func (v VrackServicesModel) ToCreate() *VrackServicesWritableModel {
	res := &VrackServicesWritableModel{}

	if !v.Checksum.IsUnknown() {
		res.Checksum = &v.Checksum
	}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = v.TargetSpec.ToCreate()
	}

	return res
}

func (v VrackServicesModel) ToUpdate() *VrackServicesWritableModel {
	res := &VrackServicesWritableModel{}

	if !v.Checksum.IsUnknown() {
		res.Checksum = &v.Checksum
	}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = v.TargetSpec.ToUpdate()
	}

	return res
}

var _ basetypes.ObjectTypable = CurrentStateType{}

type CurrentStateType struct {
	basetypes.ObjectType
}

func (t CurrentStateType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateType) String() string {
	return "CurrentStateType"
}

func (t CurrentStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	productStatusAttribute, ok := attributes["product_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_status is missing from object`)

		return nil, diags
	}

	productStatusVal, ok := productStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_status expected to be ovhtypes.TfStringValue, was: %T`, productStatusAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[CurrentStateSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[CurrentStateSubnetsValue], was: %T`, subnetsAttribute))
	}

	vrackIdAttribute, ok := attributes["vrack_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrack_id is missing from object`)

		return nil, diags
	}

	vrackIdVal, ok := vrackIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrack_id expected to be ovhtypes.TfStringValue, was: %T`, vrackIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateValue{
		DisplayName:   displayNameVal,
		ProductStatus: productStatusVal,
		Region:        regionVal,
		Subnets:       subnetsVal,
		VrackId:       vrackIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateValueNull() CurrentStateValue {
	return CurrentStateValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateValueUnknown() CurrentStateValue {
	return CurrentStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateValue Attribute Value",
				"While creating a CurrentStateValue value, a missing attribute value was detected. "+
					"A CurrentStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateValue Attribute Type",
				"While creating a CurrentStateValue value, an invalid attribute value was detected. "+
					"A CurrentStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateValue Attribute Value",
				"While creating a CurrentStateValue value, an extra attribute value was detected. "+
					"A CurrentStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateValueUnknown(), diags
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	productStatusAttribute, ok := attributes["product_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_status is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	productStatusVal, ok := productStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_status expected to be ovhtypes.TfStringValue, was: %T`, productStatusAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[CurrentStateSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[CurrentStateSubnetsValue], was: %T`, subnetsAttribute))
	}

	vrackIdAttribute, ok := attributes["vrack_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrack_id is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	vrackIdVal, ok := vrackIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrack_id expected to be ovhtypes.TfStringValue, was: %T`, vrackIdAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateValueUnknown(), diags
	}

	return CurrentStateValue{
		DisplayName:   displayNameVal,
		ProductStatus: productStatusVal,
		Region:        regionVal,
		Subnets:       subnetsVal,
		VrackId:       vrackIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateValue {
	object, diags := NewCurrentStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateValueMust(CurrentStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateValue{}
}

var _ basetypes.ObjectValuable = CurrentStateValue{}

type CurrentStateValue struct {
	DisplayName   ovhtypes.TfStringValue                               `tfsdk:"display_name" json:"displayName"`
	ProductStatus ovhtypes.TfStringValue                               `tfsdk:"product_status" json:"productStatus"`
	Region        ovhtypes.TfStringValue                               `tfsdk:"region" json:"region"`
	Subnets       ovhtypes.TfListNestedValue[CurrentStateSubnetsValue] `tfsdk:"subnets" json:"subnets"`
	VrackId       ovhtypes.TfStringValue                               `tfsdk:"vrack_id" json:"vrackId"`
	state         attr.ValueState
}

func (v *CurrentStateValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateValue CurrentStateValue

	var tmp JsonCurrentStateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DisplayName = tmp.DisplayName
	v.ProductStatus = tmp.ProductStatus
	v.Region = tmp.Region
	v.Subnets = tmp.Subnets
	v.VrackId = tmp.VrackId

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateValue) MergeWith(other *CurrentStateValue) {

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if (v.ProductStatus.IsUnknown() || v.ProductStatus.IsNull()) && !other.ProductStatus.IsUnknown() {
		v.ProductStatus = other.ProductStatus
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.Subnets.IsUnknown() || v.Subnets.IsNull()) && !other.Subnets.IsUnknown() {
		v.Subnets = other.Subnets
	} else if !other.Subnets.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Subnets.Elements()
		newElems := other.Subnets.Elements()

		if len(elems) != len(newElems) {
			v.Subnets = other.Subnets
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentStateSubnetsValue)
				tmp2 := newElems[idx].(CurrentStateSubnetsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Subnets = ovhtypes.TfListNestedValue[CurrentStateSubnetsValue]{
				ListValue: basetypes.NewListValueMust(CurrentStateSubnetsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.VrackId.IsUnknown() || v.VrackId.IsNull()) && !other.VrackId.IsUnknown() {
		v.VrackId = other.VrackId
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"displayName":   v.DisplayName,
		"productStatus": v.ProductStatus,
		"region":        v.Region,
		"subnets":       v.Subnets,
		"vrackId":       v.VrackId,
	}
}
func (v CurrentStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["product_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: CurrentStateSubnetsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vrack_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.ProductStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["product_status"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.VrackId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrack_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateValue) String() string {
	return "CurrentStateValue"
}

func (v CurrentStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"display_name":   ovhtypes.TfStringType{},
			"product_status": ovhtypes.TfStringType{},
			"region":         ovhtypes.TfStringType{},
			"subnets":        ovhtypes.NewTfListNestedType[CurrentStateSubnetsValue](ctx),
			"vrack_id":       ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"display_name":   v.DisplayName,
			"product_status": v.ProductStatus,
			"region":         v.Region,
			"subnets":        v.Subnets,
			"vrack_id":       v.VrackId,
		})

	return objVal, diags
}

func (v CurrentStateValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.ProductStatus.Equal(other.ProductStatus) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.VrackId.Equal(other.VrackId) {
		return false
	}

	return true
}

func (v CurrentStateValue) Type(ctx context.Context) attr.Type {
	return CurrentStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"display_name":   ovhtypes.TfStringType{},
		"product_status": ovhtypes.TfStringType{},
		"region":         ovhtypes.TfStringType{},
		"subnets":        ovhtypes.NewTfListNestedType[CurrentStateSubnetsValue](ctx),
		"vrack_id":       ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateSubnetsType{}

type CurrentStateSubnetsType struct {
	basetypes.ObjectType
}

func (t CurrentStateSubnetsType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateSubnetsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateSubnetsType) String() string {
	return "CurrentStateSubnetsType"
}

func (t CurrentStateSubnetsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return nil, diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return nil, diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(CurrentStateSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be CurrentStateSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsValueNull() CurrentStateSubnetsValue {
	return CurrentStateSubnetsValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateSubnetsValueUnknown() CurrentStateSubnetsValue {
	return CurrentStateSubnetsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateSubnetsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateSubnetsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateSubnetsValue Attribute Value",
				"While creating a CurrentStateSubnetsValue value, a missing attribute value was detected. "+
					"A CurrentStateSubnetsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateSubnetsValue Attribute Type",
				"While creating a CurrentStateSubnetsValue value, an invalid attribute value was detected. "+
					"A CurrentStateSubnetsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateSubnetsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateSubnetsValue Attribute Value",
				"While creating a CurrentStateSubnetsValue value, an extra attribute value was detected. "+
					"A CurrentStateSubnetsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateSubnetsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewCurrentStateSubnetsValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewCurrentStateSubnetsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return NewCurrentStateSubnetsValueUnknown(), diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return NewCurrentStateSubnetsValueUnknown(), diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(CurrentStateSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be CurrentStateSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewCurrentStateSubnetsValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsValueUnknown(), diags
	}

	return CurrentStateSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateSubnetsValue {
	object, diags := NewCurrentStateSubnetsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateSubnetsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateSubnetsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateSubnetsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateSubnetsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateSubnetsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateSubnetsValueMust(CurrentStateSubnetsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateSubnetsType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateSubnetsValue{}
}

var _ basetypes.ObjectValuable = CurrentStateSubnetsValue{}

type CurrentStateSubnetsValue struct {
	Cidr             ovhtypes.TfStringValue                                               `tfsdk:"cidr" json:"cidr"`
	DisplayName      ovhtypes.TfStringValue                                               `tfsdk:"display_name" json:"displayName"`
	ServiceEndpoints ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsValue] `tfsdk:"service_endpoints" json:"serviceEndpoints"`
	ServiceRange     CurrentStateSubnetsServiceRangeValue                                 `tfsdk:"service_range" json:"serviceRange"`
	Vlan             ovhtypes.TfInt64Value                                                `tfsdk:"vlan" json:"vlan"`
	state            attr.ValueState
}

func (v *CurrentStateSubnetsValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateSubnetsValue CurrentStateSubnetsValue

	var tmp JsonCurrentStateSubnetsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr
	v.DisplayName = tmp.DisplayName
	v.ServiceEndpoints = tmp.ServiceEndpoints
	v.ServiceRange = tmp.ServiceRange
	v.Vlan = tmp.Vlan

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateSubnetsValue) MergeWith(other *CurrentStateSubnetsValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if (v.ServiceEndpoints.IsUnknown() || v.ServiceEndpoints.IsNull()) && !other.ServiceEndpoints.IsUnknown() {
		v.ServiceEndpoints = other.ServiceEndpoints
	} else if !other.ServiceEndpoints.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.ServiceEndpoints.Elements()
		newElems := other.ServiceEndpoints.Elements()

		if len(elems) != len(newElems) {
			v.ServiceEndpoints = other.ServiceEndpoints
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentStateSubnetsServiceEndpointsValue)
				tmp2 := newElems[idx].(CurrentStateSubnetsServiceEndpointsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.ServiceEndpoints = ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsValue]{
				ListValue: basetypes.NewListValueMust(CurrentStateSubnetsServiceEndpointsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if v.ServiceRange.IsUnknown() && !other.ServiceRange.IsUnknown() {
		v.ServiceRange = other.ServiceRange
	} else if !other.ServiceRange.IsUnknown() {
		v.ServiceRange.MergeWith(&other.ServiceRange)
	}

	if (v.Vlan.IsUnknown() || v.Vlan.IsNull()) && !other.Vlan.IsUnknown() {
		v.Vlan = other.Vlan
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateSubnetsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr":             v.Cidr,
		"displayName":      v.DisplayName,
		"serviceEndpoints": v.ServiceEndpoints,
		"serviceRange":     v.ServiceRange,
		"vlan":             v.Vlan,
	}
}
func (v CurrentStateSubnetsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_endpoints"] = basetypes.ListType{
		ElemType: CurrentStateSubnetsServiceEndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_range"] = basetypes.ObjectType{
		AttrTypes: CurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.ServiceEndpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_endpoints"] = val

		val, err = v.ServiceRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_range"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateSubnetsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateSubnetsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateSubnetsValue) String() string {
	return "CurrentStateSubnetsValue"
}

func (v CurrentStateSubnetsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr":              ovhtypes.TfStringType{},
			"display_name":      ovhtypes.TfStringType{},
			"service_endpoints": ovhtypes.NewTfListNestedType[CurrentStateSubnetsServiceEndpointsValue](ctx),
			"service_range": CurrentStateSubnetsServiceRangeType{
				basetypes.ObjectType{
					AttrTypes: CurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx),
				},
			},
			"vlan": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"display_name":      v.DisplayName,
			"service_endpoints": v.ServiceEndpoints,
			"service_range":     v.ServiceRange,
			"vlan":              v.Vlan,
		})

	return objVal, diags
}

func (v CurrentStateSubnetsValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateSubnetsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.ServiceEndpoints.Equal(other.ServiceEndpoints) {
		return false
	}

	if !v.ServiceRange.Equal(other.ServiceRange) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	return true
}

func (v CurrentStateSubnetsValue) Type(ctx context.Context) attr.Type {
	return CurrentStateSubnetsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateSubnetsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              ovhtypes.TfStringType{},
		"display_name":      ovhtypes.TfStringType{},
		"service_endpoints": ovhtypes.NewTfListNestedType[CurrentStateSubnetsServiceEndpointsValue](ctx),
		"service_range":     CurrentStateSubnetsServiceRangeValue{}.Type(ctx),
		"vlan":              ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateSubnetsServiceEndpointsType{}

type CurrentStateSubnetsServiceEndpointsType struct {
	basetypes.ObjectType
}

func (t CurrentStateSubnetsServiceEndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateSubnetsServiceEndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateSubnetsServiceEndpointsType) String() string {
	return "CurrentStateSubnetsServiceEndpointsType"
}

func (t CurrentStateSubnetsServiceEndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return nil, diags
	}

	endpointsVal, ok := endpointsAttribute.(ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsEndpointsValue], was: %T`, endpointsAttribute))
	}

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return nil, diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateSubnetsServiceEndpointsValue{
		Endpoints:         endpointsVal,
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsServiceEndpointsValueNull() CurrentStateSubnetsServiceEndpointsValue {
	return CurrentStateSubnetsServiceEndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateSubnetsServiceEndpointsValueUnknown() CurrentStateSubnetsServiceEndpointsValue {
	return CurrentStateSubnetsServiceEndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateSubnetsServiceEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateSubnetsServiceEndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateSubnetsServiceEndpointsValue Attribute Value",
				"While creating a CurrentStateSubnetsServiceEndpointsValue value, a missing attribute value was detected. "+
					"A CurrentStateSubnetsServiceEndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateSubnetsServiceEndpointsValue Attribute Type",
				"While creating a CurrentStateSubnetsServiceEndpointsValue value, an invalid attribute value was detected. "+
					"A CurrentStateSubnetsServiceEndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateSubnetsServiceEndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateSubnetsServiceEndpointsValue Attribute Value",
				"While creating a CurrentStateSubnetsServiceEndpointsValue value, an extra attribute value was detected. "+
					"A CurrentStateSubnetsServiceEndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateSubnetsServiceEndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return NewCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	endpointsVal, ok := endpointsAttribute.(ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsEndpointsValue], was: %T`, endpointsAttribute))
	}

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return NewCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	return CurrentStateSubnetsServiceEndpointsValue{
		Endpoints:         endpointsVal,
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsServiceEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateSubnetsServiceEndpointsValue {
	object, diags := NewCurrentStateSubnetsServiceEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateSubnetsServiceEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateSubnetsServiceEndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateSubnetsServiceEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateSubnetsServiceEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateSubnetsServiceEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateSubnetsServiceEndpointsValueMust(CurrentStateSubnetsServiceEndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateSubnetsServiceEndpointsType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateSubnetsServiceEndpointsValue{}
}

var _ basetypes.ObjectValuable = CurrentStateSubnetsServiceEndpointsValue{}

type CurrentStateSubnetsServiceEndpointsValue struct {
	Endpoints         ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsEndpointsValue] `tfsdk:"endpoints" json:"endpoints"`
	ManagedServiceUrn ovhtypes.TfStringValue                                                        `tfsdk:"managed_service_urn" json:"managedServiceUrn"`
	state             attr.ValueState
}

func (v *CurrentStateSubnetsServiceEndpointsValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateSubnetsServiceEndpointsValue CurrentStateSubnetsServiceEndpointsValue

	var tmp JsonCurrentStateSubnetsServiceEndpointsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Endpoints = tmp.Endpoints
	v.ManagedServiceUrn = tmp.ManagedServiceUrn

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateSubnetsServiceEndpointsValue) MergeWith(other *CurrentStateSubnetsServiceEndpointsValue) {

	if (v.Endpoints.IsUnknown() || v.Endpoints.IsNull()) && !other.Endpoints.IsUnknown() {
		v.Endpoints = other.Endpoints
	} else if !other.Endpoints.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Endpoints.Elements()
		newElems := other.Endpoints.Elements()

		if len(elems) != len(newElems) {
			v.Endpoints = other.Endpoints
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentStateSubnetsServiceEndpointsEndpointsValue)
				tmp2 := newElems[idx].(CurrentStateSubnetsServiceEndpointsEndpointsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Endpoints = ovhtypes.TfListNestedValue[CurrentStateSubnetsServiceEndpointsEndpointsValue]{
				ListValue: basetypes.NewListValueMust(CurrentStateSubnetsServiceEndpointsEndpointsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.ManagedServiceUrn.IsUnknown() || v.ManagedServiceUrn.IsNull()) && !other.ManagedServiceUrn.IsUnknown() {
		v.ManagedServiceUrn = other.ManagedServiceUrn
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateSubnetsServiceEndpointsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"endpoints":         v.Endpoints,
		"managedServiceUrn": v.ManagedServiceUrn,
	}
}
func (v CurrentStateSubnetsServiceEndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["endpoints"] = basetypes.ListType{
		ElemType: CurrentStateSubnetsServiceEndpointsEndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["managed_service_urn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Endpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoints"] = val

		val, err = v.ManagedServiceUrn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_service_urn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateSubnetsServiceEndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateSubnetsServiceEndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateSubnetsServiceEndpointsValue) String() string {
	return "CurrentStateSubnetsServiceEndpointsValue"
}

func (v CurrentStateSubnetsServiceEndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"endpoints":           ovhtypes.NewTfListNestedType[CurrentStateSubnetsServiceEndpointsEndpointsValue](ctx),
			"managed_service_urn": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"endpoints":           v.Endpoints,
			"managed_service_urn": v.ManagedServiceUrn,
		})

	return objVal, diags
}

func (v CurrentStateSubnetsServiceEndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateSubnetsServiceEndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Endpoints.Equal(other.Endpoints) {
		return false
	}

	if !v.ManagedServiceUrn.Equal(other.ManagedServiceUrn) {
		return false
	}

	return true
}

func (v CurrentStateSubnetsServiceEndpointsValue) Type(ctx context.Context) attr.Type {
	return CurrentStateSubnetsServiceEndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateSubnetsServiceEndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"endpoints":           ovhtypes.NewTfListNestedType[CurrentStateSubnetsServiceEndpointsEndpointsValue](ctx),
		"managed_service_urn": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateSubnetsServiceEndpointsEndpointsType{}

type CurrentStateSubnetsServiceEndpointsEndpointsType struct {
	basetypes.ObjectType
}

func (t CurrentStateSubnetsServiceEndpointsEndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateSubnetsServiceEndpointsEndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateSubnetsServiceEndpointsEndpointsType) String() string {
	return "CurrentStateSubnetsServiceEndpointsEndpointsType"
}

func (t CurrentStateSubnetsServiceEndpointsEndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateSubnetsServiceEndpointsEndpointsValue{
		Description: descriptionVal,
		Ip:          ipVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsServiceEndpointsEndpointsValueNull() CurrentStateSubnetsServiceEndpointsEndpointsValue {
	return CurrentStateSubnetsServiceEndpointsEndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown() CurrentStateSubnetsServiceEndpointsEndpointsValue {
	return CurrentStateSubnetsServiceEndpointsEndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateSubnetsServiceEndpointsEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateSubnetsServiceEndpointsEndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Value",
				"While creating a CurrentStateSubnetsServiceEndpointsEndpointsValue value, a missing attribute value was detected. "+
					"A CurrentStateSubnetsServiceEndpointsEndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Type",
				"While creating a CurrentStateSubnetsServiceEndpointsEndpointsValue value, an invalid attribute value was detected. "+
					"A CurrentStateSubnetsServiceEndpointsEndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Value",
				"While creating a CurrentStateSubnetsServiceEndpointsEndpointsValue value, an extra attribute value was detected. "+
					"A CurrentStateSubnetsServiceEndpointsEndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	return CurrentStateSubnetsServiceEndpointsEndpointsValue{
		Description: descriptionVal,
		Ip:          ipVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsServiceEndpointsEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateSubnetsServiceEndpointsEndpointsValue {
	object, diags := NewCurrentStateSubnetsServiceEndpointsEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateSubnetsServiceEndpointsEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateSubnetsServiceEndpointsEndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateSubnetsServiceEndpointsEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateSubnetsServiceEndpointsEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateSubnetsServiceEndpointsEndpointsValueMust(CurrentStateSubnetsServiceEndpointsEndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateSubnetsServiceEndpointsEndpointsType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateSubnetsServiceEndpointsEndpointsValue{}
}

var _ basetypes.ObjectValuable = CurrentStateSubnetsServiceEndpointsEndpointsValue{}

type CurrentStateSubnetsServiceEndpointsEndpointsValue struct {
	Description ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	Ip          ovhtypes.TfStringValue `tfsdk:"ip" json:"ip"`
	state       attr.ValueState
}

func (v *CurrentStateSubnetsServiceEndpointsEndpointsValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateSubnetsServiceEndpointsEndpointsValue CurrentStateSubnetsServiceEndpointsEndpointsValue

	var tmp JsonCurrentStateSubnetsServiceEndpointsEndpointsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Description = tmp.Description
	v.Ip = tmp.Ip

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateSubnetsServiceEndpointsEndpointsValue) MergeWith(other *CurrentStateSubnetsServiceEndpointsEndpointsValue) {

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.Ip.IsUnknown() || v.Ip.IsNull()) && !other.Ip.IsUnknown() {
		v.Ip = other.Ip
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"description": v.Description,
		"ip":          v.Ip,
	}
}
func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) String() string {
	return "CurrentStateSubnetsServiceEndpointsEndpointsValue"
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"description": ovhtypes.TfStringType{},
			"ip":          ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"description": v.Description,
			"ip":          v.Ip,
		})

	return objVal, diags
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateSubnetsServiceEndpointsEndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	return true
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) Type(ctx context.Context) attr.Type {
	return CurrentStateSubnetsServiceEndpointsEndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateSubnetsServiceEndpointsEndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": ovhtypes.TfStringType{},
		"ip":          ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateSubnetsServiceRangeType{}

type CurrentStateSubnetsServiceRangeType struct {
	basetypes.ObjectType
}

func (t CurrentStateSubnetsServiceRangeType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateSubnetsServiceRangeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateSubnetsServiceRangeType) String() string {
	return "CurrentStateSubnetsServiceRangeType"
}

func (t CurrentStateSubnetsServiceRangeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	remainingIpsAttribute, ok := attributes["remaining_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remaining_ips is missing from object`)

		return nil, diags
	}

	remainingIpsVal, ok := remainingIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remaining_ips expected to be ovhtypes.TfInt64Value, was: %T`, remainingIpsAttribute))
	}

	reservedIpsAttribute, ok := attributes["reserved_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_ips is missing from object`)

		return nil, diags
	}

	reservedIpsVal, ok := reservedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_ips expected to be ovhtypes.TfInt64Value, was: %T`, reservedIpsAttribute))
	}

	usedIpsAttribute, ok := attributes["used_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`used_ips is missing from object`)

		return nil, diags
	}

	usedIpsVal, ok := usedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`used_ips expected to be ovhtypes.TfInt64Value, was: %T`, usedIpsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateSubnetsServiceRangeValue{
		Cidr:         cidrVal,
		RemainingIps: remainingIpsVal,
		ReservedIps:  reservedIpsVal,
		UsedIps:      usedIpsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsServiceRangeValueNull() CurrentStateSubnetsServiceRangeValue {
	return CurrentStateSubnetsServiceRangeValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateSubnetsServiceRangeValueUnknown() CurrentStateSubnetsServiceRangeValue {
	return CurrentStateSubnetsServiceRangeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateSubnetsServiceRangeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateSubnetsServiceRangeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateSubnetsServiceRangeValue Attribute Value",
				"While creating a CurrentStateSubnetsServiceRangeValue value, a missing attribute value was detected. "+
					"A CurrentStateSubnetsServiceRangeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateSubnetsServiceRangeValue Attribute Type",
				"While creating a CurrentStateSubnetsServiceRangeValue value, an invalid attribute value was detected. "+
					"A CurrentStateSubnetsServiceRangeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateSubnetsServiceRangeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateSubnetsServiceRangeValue Attribute Value",
				"While creating a CurrentStateSubnetsServiceRangeValue value, an extra attribute value was detected. "+
					"A CurrentStateSubnetsServiceRangeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateSubnetsServiceRangeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	remainingIpsAttribute, ok := attributes["remaining_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remaining_ips is missing from object`)

		return NewCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	remainingIpsVal, ok := remainingIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remaining_ips expected to be ovhtypes.TfInt64Value, was: %T`, remainingIpsAttribute))
	}

	reservedIpsAttribute, ok := attributes["reserved_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_ips is missing from object`)

		return NewCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	reservedIpsVal, ok := reservedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_ips expected to be ovhtypes.TfInt64Value, was: %T`, reservedIpsAttribute))
	}

	usedIpsAttribute, ok := attributes["used_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`used_ips is missing from object`)

		return NewCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	usedIpsVal, ok := usedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`used_ips expected to be ovhtypes.TfInt64Value, was: %T`, usedIpsAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	return CurrentStateSubnetsServiceRangeValue{
		Cidr:         cidrVal,
		RemainingIps: remainingIpsVal,
		ReservedIps:  reservedIpsVal,
		UsedIps:      usedIpsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateSubnetsServiceRangeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateSubnetsServiceRangeValue {
	object, diags := NewCurrentStateSubnetsServiceRangeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateSubnetsServiceRangeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateSubnetsServiceRangeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateSubnetsServiceRangeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateSubnetsServiceRangeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateSubnetsServiceRangeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateSubnetsServiceRangeValueMust(CurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateSubnetsServiceRangeType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateSubnetsServiceRangeValue{}
}

var _ basetypes.ObjectValuable = CurrentStateSubnetsServiceRangeValue{}

type CurrentStateSubnetsServiceRangeValue struct {
	Cidr         ovhtypes.TfStringValue `tfsdk:"cidr" json:"cidr"`
	RemainingIps ovhtypes.TfInt64Value  `tfsdk:"remaining_ips" json:"remainingIps"`
	ReservedIps  ovhtypes.TfInt64Value  `tfsdk:"reserved_ips" json:"reservedIps"`
	UsedIps      ovhtypes.TfInt64Value  `tfsdk:"used_ips" json:"usedIps"`
	state        attr.ValueState
}

func (v *CurrentStateSubnetsServiceRangeValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateSubnetsServiceRangeValue CurrentStateSubnetsServiceRangeValue

	var tmp JsonCurrentStateSubnetsServiceRangeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr
	v.RemainingIps = tmp.RemainingIps
	v.ReservedIps = tmp.ReservedIps
	v.UsedIps = tmp.UsedIps

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateSubnetsServiceRangeValue) MergeWith(other *CurrentStateSubnetsServiceRangeValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.RemainingIps.IsUnknown() || v.RemainingIps.IsNull()) && !other.RemainingIps.IsUnknown() {
		v.RemainingIps = other.RemainingIps
	}

	if (v.ReservedIps.IsUnknown() || v.ReservedIps.IsNull()) && !other.ReservedIps.IsUnknown() {
		v.ReservedIps = other.ReservedIps
	}

	if (v.UsedIps.IsUnknown() || v.UsedIps.IsNull()) && !other.UsedIps.IsUnknown() {
		v.UsedIps = other.UsedIps
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateSubnetsServiceRangeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr":         v.Cidr,
		"remainingIps": v.RemainingIps,
		"reservedIps":  v.ReservedIps,
		"usedIps":      v.UsedIps,
	}
}
func (v CurrentStateSubnetsServiceRangeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remaining_ips"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["reserved_ips"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["used_ips"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.RemainingIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remaining_ips"] = val

		val, err = v.ReservedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reserved_ips"] = val

		val, err = v.UsedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["used_ips"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateSubnetsServiceRangeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateSubnetsServiceRangeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateSubnetsServiceRangeValue) String() string {
	return "CurrentStateSubnetsServiceRangeValue"
}

func (v CurrentStateSubnetsServiceRangeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr":          ovhtypes.TfStringType{},
			"remaining_ips": ovhtypes.TfInt64Type{},
			"reserved_ips":  ovhtypes.TfInt64Type{},
			"used_ips":      ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cidr":          v.Cidr,
			"remaining_ips": v.RemainingIps,
			"reserved_ips":  v.ReservedIps,
			"used_ips":      v.UsedIps,
		})

	return objVal, diags
}

func (v CurrentStateSubnetsServiceRangeValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateSubnetsServiceRangeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.RemainingIps.Equal(other.RemainingIps) {
		return false
	}

	if !v.ReservedIps.Equal(other.ReservedIps) {
		return false
	}

	if !v.UsedIps.Equal(other.UsedIps) {
		return false
	}

	return true
}

func (v CurrentStateSubnetsServiceRangeValue) Type(ctx context.Context) attr.Type {
	return CurrentStateSubnetsServiceRangeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateSubnetsServiceRangeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":          ovhtypes.TfStringType{},
		"remaining_ips": ovhtypes.TfInt64Type{},
		"reserved_ips":  ovhtypes.TfInt64Type{},
		"used_ips":      ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = CurrentTasksType{}

type CurrentTasksType struct {
	basetypes.ObjectType
}

func (t CurrentTasksType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentTasksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentTasksType) String() string {
	return "CurrentTasksType"
}

func (t CurrentTasksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return nil, diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentTasksValue{
		Id:               idVal,
		Link:             linkVal,
		Status:           statusVal,
		CurrentTasksType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentTasksValueNull() CurrentTasksValue {
	return CurrentTasksValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentTasksValueUnknown() CurrentTasksValue {
	return CurrentTasksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentTasksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentTasksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentTasksValue Attribute Value",
				"While creating a CurrentTasksValue value, a missing attribute value was detected. "+
					"A CurrentTasksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentTasksValue Attribute Type",
				"While creating a CurrentTasksValue value, an invalid attribute value was detected. "+
					"A CurrentTasksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentTasksValue Attribute Value",
				"While creating a CurrentTasksValue value, an extra attribute value was detected. "+
					"A CurrentTasksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentTasksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentTasksValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewCurrentTasksValueUnknown(), diags
	}

	return CurrentTasksValue{
		Id:               idVal,
		Link:             linkVal,
		Status:           statusVal,
		CurrentTasksType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentTasksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentTasksValue {
	object, diags := NewCurrentTasksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentTasksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentTasksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentTasksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentTasksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentTasksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentTasksValueMust(CurrentTasksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentTasksType) ValueType(ctx context.Context) attr.Value {
	return CurrentTasksValue{}
}

var _ basetypes.ObjectValuable = CurrentTasksValue{}

type CurrentTasksValue struct {
	Id               ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	Link             ovhtypes.TfStringValue `tfsdk:"link" json:"link"`
	Status           ovhtypes.TfStringValue `tfsdk:"status" json:"status"`
	CurrentTasksType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state            attr.ValueState
}

func (v *CurrentTasksValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentTasksValue CurrentTasksValue

	var tmp JsonCurrentTasksValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id
	v.Link = tmp.Link
	v.Status = tmp.Status
	v.CurrentTasksType = tmp.CurrentTasksType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentTasksValue) MergeWith(other *CurrentTasksValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Link.IsUnknown() || v.Link.IsNull()) && !other.Link.IsUnknown() {
		v.Link = other.Link
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.CurrentTasksType.IsUnknown() || v.CurrentTasksType.IsNull()) && !other.CurrentTasksType.IsUnknown() {
		v.CurrentTasksType = other.CurrentTasksType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentTasksValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id":     v.Id,
		"link":   v.Link,
		"status": v.Status,
		"type":   v.CurrentTasksType,
	}
}
func (v CurrentTasksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Link.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.CurrentTasksType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentTasksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentTasksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentTasksValue) String() string {
	return "CurrentTasksValue"
}

func (v CurrentTasksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":     ovhtypes.TfStringType{},
			"link":   ovhtypes.TfStringType{},
			"status": ovhtypes.TfStringType{},
			"type":   ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id":     v.Id,
			"link":   v.Link,
			"status": v.Status,
			"type":   v.CurrentTasksType,
		})

	return objVal, diags
}

func (v CurrentTasksValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentTasksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Link.Equal(other.Link) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.CurrentTasksType.Equal(other.CurrentTasksType) {
		return false
	}

	return true
}

func (v CurrentTasksValue) Type(ctx context.Context) attr.Type {
	return CurrentTasksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentTasksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":     ovhtypes.TfStringType{},
		"link":   ovhtypes.TfStringType{},
		"status": ovhtypes.TfStringType{},
		"type":   ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TargetSpecType{}

type TargetSpecType struct {
	basetypes.ObjectType
}

func (t TargetSpecType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecType) String() string {
	return "TargetSpecType"
}

func (t TargetSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[TargetSpecSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[TargetSpecSubnetsValue], was: %T`, subnetsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecValue{
		DisplayName: displayNameVal,
		Subnets:     subnetsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecValueNull() TargetSpecValue {
	return TargetSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecValueUnknown() TargetSpecValue {
	return TargetSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecValue Attribute Value",
				"While creating a TargetSpecValue value, a missing attribute value was detected. "+
					"A TargetSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecValue Attribute Type",
				"While creating a TargetSpecValue value, an invalid attribute value was detected. "+
					"A TargetSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecValue Attribute Value",
				"While creating a TargetSpecValue value, an extra attribute value was detected. "+
					"A TargetSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecValueUnknown(), diags
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[TargetSpecSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[TargetSpecSubnetsValue], was: %T`, subnetsAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecValueUnknown(), diags
	}

	return TargetSpecValue{
		DisplayName: displayNameVal,
		Subnets:     subnetsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecValue {
	object, diags := NewTargetSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecValueMust(TargetSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecValue{}
}

var _ basetypes.ObjectValuable = TargetSpecValue{}

type TargetSpecValue struct {
	DisplayName ovhtypes.TfStringValue                             `tfsdk:"display_name" json:"displayName"`
	Subnets     ovhtypes.TfListNestedValue[TargetSpecSubnetsValue] `tfsdk:"subnets" json:"subnets"`
	state       attr.ValueState
}

type TargetSpecWritableValue struct {
	*TargetSpecValue `json:"-"`
	DisplayName      *ovhtypes.TfStringValue                             `json:"displayName,omitempty"`
	Subnets          *ovhtypes.TfListNestedValue[TargetSpecSubnetsValue] `json:"subnets,omitempty"`
}

func (v TargetSpecValue) ToCreate() *TargetSpecWritableValue {
	res := &TargetSpecWritableValue{}

	if !v.DisplayName.IsNull() {
		res.DisplayName = &v.DisplayName
	}

	if !v.Subnets.IsNull() {
		res.Subnets = &v.Subnets
	}

	return res
}

func (v TargetSpecValue) ToUpdate() *TargetSpecWritableValue {
	res := &TargetSpecWritableValue{}

	if !v.DisplayName.IsNull() {
		res.DisplayName = &v.DisplayName
	}

	if !v.Subnets.IsNull() {
		res.Subnets = &v.Subnets
	}

	return res
}

func (v *TargetSpecValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecValue TargetSpecValue

	var tmp JsonTargetSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DisplayName = tmp.DisplayName
	v.Subnets = tmp.Subnets

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecValue) MergeWith(other *TargetSpecValue) {

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if (v.Subnets.IsUnknown() || v.Subnets.IsNull()) && !other.Subnets.IsUnknown() {
		v.Subnets = other.Subnets
	} else if !other.Subnets.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Subnets.Elements()
		newElems := other.Subnets.Elements()

		if len(elems) != len(newElems) {
			v.Subnets = other.Subnets
		} else {
			for idx, e := range elems {
				tmp := e.(TargetSpecSubnetsValue)
				tmp2 := newElems[idx].(TargetSpecSubnetsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Subnets = ovhtypes.TfListNestedValue[TargetSpecSubnetsValue]{
				ListValue: basetypes.NewListValueMust(TargetSpecSubnetsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"displayName": v.DisplayName,
		"subnets":     v.Subnets,
	}
}
func (v TargetSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: TargetSpecSubnetsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecValue) String() string {
	return "TargetSpecValue"
}

func (v TargetSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"display_name": ovhtypes.TfStringType{},
			"subnets":      ovhtypes.NewTfListNestedType[TargetSpecSubnetsValue](ctx),
		},
		map[string]attr.Value{
			"display_name": v.DisplayName,
			"subnets":      v.Subnets,
		})

	return objVal, diags
}

func (v TargetSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	return true
}

func (v TargetSpecValue) Type(ctx context.Context) attr.Type {
	return TargetSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"display_name": ovhtypes.TfStringType{},
		"subnets":      ovhtypes.NewTfListNestedType[TargetSpecSubnetsValue](ctx),
	}
}

var _ basetypes.ObjectTypable = TargetSpecSubnetsType{}

type TargetSpecSubnetsType struct {
	basetypes.ObjectType
}

func (t TargetSpecSubnetsType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecSubnetsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecSubnetsType) String() string {
	return "TargetSpecSubnetsType"
}

func (t TargetSpecSubnetsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return nil, diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[TargetSpecSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[TargetSpecSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return nil, diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(TargetSpecSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be TargetSpecSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecSubnetsValueNull() TargetSpecSubnetsValue {
	return TargetSpecSubnetsValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecSubnetsValueUnknown() TargetSpecSubnetsValue {
	return TargetSpecSubnetsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecSubnetsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecSubnetsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecSubnetsValue Attribute Value",
				"While creating a TargetSpecSubnetsValue value, a missing attribute value was detected. "+
					"A TargetSpecSubnetsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecSubnetsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecSubnetsValue Attribute Type",
				"While creating a TargetSpecSubnetsValue value, an invalid attribute value was detected. "+
					"A TargetSpecSubnetsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecSubnetsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecSubnetsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecSubnetsValue Attribute Value",
				"While creating a TargetSpecSubnetsValue value, an extra attribute value was detected. "+
					"A TargetSpecSubnetsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecSubnetsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecSubnetsValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewTargetSpecSubnetsValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewTargetSpecSubnetsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return NewTargetSpecSubnetsValueUnknown(), diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[TargetSpecSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[TargetSpecSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return NewTargetSpecSubnetsValueUnknown(), diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(TargetSpecSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be TargetSpecSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewTargetSpecSubnetsValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecSubnetsValueUnknown(), diags
	}

	return TargetSpecSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecSubnetsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecSubnetsValue {
	object, diags := NewTargetSpecSubnetsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecSubnetsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecSubnetsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecSubnetsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecSubnetsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecSubnetsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecSubnetsValueMust(TargetSpecSubnetsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecSubnetsType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecSubnetsValue{}
}

var _ basetypes.ObjectValuable = TargetSpecSubnetsValue{}

type TargetSpecSubnetsValue struct {
	Cidr             ovhtypes.TfStringValue                                             `tfsdk:"cidr" json:"cidr"`
	DisplayName      ovhtypes.TfStringValue                                             `tfsdk:"display_name" json:"displayName"`
	ServiceEndpoints ovhtypes.TfListNestedValue[TargetSpecSubnetsServiceEndpointsValue] `tfsdk:"service_endpoints" json:"serviceEndpoints"`
	ServiceRange     TargetSpecSubnetsServiceRangeValue                                 `tfsdk:"service_range" json:"serviceRange"`
	Vlan             ovhtypes.TfInt64Value                                              `tfsdk:"vlan" json:"vlan"`
	state            attr.ValueState
}

type TargetSpecSubnetsWritableValue struct {
	*TargetSpecSubnetsValue `json:"-"`
	Cidr                    *ovhtypes.TfStringValue                                             `json:"cidr,omitempty"`
	DisplayName             *ovhtypes.TfStringValue                                             `json:"displayName,omitempty"`
	ServiceEndpoints        *ovhtypes.TfListNestedValue[TargetSpecSubnetsServiceEndpointsValue] `json:"serviceEndpoints,omitempty"`
	ServiceRange            *TargetSpecSubnetsServiceRangeValue                                 `json:"serviceRange,omitempty"`
	Vlan                    *ovhtypes.TfInt64Value                                              `json:"vlan,omitempty"`
}

func (v TargetSpecSubnetsValue) ToCreate() *TargetSpecSubnetsWritableValue {
	res := &TargetSpecSubnetsWritableValue{}

	if !v.ServiceEndpoints.IsNull() {
		res.ServiceEndpoints = &v.ServiceEndpoints
	}

	if !v.ServiceRange.IsNull() {
		res.ServiceRange = &v.ServiceRange
	}

	if !v.Vlan.IsNull() {
		res.Vlan = &v.Vlan
	}

	if !v.Cidr.IsNull() {
		res.Cidr = &v.Cidr
	}

	if !v.DisplayName.IsNull() {
		res.DisplayName = &v.DisplayName
	}

	return res
}

func (v TargetSpecSubnetsValue) ToUpdate() *TargetSpecSubnetsWritableValue {
	res := &TargetSpecSubnetsWritableValue{}

	if !v.ServiceEndpoints.IsNull() {
		res.ServiceEndpoints = &v.ServiceEndpoints
	}

	if !v.ServiceRange.IsNull() {
		res.ServiceRange = &v.ServiceRange
	}

	if !v.Vlan.IsNull() {
		res.Vlan = &v.Vlan
	}

	if !v.Cidr.IsNull() {
		res.Cidr = &v.Cidr
	}

	if !v.DisplayName.IsNull() {
		res.DisplayName = &v.DisplayName
	}

	return res
}

func (v *TargetSpecSubnetsValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecSubnetsValue TargetSpecSubnetsValue

	var tmp JsonTargetSpecSubnetsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr
	v.DisplayName = tmp.DisplayName
	v.ServiceEndpoints = tmp.ServiceEndpoints
	v.ServiceRange = tmp.ServiceRange
	v.Vlan = tmp.Vlan

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecSubnetsValue) MergeWith(other *TargetSpecSubnetsValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if (v.ServiceEndpoints.IsUnknown() || v.ServiceEndpoints.IsNull()) && !other.ServiceEndpoints.IsUnknown() {
		v.ServiceEndpoints = other.ServiceEndpoints
	} else if !other.ServiceEndpoints.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.ServiceEndpoints.Elements()
		newElems := other.ServiceEndpoints.Elements()

		if len(elems) != len(newElems) {
			v.ServiceEndpoints = other.ServiceEndpoints
		} else {
			for idx, e := range elems {
				tmp := e.(TargetSpecSubnetsServiceEndpointsValue)
				tmp2 := newElems[idx].(TargetSpecSubnetsServiceEndpointsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.ServiceEndpoints = ovhtypes.TfListNestedValue[TargetSpecSubnetsServiceEndpointsValue]{
				ListValue: basetypes.NewListValueMust(TargetSpecSubnetsServiceEndpointsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if v.ServiceRange.IsUnknown() && !other.ServiceRange.IsUnknown() {
		v.ServiceRange = other.ServiceRange
	} else if !other.ServiceRange.IsUnknown() {
		v.ServiceRange.MergeWith(&other.ServiceRange)
	}

	if (v.Vlan.IsUnknown() || v.Vlan.IsNull()) && !other.Vlan.IsUnknown() {
		v.Vlan = other.Vlan
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecSubnetsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr":             v.Cidr,
		"displayName":      v.DisplayName,
		"serviceEndpoints": v.ServiceEndpoints,
		"serviceRange":     v.ServiceRange,
		"vlan":             v.Vlan,
	}
}
func (v TargetSpecSubnetsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_endpoints"] = basetypes.ListType{
		ElemType: TargetSpecSubnetsServiceEndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_range"] = basetypes.ObjectType{
		AttrTypes: TargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.ServiceEndpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_endpoints"] = val

		val, err = v.ServiceRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_range"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecSubnetsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecSubnetsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecSubnetsValue) String() string {
	return "TargetSpecSubnetsValue"
}

func (v TargetSpecSubnetsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr":              ovhtypes.TfStringType{},
			"display_name":      ovhtypes.TfStringType{},
			"service_endpoints": ovhtypes.NewTfListNestedType[TargetSpecSubnetsServiceEndpointsValue](ctx),
			"service_range": TargetSpecSubnetsServiceRangeType{
				basetypes.ObjectType{
					AttrTypes: TargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx),
				},
			},
			"vlan": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"display_name":      v.DisplayName,
			"service_endpoints": v.ServiceEndpoints,
			"service_range":     v.ServiceRange,
			"vlan":              v.Vlan,
		})

	return objVal, diags
}

func (v TargetSpecSubnetsValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecSubnetsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.ServiceEndpoints.Equal(other.ServiceEndpoints) {
		return false
	}

	if !v.ServiceRange.Equal(other.ServiceRange) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	return true
}

func (v TargetSpecSubnetsValue) Type(ctx context.Context) attr.Type {
	return TargetSpecSubnetsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecSubnetsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              ovhtypes.TfStringType{},
		"display_name":      ovhtypes.TfStringType{},
		"service_endpoints": ovhtypes.NewTfListNestedType[TargetSpecSubnetsServiceEndpointsValue](ctx),
		"service_range":     TargetSpecSubnetsServiceRangeValue{}.Type(ctx),
		"vlan":              ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = TargetSpecSubnetsServiceEndpointsType{}

type TargetSpecSubnetsServiceEndpointsType struct {
	basetypes.ObjectType
}

func (t TargetSpecSubnetsServiceEndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecSubnetsServiceEndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecSubnetsServiceEndpointsType) String() string {
	return "TargetSpecSubnetsServiceEndpointsType"
}

func (t TargetSpecSubnetsServiceEndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return nil, diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecSubnetsServiceEndpointsValue{
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecSubnetsServiceEndpointsValueNull() TargetSpecSubnetsServiceEndpointsValue {
	return TargetSpecSubnetsServiceEndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecSubnetsServiceEndpointsValueUnknown() TargetSpecSubnetsServiceEndpointsValue {
	return TargetSpecSubnetsServiceEndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecSubnetsServiceEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecSubnetsServiceEndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecSubnetsServiceEndpointsValue Attribute Value",
				"While creating a TargetSpecSubnetsServiceEndpointsValue value, a missing attribute value was detected. "+
					"A TargetSpecSubnetsServiceEndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecSubnetsServiceEndpointsValue Attribute Type",
				"While creating a TargetSpecSubnetsServiceEndpointsValue value, an invalid attribute value was detected. "+
					"A TargetSpecSubnetsServiceEndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecSubnetsServiceEndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecSubnetsServiceEndpointsValue Attribute Value",
				"While creating a TargetSpecSubnetsServiceEndpointsValue value, an extra attribute value was detected. "+
					"A TargetSpecSubnetsServiceEndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecSubnetsServiceEndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecSubnetsServiceEndpointsValueUnknown(), diags
	}

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return NewTargetSpecSubnetsServiceEndpointsValueUnknown(), diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecSubnetsServiceEndpointsValueUnknown(), diags
	}

	return TargetSpecSubnetsServiceEndpointsValue{
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecSubnetsServiceEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecSubnetsServiceEndpointsValue {
	object, diags := NewTargetSpecSubnetsServiceEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecSubnetsServiceEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecSubnetsServiceEndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecSubnetsServiceEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecSubnetsServiceEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecSubnetsServiceEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecSubnetsServiceEndpointsValueMust(TargetSpecSubnetsServiceEndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecSubnetsServiceEndpointsType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecSubnetsServiceEndpointsValue{}
}

var _ basetypes.ObjectValuable = TargetSpecSubnetsServiceEndpointsValue{}

type TargetSpecSubnetsServiceEndpointsValue struct {
	ManagedServiceUrn ovhtypes.TfStringValue `tfsdk:"managed_service_urn" json:"managedServiceUrn"`
	state             attr.ValueState
}

type TargetSpecSubnetsServiceEndpointsWritableValue struct {
	*TargetSpecSubnetsServiceEndpointsValue `json:"-"`
	ManagedServiceUrn                       *ovhtypes.TfStringValue `json:"managedServiceUrn,omitempty"`
}

func (v TargetSpecSubnetsServiceEndpointsValue) ToCreate() *TargetSpecSubnetsServiceEndpointsWritableValue {
	res := &TargetSpecSubnetsServiceEndpointsWritableValue{}

	if !v.ManagedServiceUrn.IsNull() {
		res.ManagedServiceUrn = &v.ManagedServiceUrn
	}

	return res
}

func (v TargetSpecSubnetsServiceEndpointsValue) ToUpdate() *TargetSpecSubnetsServiceEndpointsWritableValue {
	res := &TargetSpecSubnetsServiceEndpointsWritableValue{}

	if !v.ManagedServiceUrn.IsNull() {
		res.ManagedServiceUrn = &v.ManagedServiceUrn
	}

	return res
}

func (v *TargetSpecSubnetsServiceEndpointsValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecSubnetsServiceEndpointsValue TargetSpecSubnetsServiceEndpointsValue

	var tmp JsonTargetSpecSubnetsServiceEndpointsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.ManagedServiceUrn = tmp.ManagedServiceUrn

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecSubnetsServiceEndpointsValue) MergeWith(other *TargetSpecSubnetsServiceEndpointsValue) {

	if (v.ManagedServiceUrn.IsUnknown() || v.ManagedServiceUrn.IsNull()) && !other.ManagedServiceUrn.IsUnknown() {
		v.ManagedServiceUrn = other.ManagedServiceUrn
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecSubnetsServiceEndpointsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"managedServiceUrn": v.ManagedServiceUrn,
	}
}
func (v TargetSpecSubnetsServiceEndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["managed_service_urn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ManagedServiceUrn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_service_urn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecSubnetsServiceEndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecSubnetsServiceEndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecSubnetsServiceEndpointsValue) String() string {
	return "TargetSpecSubnetsServiceEndpointsValue"
}

func (v TargetSpecSubnetsServiceEndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"managed_service_urn": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"managed_service_urn": v.ManagedServiceUrn,
		})

	return objVal, diags
}

func (v TargetSpecSubnetsServiceEndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecSubnetsServiceEndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ManagedServiceUrn.Equal(other.ManagedServiceUrn) {
		return false
	}

	return true
}

func (v TargetSpecSubnetsServiceEndpointsValue) Type(ctx context.Context) attr.Type {
	return TargetSpecSubnetsServiceEndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecSubnetsServiceEndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"managed_service_urn": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TargetSpecSubnetsServiceRangeType{}

type TargetSpecSubnetsServiceRangeType struct {
	basetypes.ObjectType
}

func (t TargetSpecSubnetsServiceRangeType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecSubnetsServiceRangeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecSubnetsServiceRangeType) String() string {
	return "TargetSpecSubnetsServiceRangeType"
}

func (t TargetSpecSubnetsServiceRangeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecSubnetsServiceRangeValue{
		Cidr:  cidrVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecSubnetsServiceRangeValueNull() TargetSpecSubnetsServiceRangeValue {
	return TargetSpecSubnetsServiceRangeValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecSubnetsServiceRangeValueUnknown() TargetSpecSubnetsServiceRangeValue {
	return TargetSpecSubnetsServiceRangeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecSubnetsServiceRangeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecSubnetsServiceRangeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecSubnetsServiceRangeValue Attribute Value",
				"While creating a TargetSpecSubnetsServiceRangeValue value, a missing attribute value was detected. "+
					"A TargetSpecSubnetsServiceRangeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecSubnetsServiceRangeValue Attribute Type",
				"While creating a TargetSpecSubnetsServiceRangeValue value, an invalid attribute value was detected. "+
					"A TargetSpecSubnetsServiceRangeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecSubnetsServiceRangeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecSubnetsServiceRangeValue Attribute Value",
				"While creating a TargetSpecSubnetsServiceRangeValue value, an extra attribute value was detected. "+
					"A TargetSpecSubnetsServiceRangeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecSubnetsServiceRangeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecSubnetsServiceRangeValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewTargetSpecSubnetsServiceRangeValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecSubnetsServiceRangeValueUnknown(), diags
	}

	return TargetSpecSubnetsServiceRangeValue{
		Cidr:  cidrVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecSubnetsServiceRangeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecSubnetsServiceRangeValue {
	object, diags := NewTargetSpecSubnetsServiceRangeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecSubnetsServiceRangeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecSubnetsServiceRangeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecSubnetsServiceRangeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecSubnetsServiceRangeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecSubnetsServiceRangeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecSubnetsServiceRangeValueMust(TargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecSubnetsServiceRangeType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecSubnetsServiceRangeValue{}
}

var _ basetypes.ObjectValuable = TargetSpecSubnetsServiceRangeValue{}

type TargetSpecSubnetsServiceRangeValue struct {
	Cidr  ovhtypes.TfStringValue `tfsdk:"cidr" json:"cidr"`
	state attr.ValueState
}

type TargetSpecSubnetsServiceRangeWritableValue struct {
	*TargetSpecSubnetsServiceRangeValue `json:"-"`
	Cidr                                *ovhtypes.TfStringValue `json:"cidr,omitempty"`
}

func (v TargetSpecSubnetsServiceRangeValue) ToCreate() *TargetSpecSubnetsServiceRangeWritableValue {
	res := &TargetSpecSubnetsServiceRangeWritableValue{}

	if !v.Cidr.IsNull() {
		res.Cidr = &v.Cidr
	}

	return res
}

func (v TargetSpecSubnetsServiceRangeValue) ToUpdate() *TargetSpecSubnetsServiceRangeWritableValue {
	res := &TargetSpecSubnetsServiceRangeWritableValue{}

	if !v.Cidr.IsNull() {
		res.Cidr = &v.Cidr
	}

	return res
}

func (v *TargetSpecSubnetsServiceRangeValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecSubnetsServiceRangeValue TargetSpecSubnetsServiceRangeValue

	var tmp JsonTargetSpecSubnetsServiceRangeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecSubnetsServiceRangeValue) MergeWith(other *TargetSpecSubnetsServiceRangeValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecSubnetsServiceRangeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr": v.Cidr,
	}
}
func (v TargetSpecSubnetsServiceRangeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecSubnetsServiceRangeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecSubnetsServiceRangeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecSubnetsServiceRangeValue) String() string {
	return "TargetSpecSubnetsServiceRangeValue"
}

func (v TargetSpecSubnetsServiceRangeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cidr": v.Cidr,
		})

	return objVal, diags
}

func (v TargetSpecSubnetsServiceRangeValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecSubnetsServiceRangeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	return true
}

func (v TargetSpecSubnetsServiceRangeValue) Type(ctx context.Context) attr.Type {
	return TargetSpecSubnetsServiceRangeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecSubnetsServiceRangeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr": ovhtypes.TfStringType{},
	}
}
