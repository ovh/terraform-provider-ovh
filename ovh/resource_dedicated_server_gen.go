// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DedicatedServerResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"availability_zone": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "dedicated AZ localisation",
			MarkdownDescription: "dedicated AZ localisation",
		},
		"boot_id": schema.Int64Attribute{
			CustomType: ovhtypes.TfInt64Type{},
			Optional:   true,
			Computed:   true,
		},
		"boot_script": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Ipxe script served on boot",
			MarkdownDescription: "Ipxe script served on boot",
		},
		"commercial_range": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "dedicater server commercial range",
			MarkdownDescription: "dedicater server commercial range",
		},
		"datacenter": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "dedicated datacenter localisation",
			MarkdownDescription: "dedicated datacenter localisation",
			Validators: []validator.String{
				stringvalidator.OneOf(
					"bhs1",
					"bhs2",
					"bhs3",
					"bhs4",
					"bhs5",
					"bhs6",
					"bhs7",
					"bhs8",
					"cch01",
					"crx1",
					"crx2",
					"dc1",
					"eri1",
					"eri2",
					"gra04",
					"gra1",
					"gra2",
					"gra3",
					"gsw",
					"hdf01",
					"hil1",
					"ieb01",
					"lil1-int1",
					"lim1",
					"lim2",
					"lim3",
					"mr901",
					"p19",
					"rbx",
					"rbx-hz",
					"rbx1",
					"rbx10",
					"rbx2",
					"rbx3",
					"rbx4",
					"rbx5",
					"rbx6",
					"rbx7",
					"rbx8",
					"rbx9",
					"sbg1",
					"sbg2",
					"sbg3",
					"sbg4",
					"sbg5",
					"sgp02",
					"sgp1",
					"syd03",
					"syd1",
					"syd2",
					"vin1",
					"waw1",
					"ynm1",
					"yyz01",
				),
			},
		},
		"details": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"custom_hostname": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Description:         "Personnal hostname to use in server reinstallation",
					MarkdownDescription: "Personnal hostname to use in server reinstallation",
				},
				"disk_group_id": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Description:         "Disk group id to process install on (only available for some templates)",
					MarkdownDescription: "Disk group id to process install on (only available for some templates)",
				},
				"no_raid": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Optional:            true,
					Description:         "true if you want to install only on the first disk",
					MarkdownDescription: "true if you want to install only on the first disk",
				},
				"soft_raid_devices": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Description:         "Number of devices to use for system's software RAID",
					MarkdownDescription: "Number of devices to use for system's software RAID",
				},
			},
			CustomType: DetailsType{
				ObjectType: types.ObjectType{
					AttrTypes: DetailsValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Description:         "A structure describing informations about installation custom",
			MarkdownDescription: "A structure describing informations about installation custom",
		},
		"display_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Optional:            true,
			Description:         "The display name of your dedicated server",
			MarkdownDescription: "The display name of your dedicated server",
		},
		"iam": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Resource display name",
					MarkdownDescription: "Resource display name",
				},
				"id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique identifier of the resource",
					MarkdownDescription: "Unique identifier of the resource",
				},
				"tags": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Resource tags. Tags that were internally computed are prefixed with ovh:",
					MarkdownDescription: "Resource tags. Tags that were internally computed are prefixed with ovh:",
				},
				"urn": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique resource name used in policies",
					MarkdownDescription: "Unique resource name used in policies",
				},
			},
			CustomType: IamType{
				ObjectType: types.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "IAM resource metadata",
			MarkdownDescription: "IAM resource metadata",
		},
		"ip": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "dedicated server ip",
			MarkdownDescription: "dedicated server ip",
		},
		"link_speed": schema.Int64Attribute{
			CustomType: ovhtypes.TfInt64Type{},
			Computed:   true,
		},
		"monitoring": schema.BoolAttribute{
			CustomType:          ovhtypes.TfBoolType{},
			Optional:            true,
			Computed:            true,
			Description:         "Icmp monitoring state",
			MarkdownDescription: "Icmp monitoring state",
		},
		"name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "dedicated server name",
			MarkdownDescription: "dedicated server name",
		},
		"new_upgrade_system": schema.BoolAttribute{
			CustomType: ovhtypes.TfBoolType{},
			Computed:   true,
		},
		"no_intervention": schema.BoolAttribute{
			CustomType:          ovhtypes.TfBoolType{},
			Optional:            true,
			Computed:            true,
			Description:         "Prevent datacenter intervention",
			MarkdownDescription: "Prevent datacenter intervention",
		},
		"os": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Operating system",
			MarkdownDescription: "Operating system",
		},
		"partition_scheme_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Description:         "Partition scheme name",
			MarkdownDescription: "Partition scheme name",
		},
		"power_state": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Power state of the server",
			MarkdownDescription: "Power state of the server",
			Validators: []validator.String{
				stringvalidator.OneOf(
					"poweroff",
					"poweron",
				),
			},
		},
		"professional_use": schema.BoolAttribute{
			CustomType:          ovhtypes.TfBoolType{},
			Computed:            true,
			Description:         "Does this server have professional use option",
			MarkdownDescription: "Does this server have professional use option",
		},
		"rack": schema.StringAttribute{
			CustomType: ovhtypes.TfStringType{},
			Computed:   true,
		},
		"region": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "dedicated region localisation",
			MarkdownDescription: "dedicated region localisation",
		},
		"rescue_mail": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Custom email used to receive rescue credentials",
			MarkdownDescription: "Custom email used to receive rescue credentials",
		},
		"rescue_ssh_key": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Public SSH Key used in the rescue mode",
			MarkdownDescription: "Public SSH Key used in the rescue mode",
		},
		"reverse": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "dedicated server reverse",
			MarkdownDescription: "dedicated server reverse",
		},
		"root_device": schema.StringAttribute{
			CustomType: ovhtypes.TfStringType{},
			Optional:   true,
			Computed:   true,
		},
		"server_id": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Computed:            true,
			Description:         "Server id",
			MarkdownDescription: "Server id",
		},
		"service_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "The internal name of your dedicated server",
			MarkdownDescription: "The internal name of your dedicated server",
		},
		"state": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "All states a Dedicated can be in",
			MarkdownDescription: "All states a Dedicated can be in",
			Validators: []validator.String{
				stringvalidator.OneOf(
					"error",
					"hacked",
					"hackedBlocked",
					"ok",
				),
			},
		},
		"support_level": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Dedicated server support level",
			MarkdownDescription: "Dedicated server support level",
			Validators: []validator.String{
				stringvalidator.OneOf(
					"critical",
					"fastpath",
					"gs",
					"pro",
				),
			},
		},
		"template_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Description:         "Template name",
			MarkdownDescription: "Template name",
		},
		"user_metadata": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"key": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Optional:   true,
					},
					"value": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Optional:   true,
					},
				},
				CustomType: UserMetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: UserMetadataValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[UserMetadataValue](ctx),
			Optional:            true,
			Description:         "Metadata",
			MarkdownDescription: "Metadata",
		},
	}
	for k, v := range OrderResourceSchema(ctx).Attributes {
		attrs[k] = v
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type DedicatedServerModel struct {
	AvailabilityZone    ovhtypes.TfStringValue                        `tfsdk:"availability_zone" json:"availabilityZone"`
	BootId              ovhtypes.TfInt64Value                         `tfsdk:"boot_id" json:"bootId"`
	BootScript          ovhtypes.TfStringValue                        `tfsdk:"boot_script" json:"bootScript"`
	CommercialRange     ovhtypes.TfStringValue                        `tfsdk:"commercial_range" json:"commercialRange"`
	Datacenter          ovhtypes.TfStringValue                        `tfsdk:"datacenter" json:"datacenter"`
	Details             DetailsValue                                  `tfsdk:"details" json:"details"`
	DisplayName         ovhtypes.TfStringValue                        `tfsdk:"display_name" json:"displayName"`
	Iam                 IamValue                                      `tfsdk:"iam" json:"iam"`
	Ip                  ovhtypes.TfStringValue                        `tfsdk:"ip" json:"ip"`
	LinkSpeed           ovhtypes.TfInt64Value                         `tfsdk:"link_speed" json:"linkSpeed"`
	Monitoring          ovhtypes.TfBoolValue                          `tfsdk:"monitoring" json:"monitoring"`
	Name                ovhtypes.TfStringValue                        `tfsdk:"name" json:"name"`
	NewUpgradeSystem    ovhtypes.TfBoolValue                          `tfsdk:"new_upgrade_system" json:"newUpgradeSystem"`
	NoIntervention      ovhtypes.TfBoolValue                          `tfsdk:"no_intervention" json:"noIntervention"`
	Os                  ovhtypes.TfStringValue                        `tfsdk:"os" json:"os"`
	PartitionSchemeName ovhtypes.TfStringValue                        `tfsdk:"partition_scheme_name" json:"partitionSchemeName"`
	PowerState          ovhtypes.TfStringValue                        `tfsdk:"power_state" json:"powerState"`
	ProfessionalUse     ovhtypes.TfBoolValue                          `tfsdk:"professional_use" json:"professionalUse"`
	Rack                ovhtypes.TfStringValue                        `tfsdk:"rack" json:"rack"`
	Region              ovhtypes.TfStringValue                        `tfsdk:"region" json:"region"`
	RescueMail          ovhtypes.TfStringValue                        `tfsdk:"rescue_mail" json:"rescueMail"`
	RescueSshKey        ovhtypes.TfStringValue                        `tfsdk:"rescue_ssh_key" json:"rescueSshKey"`
	Reverse             ovhtypes.TfStringValue                        `tfsdk:"reverse" json:"reverse"`
	RootDevice          ovhtypes.TfStringValue                        `tfsdk:"root_device" json:"rootDevice"`
	ServerId            ovhtypes.TfInt64Value                         `tfsdk:"server_id" json:"serverId"`
	ServiceName         ovhtypes.TfStringValue                        `tfsdk:"service_name" json:"serviceName"`
	State               ovhtypes.TfStringValue                        `tfsdk:"state" json:"state"`
	SupportLevel        ovhtypes.TfStringValue                        `tfsdk:"support_level" json:"supportLevel"`
	TemplateName        ovhtypes.TfStringValue                        `tfsdk:"template_name" json:"templateName"`
	UserMetadata        ovhtypes.TfListNestedValue[UserMetadataValue] `tfsdk:"user_metadata" json:"userMetadata"`
	Order               OrderValue                                    `tfsdk:"order" json:"order"`
	OvhSubsidiary       ovhtypes.TfStringValue                        `tfsdk:"ovh_subsidiary" json:"ovhSubsidiary"`
	Plan                ovhtypes.TfListNestedValue[PlanValue]         `tfsdk:"plan" json:"plan"`
	PlanOption          ovhtypes.TfListNestedValue[PlanOptionValue]   `tfsdk:"plan_option" json:"planOption"`
}

func (v *DedicatedServerModel) MergeWith(other *DedicatedServerModel) {

	if (v.AvailabilityZone.IsUnknown() || v.AvailabilityZone.IsNull()) && !other.AvailabilityZone.IsUnknown() {
		v.AvailabilityZone = other.AvailabilityZone
	}

	if (v.BootId.IsUnknown() || v.BootId.IsNull()) && !other.BootId.IsUnknown() {
		v.BootId = other.BootId
	}

	if (v.BootScript.IsUnknown() || v.BootScript.IsNull()) && !other.BootScript.IsUnknown() {
		v.BootScript = other.BootScript
	}

	if (v.CommercialRange.IsUnknown() || v.CommercialRange.IsNull()) && !other.CommercialRange.IsUnknown() {
		v.CommercialRange = other.CommercialRange
	}

	if (v.Datacenter.IsUnknown() || v.Datacenter.IsNull()) && !other.Datacenter.IsUnknown() {
		v.Datacenter = other.Datacenter
	}

	if v.Details.IsUnknown() && !other.Details.IsUnknown() {
		v.Details = other.Details
	} else if !other.Details.IsUnknown() {
		v.Details.MergeWith(&other.Details)
	}

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if v.Iam.IsUnknown() && !other.Iam.IsUnknown() {
		v.Iam = other.Iam
	} else if !other.Iam.IsUnknown() {
		v.Iam.MergeWith(&other.Iam)
	}

	if (v.Ip.IsUnknown() || v.Ip.IsNull()) && !other.Ip.IsUnknown() {
		v.Ip = other.Ip
	}

	if (v.LinkSpeed.IsUnknown() || v.LinkSpeed.IsNull()) && !other.LinkSpeed.IsUnknown() {
		v.LinkSpeed = other.LinkSpeed
	}

	if (v.Monitoring.IsUnknown() || v.Monitoring.IsNull()) && !other.Monitoring.IsUnknown() {
		v.Monitoring = other.Monitoring
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.NewUpgradeSystem.IsUnknown() || v.NewUpgradeSystem.IsNull()) && !other.NewUpgradeSystem.IsUnknown() {
		v.NewUpgradeSystem = other.NewUpgradeSystem
	}

	if (v.NoIntervention.IsUnknown() || v.NoIntervention.IsNull()) && !other.NoIntervention.IsUnknown() {
		v.NoIntervention = other.NoIntervention
	}

	if (v.Os.IsUnknown() || v.Os.IsNull()) && !other.Os.IsUnknown() {
		v.Os = other.Os
	}

	if (v.PartitionSchemeName.IsUnknown() || v.PartitionSchemeName.IsNull()) && !other.PartitionSchemeName.IsUnknown() {
		v.PartitionSchemeName = other.PartitionSchemeName
	}

	if (v.PowerState.IsUnknown() || v.PowerState.IsNull()) && !other.PowerState.IsUnknown() {
		v.PowerState = other.PowerState
	}

	if (v.ProfessionalUse.IsUnknown() || v.ProfessionalUse.IsNull()) && !other.ProfessionalUse.IsUnknown() {
		v.ProfessionalUse = other.ProfessionalUse
	}

	if (v.Rack.IsUnknown() || v.Rack.IsNull()) && !other.Rack.IsUnknown() {
		v.Rack = other.Rack
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.RescueMail.IsUnknown() || v.RescueMail.IsNull()) && !other.RescueMail.IsUnknown() {
		v.RescueMail = other.RescueMail
	}

	if (v.RescueSshKey.IsUnknown() || v.RescueSshKey.IsNull()) && !other.RescueSshKey.IsUnknown() {
		v.RescueSshKey = other.RescueSshKey
	}

	if (v.Reverse.IsUnknown() || v.Reverse.IsNull()) && !other.Reverse.IsUnknown() {
		v.Reverse = other.Reverse
	}

	if (v.RootDevice.IsUnknown() || v.RootDevice.IsNull()) && !other.RootDevice.IsUnknown() {
		v.RootDevice = other.RootDevice
	}

	if (v.ServerId.IsUnknown() || v.ServerId.IsNull()) && !other.ServerId.IsUnknown() {
		v.ServerId = other.ServerId
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.SupportLevel.IsUnknown() || v.SupportLevel.IsNull()) && !other.SupportLevel.IsUnknown() {
		v.SupportLevel = other.SupportLevel
	}

	if (v.TemplateName.IsUnknown() || v.TemplateName.IsNull()) && !other.TemplateName.IsUnknown() {
		v.TemplateName = other.TemplateName
	}

	if (v.UserMetadata.IsUnknown() || v.UserMetadata.IsNull()) && !other.UserMetadata.IsUnknown() {
		v.UserMetadata = other.UserMetadata
	} else if !other.UserMetadata.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.UserMetadata.Elements()
		newElems := other.UserMetadata.Elements()

		if len(elems) != len(newElems) {
			v.UserMetadata = other.UserMetadata
		} else {
			for idx, e := range elems {
				tmp := e.(UserMetadataValue)
				tmp2 := newElems[idx].(UserMetadataValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.UserMetadata = ovhtypes.TfListNestedValue[UserMetadataValue]{
				ListValue: basetypes.NewListValueMust(UserMetadataValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Order.IsUnknown() || v.Order.IsNull()) && !other.Order.IsUnknown() {
		v.Order = other.Order
	}

	if (v.OvhSubsidiary.IsUnknown() || v.OvhSubsidiary.IsNull()) && !other.OvhSubsidiary.IsUnknown() {
		v.OvhSubsidiary = other.OvhSubsidiary
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	}

	if (v.PlanOption.IsUnknown() || v.PlanOption.IsNull()) && !other.PlanOption.IsUnknown() {
		v.PlanOption = other.PlanOption
	} else if !other.PlanOption.IsUnknown() && !other.PlanOption.IsNull() {
		newSlice := make([]attr.Value, 0)
		elems := v.PlanOption.Elements()
		newElems := other.PlanOption.Elements()

		if len(elems) != len(newElems) {
			v.PlanOption = other.PlanOption
		} else {
			for idx, e := range elems {
				tmp := e.(PlanOptionValue)
				tmp2 := newElems[idx].(PlanOptionValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.PlanOption = ovhtypes.TfListNestedValue[PlanOptionValue]{
				ListValue: basetypes.NewListValueMust(PlanOptionValue{}.Type(context.Background()), newSlice),
			}
		}
	}

}

func (v *DedicatedServerModel) ToOrder() *OrderModel {
	return &OrderModel{
		Order:         v.Order,
		OvhSubsidiary: v.OvhSubsidiary,
		Plan:          v.Plan,
		PlanOption:    v.PlanOption,
	}
}

type DedicatedServerWritableModel struct {
	BootId              *ovhtypes.TfInt64Value                                 `tfsdk:"boot_id" json:"bootId,omitempty"`
	BootScript          *ovhtypes.TfStringValue                                `tfsdk:"boot_script" json:"bootScript,omitempty"`
	Details             *DetailsWritableValue                                  `tfsdk:"details" json:"details,omitempty"`
	Monitoring          *ovhtypes.TfBoolValue                                  `tfsdk:"monitoring" json:"monitoring,omitempty"`
	NoIntervention      *ovhtypes.TfBoolValue                                  `tfsdk:"no_intervention" json:"noIntervention,omitempty"`
	PartitionSchemeName *ovhtypes.TfStringValue                                `tfsdk:"partition_scheme_name" json:"partitionSchemeName,omitempty"`
	RescueMail          *ovhtypes.TfStringValue                                `tfsdk:"rescue_mail" json:"rescueMail,omitempty"`
	RescueSshKey        *ovhtypes.TfStringValue                                `tfsdk:"rescue_ssh_key" json:"rescueSshKey,omitempty"`
	RootDevice          *ovhtypes.TfStringValue                                `tfsdk:"root_device" json:"rootDevice,omitempty"`
	State               *ovhtypes.TfStringValue                                `tfsdk:"state" json:"state,omitempty"`
	TemplateName        *ovhtypes.TfStringValue                                `tfsdk:"template_name" json:"templateName,omitempty"`
	UserMetadata        *ovhtypes.TfListNestedValue[UserMetadataWritableValue] `tfsdk:"user_metadata" json:"userMetadata,omitempty"`
}

func (v DedicatedServerModel) ToCreate() *DedicatedServerWritableModel {
	res := &DedicatedServerWritableModel{}

	if !v.BootId.IsUnknown() {
		res.BootId = &v.BootId
	}

	if !v.BootScript.IsUnknown() {
		res.BootScript = &v.BootScript
	}

	if !v.Monitoring.IsUnknown() {
		res.Monitoring = &v.Monitoring
	}

	if !v.NoIntervention.IsUnknown() {
		res.NoIntervention = &v.NoIntervention
	}

	if !v.RescueMail.IsUnknown() {
		res.RescueMail = &v.RescueMail
	}

	if !v.RescueSshKey.IsUnknown() {
		res.RescueSshKey = &v.RescueSshKey
	}

	if !v.RootDevice.IsUnknown() {
		res.RootDevice = &v.RootDevice
	}

	if !v.State.IsUnknown() {
		res.State = &v.State
	}

	return res
}

func (v DedicatedServerModel) ToReinstall() *DedicatedServerWritableModel {
	res := &DedicatedServerWritableModel{}

	if !v.Details.IsUnknown() {
		res.Details = v.Details.ToUpdate()
	}

	if !v.PartitionSchemeName.IsUnknown() {
		res.PartitionSchemeName = &v.PartitionSchemeName
	}

	if !v.TemplateName.IsUnknown() {
		res.TemplateName = &v.TemplateName
	}

	if !v.UserMetadata.IsUnknown() {
		var updateUserMetadata []UserMetadataWritableValue
		for _, elem := range v.UserMetadata.Elements() {
			updateUserMetadata = append(updateUserMetadata, *elem.(UserMetadataValue).ToUpdate())
		}

		newUserMetadata, _ := basetypes.NewListValueFrom(context.Background(), UserMetadataWritableValue{
			UserMetadataValue: &UserMetadataValue{},
		}.Type(context.Background()), updateUserMetadata)
		res.UserMetadata = &ovhtypes.TfListNestedValue[UserMetadataWritableValue]{
			ListValue: newUserMetadata,
		}
	}

	return res
}

func (v DedicatedServerModel) ToUpdate() *DedicatedServerWritableModel {
	res := &DedicatedServerWritableModel{}

	if !v.BootId.IsUnknown() {
		res.BootId = &v.BootId
	}

	if !v.BootScript.IsUnknown() {
		res.BootScript = &v.BootScript
	}

	if !v.Monitoring.IsUnknown() {
		res.Monitoring = &v.Monitoring
	}

	if !v.NoIntervention.IsUnknown() {
		res.NoIntervention = &v.NoIntervention
	}

	if !v.RescueMail.IsUnknown() {
		res.RescueMail = &v.RescueMail
	}

	if !v.RescueSshKey.IsUnknown() {
		res.RescueSshKey = &v.RescueSshKey
	}

	if !v.RootDevice.IsUnknown() {
		res.RootDevice = &v.RootDevice
	}

	if !v.State.IsUnknown() {
		res.State = &v.State
	}

	return res
}

var _ basetypes.ObjectTypable = DetailsType{}

type DetailsType struct {
	basetypes.ObjectType
}

func (t DetailsType) Equal(o attr.Type) bool {
	other, ok := o.(DetailsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DetailsType) String() string {
	return "DetailsType"
}

func (t DetailsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customHostnameAttribute, ok := attributes["custom_hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_hostname is missing from object`)

		return nil, diags
	}

	customHostnameVal, ok := customHostnameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_hostname expected to be ovhtypes.TfStringValue, was: %T`, customHostnameAttribute))
	}

	diskGroupIdAttribute, ok := attributes["disk_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_group_id is missing from object`)

		return nil, diags
	}

	diskGroupIdVal, ok := diskGroupIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_group_id expected to be ovhtypes.TfInt64Value, was: %T`, diskGroupIdAttribute))
	}

	noRaidAttribute, ok := attributes["no_raid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_raid is missing from object`)

		return nil, diags
	}

	noRaidVal, ok := noRaidAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_raid expected to be ovhtypes.TfBoolValue, was: %T`, noRaidAttribute))
	}

	softRaidDevicesAttribute, ok := attributes["soft_raid_devices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`soft_raid_devices is missing from object`)

		return nil, diags
	}

	softRaidDevicesVal, ok := softRaidDevicesAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`soft_raid_devices expected to be ovhtypes.TfInt64Value, was: %T`, softRaidDevicesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DetailsValue{
		CustomHostname:  customHostnameVal,
		DiskGroupId:     diskGroupIdVal,
		NoRaid:          noRaidVal,
		SoftRaidDevices: softRaidDevicesVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueNull() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateNull,
	}
}

func NewDetailsValueUnknown() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDetailsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DetailsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DetailsValue Attribute Value",
				"While creating a DetailsValue value, a missing attribute value was detected. "+
					"A DetailsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DetailsValue Attribute Type",
				"While creating a DetailsValue value, an invalid attribute value was detected. "+
					"A DetailsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DetailsValue Attribute Value",
				"While creating a DetailsValue value, an extra attribute value was detected. "+
					"A DetailsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DetailsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	customHostnameAttribute, ok := attributes["custom_hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_hostname is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	customHostnameVal, ok := customHostnameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_hostname expected to be ovhtypes.TfStringValue, was: %T`, customHostnameAttribute))
	}

	diskGroupIdAttribute, ok := attributes["disk_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_group_id is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	diskGroupIdVal, ok := diskGroupIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_group_id expected to be ovhtypes.TfInt64Value, was: %T`, diskGroupIdAttribute))
	}

	noRaidAttribute, ok := attributes["no_raid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_raid is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	noRaidVal, ok := noRaidAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_raid expected to be ovhtypes.TfBoolValue, was: %T`, noRaidAttribute))
	}

	softRaidDevicesAttribute, ok := attributes["soft_raid_devices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`soft_raid_devices is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	softRaidDevicesVal, ok := softRaidDevicesAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`soft_raid_devices expected to be ovhtypes.TfInt64Value, was: %T`, softRaidDevicesAttribute))
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	return DetailsValue{
		CustomHostname:  customHostnameVal,
		DiskGroupId:     diskGroupIdVal,
		NoRaid:          noRaidVal,
		SoftRaidDevices: softRaidDevicesVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DetailsValue {
	object, diags := NewDetailsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDetailsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DetailsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDetailsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDetailsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDetailsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDetailsValueMust(DetailsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DetailsType) ValueType(ctx context.Context) attr.Value {
	return DetailsValue{}
}

var _ basetypes.ObjectValuable = DetailsValue{}

type DetailsValue struct {
	CustomHostname  ovhtypes.TfStringValue `tfsdk:"custom_hostname" json:"customHostname"`
	DiskGroupId     ovhtypes.TfInt64Value  `tfsdk:"disk_group_id" json:"diskGroupId"`
	NoRaid          ovhtypes.TfBoolValue   `tfsdk:"no_raid" json:"noRaid"`
	SoftRaidDevices ovhtypes.TfInt64Value  `tfsdk:"soft_raid_devices" json:"softRaidDevices"`
	state           attr.ValueState
}

type DetailsWritableValue struct {
	*DetailsValue   `json:"-"`
	CustomHostname  *ovhtypes.TfStringValue `json:"customHostname,omitempty"`
	DiskGroupId     *ovhtypes.TfInt64Value  `json:"diskGroupId,omitempty"`
	NoRaid          *ovhtypes.TfBoolValue   `json:"noRaid,omitempty"`
	SoftRaidDevices *ovhtypes.TfInt64Value  `json:"softRaidDevices,omitempty"`
}

func (v DetailsValue) ToCreate() *DetailsWritableValue {
	res := &DetailsWritableValue{}

	if !v.CustomHostname.IsNull() {
		res.CustomHostname = &v.CustomHostname
	}

	if !v.DiskGroupId.IsNull() {
		res.DiskGroupId = &v.DiskGroupId
	}

	if !v.NoRaid.IsNull() {
		res.NoRaid = &v.NoRaid
	}

	if !v.SoftRaidDevices.IsNull() {
		res.SoftRaidDevices = &v.SoftRaidDevices
	}

	return res
}

func (v DetailsValue) ToUpdate() *DetailsWritableValue {
	res := &DetailsWritableValue{}

	if !v.CustomHostname.IsNull() {
		res.CustomHostname = &v.CustomHostname
	}

	if !v.DiskGroupId.IsNull() {
		res.DiskGroupId = &v.DiskGroupId
	}

	if !v.NoRaid.IsNull() {
		res.NoRaid = &v.NoRaid
	}

	if !v.SoftRaidDevices.IsNull() {
		res.SoftRaidDevices = &v.SoftRaidDevices
	}

	return res
}

func (v *DetailsValue) UnmarshalJSON(data []byte) error {
	type JsonDetailsValue DetailsValue

	var tmp JsonDetailsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CustomHostname = tmp.CustomHostname
	v.DiskGroupId = tmp.DiskGroupId
	v.NoRaid = tmp.NoRaid
	v.SoftRaidDevices = tmp.SoftRaidDevices

	v.state = attr.ValueStateKnown

	return nil
}

func (v *DetailsValue) MergeWith(other *DetailsValue) {
	if (v.CustomHostname.IsUnknown() || v.CustomHostname.IsNull()) && !other.CustomHostname.IsUnknown() {
		v.CustomHostname = other.CustomHostname
	}

	if (v.DiskGroupId.IsUnknown() || v.DiskGroupId.IsNull()) && !other.DiskGroupId.IsUnknown() {
		v.DiskGroupId = other.DiskGroupId
	}

	if (v.NoRaid.IsUnknown() || v.NoRaid.IsNull()) && !other.NoRaid.IsUnknown() {
		v.NoRaid = other.NoRaid
	}

	if (v.SoftRaidDevices.IsUnknown() || v.SoftRaidDevices.IsNull()) && !other.SoftRaidDevices.IsUnknown() {
		v.SoftRaidDevices = other.SoftRaidDevices
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v DetailsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"customHostname":  v.CustomHostname,
		"diskGroupId":     v.DiskGroupId,
		"noRaid":          v.NoRaid,
		"softRaidDevices": v.SoftRaidDevices,
	}
}
func (v DetailsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["custom_hostname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk_group_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["no_raid"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["soft_raid_devices"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CustomHostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_hostname"] = val

		val, err = v.DiskGroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_group_id"] = val

		val, err = v.NoRaid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_raid"] = val

		val, err = v.SoftRaidDevices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["soft_raid_devices"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DetailsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DetailsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DetailsValue) String() string {
	return "DetailsValue"
}

func (v DetailsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"custom_hostname":   ovhtypes.TfStringType{},
			"disk_group_id":     ovhtypes.TfInt64Type{},
			"no_raid":           ovhtypes.TfBoolType{},
			"soft_raid_devices": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"custom_hostname":   v.CustomHostname,
			"disk_group_id":     v.DiskGroupId,
			"no_raid":           v.NoRaid,
			"soft_raid_devices": v.SoftRaidDevices,
		})

	return objVal, diags
}

func (v DetailsValue) Equal(o attr.Value) bool {
	other, ok := o.(DetailsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomHostname.Equal(other.CustomHostname) {
		return false
	}

	if !v.DiskGroupId.Equal(other.DiskGroupId) {
		return false
	}

	if !v.NoRaid.Equal(other.NoRaid) {
		return false
	}

	if !v.SoftRaidDevices.Equal(other.SoftRaidDevices) {
		return false
	}

	return true
}

func (v DetailsValue) Type(ctx context.Context) attr.Type {
	return DetailsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DetailsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_hostname":   ovhtypes.TfStringType{},
		"disk_group_id":     ovhtypes.TfInt64Type{},
		"no_raid":           ovhtypes.TfBoolType{},
		"soft_raid_devices": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = UserMetadataType{}

type UserMetadataType struct {
	basetypes.ObjectType
}

func (t UserMetadataType) Equal(o attr.Type) bool {
	other, ok := o.(UserMetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UserMetadataType) String() string {
	return "UserMetadataType"
}

func (t UserMetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be ovhtypes.TfStringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UserMetadataValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewUserMetadataValueNull() UserMetadataValue {
	return UserMetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewUserMetadataValueUnknown() UserMetadataValue {
	return UserMetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUserMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UserMetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UserMetadataValue Attribute Value",
				"While creating a UserMetadataValue value, a missing attribute value was detected. "+
					"A UserMetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UserMetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UserMetadataValue Attribute Type",
				"While creating a UserMetadataValue value, an invalid attribute value was detected. "+
					"A UserMetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UserMetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UserMetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UserMetadataValue Attribute Value",
				"While creating a UserMetadataValue value, an extra attribute value was detected. "+
					"A UserMetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UserMetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUserMetadataValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewUserMetadataValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be ovhtypes.TfStringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewUserMetadataValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewUserMetadataValueUnknown(), diags
	}

	return UserMetadataValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewUserMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UserMetadataValue {
	object, diags := NewUserMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUserMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UserMetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUserMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUserMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUserMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUserMetadataValueMust(UserMetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UserMetadataType) ValueType(ctx context.Context) attr.Value {
	return UserMetadataValue{}
}

var _ basetypes.ObjectValuable = UserMetadataValue{}

type UserMetadataValue struct {
	Key   ovhtypes.TfStringValue `tfsdk:"key" json:"key"`
	Value ovhtypes.TfStringValue `tfsdk:"value" json:"value"`
	state attr.ValueState
}

type UserMetadataWritableValue struct {
	*UserMetadataValue `json:"-"`
	Key                *ovhtypes.TfStringValue `json:"key,omitempty"`
	Value              *ovhtypes.TfStringValue `json:"value,omitempty"`
}

func (v UserMetadataValue) ToCreate() *UserMetadataWritableValue {
	res := &UserMetadataWritableValue{}

	if !v.Value.IsNull() {
		res.Value = &v.Value
	}

	if !v.Key.IsNull() {
		res.Key = &v.Key
	}

	return res
}

func (v UserMetadataValue) ToUpdate() *UserMetadataWritableValue {
	res := &UserMetadataWritableValue{}

	if !v.Value.IsNull() {
		res.Value = &v.Value
	}

	if !v.Key.IsNull() {
		res.Key = &v.Key
	}

	return res
}

func (v *UserMetadataValue) UnmarshalJSON(data []byte) error {
	type JsonUserMetadataValue UserMetadataValue

	var tmp JsonUserMetadataValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Key = tmp.Key
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *UserMetadataValue) MergeWith(other *UserMetadataValue) {

	if (v.Key.IsUnknown() || v.Key.IsNull()) && !other.Key.IsUnknown() {
		v.Key = other.Key
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v UserMetadataValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"key":   v.Key,
		"value": v.Value,
	}
}
func (v UserMetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UserMetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UserMetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UserMetadataValue) String() string {
	return "UserMetadataValue"
}

func (v UserMetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"key":   ovhtypes.TfStringType{},
			"value": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"key":   v.Key,
			"value": v.Value,
		})

	return objVal, diags
}

func (v UserMetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(UserMetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v UserMetadataValue) Type(ctx context.Context) attr.Type {
	return UserMetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UserMetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key":   ovhtypes.TfStringType{},
		"value": ovhtypes.TfStringType{},
	}
}
