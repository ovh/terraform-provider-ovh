// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func VrackservicessDataSourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"vrackservicess": schema.SetNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"checksum": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Computed hash used to control concurrent modification requests. Here, it represents the current target specification value",
						MarkdownDescription: "Computed hash used to control concurrent modification requests. Here, it represents the current target specification value",
					},
					"created_at": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Date of the vRack Services delivery",
						MarkdownDescription: "Date of the vRack Services delivery",
					},
					"current_state": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"product_status": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Product status of the vRack Services",
								MarkdownDescription: "Product status of the vRack Services",
							},
							"region": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Region of the vRack Services. List of compatible regions can be retrieved from /reference/region",
								MarkdownDescription: "Region of the vRack Services. List of compatible regions can be retrieved from /reference/region",
							},
							"subnets": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"cidr": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Computed:            true,
											Description:         "IP address range of the subnet in CIDR format",
											MarkdownDescription: "IP address range of the subnet in CIDR format",
										},
										"display_name": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Computed:            true,
											Description:         "Display name of the subnet",
											MarkdownDescription: "Display name of the subnet",
										},
										"service_endpoints": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"endpoints": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"description": schema.StringAttribute{
																	CustomType:          ovhtypes.TfStringType{},
																	Computed:            true,
																	Description:         "IP description defined in the managed service",
																	MarkdownDescription: "IP description defined in the managed service",
																},
																"ip": schema.StringAttribute{
																	CustomType:          ovhtypes.TfStringType{},
																	Computed:            true,
																	Description:         "IP address assigned by OVHcloud",
																	MarkdownDescription: "IP address assigned by OVHcloud",
																},
															},
															CustomType: VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType{
																ObjectType: types.ObjectType{
																	AttrTypes: VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{}.AttributeTypes(ctx),
																},
															},
														},
														CustomType:          ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue](ctx),
														Computed:            true,
														Description:         "Endpoints representing the IPs assigned to the managed services",
														MarkdownDescription: "Endpoints representing the IPs assigned to the managed services",
													},
													"managed_service_urn": schema.StringAttribute{
														CustomType:          ovhtypes.TfStringType{},
														Computed:            true,
														Description:         "IAM Resource URN of the managed service. Compatible managed service types are listed by /reference/compatibleManagedServiceType call.",
														MarkdownDescription: "IAM Resource URN of the managed service. Compatible managed service types are listed by /reference/compatibleManagedServiceType call.",
													},
												},
												CustomType: VrackservicessCurrentStateSubnetsServiceEndpointsType{
													ObjectType: types.ObjectType{
														AttrTypes: VrackservicessCurrentStateSubnetsServiceEndpointsValue{}.AttributeTypes(ctx),
													},
												},
											},
											CustomType:          ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsServiceEndpointsValue](ctx),
											Computed:            true,
											Description:         "Service endpoints of the subnet",
											MarkdownDescription: "Service endpoints of the subnet",
										},
										"service_range": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"cidr": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "CIDR dedicated to the subnet's services",
													MarkdownDescription: "CIDR dedicated to the subnet's services",
												},
												"remaining_ips": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of remaining IPs in the service range",
													MarkdownDescription: "Number of remaining IPs in the service range",
												},
												"reserved_ips": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of service range IPs reserved by OVHcloud",
													MarkdownDescription: "Number of service range IPs reserved by OVHcloud",
												},
												"used_ips": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of service range IPs assigned to the managed services",
													MarkdownDescription: "Number of service range IPs assigned to the managed services",
												},
											},
											CustomType: VrackservicessCurrentStateSubnetsServiceRangeType{
												ObjectType: types.ObjectType{
													AttrTypes: VrackservicessCurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx),
												},
											},
											Computed:            true,
											Description:         "Defines a smaller subnet dedicated to the managed services IPs",
											MarkdownDescription: "Defines a smaller subnet dedicated to the managed services IPs",
										},
										"vlan": schema.Int64Attribute{
											CustomType:          ovhtypes.TfInt64Type{},
											Computed:            true,
											Description:         "Unique inner VLAN that allows subnets segregation",
											MarkdownDescription: "Unique inner VLAN that allows subnets segregation",
										},
									},
									CustomType: VrackservicessCurrentStateSubnetsType{
										ObjectType: types.ObjectType{
											AttrTypes: VrackservicessCurrentStateSubnetsValue{}.AttributeTypes(ctx),
										},
									},
								},
								CustomType:          ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsValue](ctx),
								Computed:            true,
								Description:         "Subnets of the current vRack Services",
								MarkdownDescription: "Subnets of the current vRack Services",
							},
							"vrack_id": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "vRack associated to the vRack Services",
								MarkdownDescription: "vRack associated to the vRack Services",
							},
						},
						CustomType: VrackservicessCurrentStateType{
							ObjectType: types.ObjectType{
								AttrTypes: VrackservicessCurrentStateValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Current configuration applied to the vRack Services",
						MarkdownDescription: "Current configuration applied to the vRack Services",
					},
					"current_tasks": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Computed:            true,
									Description:         "Identifier of the current task",
									MarkdownDescription: "Identifier of the current task",
								},
								"link": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Computed:            true,
									Description:         "Link to the task details",
									MarkdownDescription: "Link to the task details",
								},
								"status": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Computed:            true,
									Description:         "Current global status of the current task",
									MarkdownDescription: "Current global status of the current task",
								},
								"type": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Computed:            true,
									Description:         "Type of the current task",
									MarkdownDescription: "Type of the current task",
								},
							},
							CustomType: VrackservicessCurrentTasksType{
								ObjectType: types.ObjectType{
									AttrTypes: VrackservicessCurrentTasksValue{}.AttributeTypes(ctx),
								},
							},
						},
						CustomType:          ovhtypes.NewTfListNestedType[VrackservicessCurrentTasksValue](ctx),
						Computed:            true,
						Description:         "Asynchronous operations ongoing on the vRack Services",
						MarkdownDescription: "Asynchronous operations ongoing on the vRack Services",
					},
					"iam": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"display_name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Resource display name",
								MarkdownDescription: "Resource display name",
							},
							"id": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Unique identifier of the resource",
								MarkdownDescription: "Unique identifier of the resource",
							},
							"state": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Resource state",
								MarkdownDescription: "Resource state",
							},
							"tags": schema.MapAttribute{
								CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
								Computed:            true,
								Description:         "Resource tags. Tags that were internally computed are prefixed with ovh:",
								MarkdownDescription: "Resource tags. Tags that were internally computed are prefixed with ovh:",
							},
							"urn": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Unique resource name used in policies",
								MarkdownDescription: "Unique resource name used in policies",
							},
						},
						CustomType: VrackservicessIamType{
							ObjectType: types.ObjectType{
								AttrTypes: VrackservicessIamValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "IAM resource metadata",
						MarkdownDescription: "IAM resource metadata",
					},
					"id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Unique identifier",
						MarkdownDescription: "Unique identifier",
					},
					"resource_status": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Reflects the readiness of the vRack Services. A new target specification request will be accepted only in `READY` status",
						MarkdownDescription: "Reflects the readiness of the vRack Services. A new target specification request will be accepted only in `READY` status",
					},
					"target_spec": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"subnets": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"cidr": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Computed:            true,
											Description:         "IP address range of the subnet in CIDR format. Must be a private network address (RFC1918). Authorized range for prefix length: /16 to /24",
											MarkdownDescription: "IP address range of the subnet in CIDR format. Must be a private network address (RFC1918). Authorized range for prefix length: /16 to /24",
										},
										"display_name": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Computed:            true,
											Description:         "Display name of the subnet. Format must follow `^[ a-zA-Z0-9-_.]{0,40}$`",
											MarkdownDescription: "Display name of the subnet. Format must follow `^[ a-zA-Z0-9-_.]{0,40}$`",
										},
										"service_endpoints": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"managed_service_urn": schema.StringAttribute{
														CustomType:          ovhtypes.TfStringType{},
														Computed:            true,
														Description:         "IAM Resource URN of the managed service. Managed service Region must match vRack Services Region. Compatible managed service types are listed by /reference/compatibleManagedServiceType call",
														MarkdownDescription: "IAM Resource URN of the managed service. Managed service Region must match vRack Services Region. Compatible managed service types are listed by /reference/compatibleManagedServiceType call",
													},
												},
												CustomType: VrackservicessTargetSpecSubnetsServiceEndpointsType{
													ObjectType: types.ObjectType{
														AttrTypes: VrackservicessTargetSpecSubnetsServiceEndpointsValue{}.AttributeTypes(ctx),
													},
												},
											},
											CustomType:          ovhtypes.NewTfListNestedType[VrackservicessTargetSpecSubnetsServiceEndpointsValue](ctx),
											Computed:            true,
											Description:         "Target specification of the Service Endpoints",
											MarkdownDescription: "Target specification of the Service Endpoints",
										},
										"service_range": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"cidr": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "IP address range dedicated to the subnet's services in CIDR format. Must be a private network address (RFC1918). Must be a sub-network of the subnet. Authorized range for prefix length: /27 to /29",
													MarkdownDescription: "IP address range dedicated to the subnet's services in CIDR format. Must be a private network address (RFC1918). Must be a sub-network of the subnet. Authorized range for prefix length: /27 to /29",
												},
											},
											CustomType: VrackservicessTargetSpecSubnetsServiceRangeType{
												ObjectType: types.ObjectType{
													AttrTypes: VrackservicessTargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx),
												},
											},
											Computed:            true,
											Description:         "Defines a smaller subnet dedicated to the managed service IPs",
											MarkdownDescription: "Defines a smaller subnet dedicated to the managed service IPs",
										},
										"vlan": schema.Int64Attribute{
											CustomType:          ovhtypes.TfInt64Type{},
											Computed:            true,
											Description:         "Unique inner VLAN that allows subnets segregation. Authorized values: [2 - 4094] and `null` (untagged traffic)",
											MarkdownDescription: "Unique inner VLAN that allows subnets segregation. Authorized values: [2 - 4094] and `null` (untagged traffic)",
										},
									},
									CustomType: VrackservicessTargetSpecSubnetsType{
										ObjectType: types.ObjectType{
											AttrTypes: VrackservicessTargetSpecSubnetsValue{}.AttributeTypes(ctx),
										},
									},
								},
								CustomType:          ovhtypes.NewTfListNestedType[VrackservicessTargetSpecSubnetsValue](ctx),
								Computed:            true,
								Description:         "Target specification of the subnets. Maximum one subnet per vRack Services",
								MarkdownDescription: "Target specification of the subnets. Maximum one subnet per vRack Services",
							},
						},
						CustomType: VrackservicessTargetSpecType{
							ObjectType: types.ObjectType{
								AttrTypes: VrackservicessTargetSpecValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Last target specification of the vRack Services",
						MarkdownDescription: "Last target specification of the vRack Services",
					},
					"updated_at": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Date of the Last vRack Services update",
						MarkdownDescription: "Date of the Last vRack Services update",
					},
				},
				CustomType: VrackservicessType{
					ObjectType: types.ObjectType{
						AttrTypes: VrackservicessValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType: ovhtypes.NewTfListNestedType[VrackservicessValue](ctx),
			Computed:   true,
		},
	}

	return schema.Schema{
		Description: "List all vRack Services",
		Attributes:  attrs,
	}
}

type VrackservicessModel struct {
	Vrackservicess ovhtypes.TfListNestedValue[VrackservicessValue] `tfsdk:"vrackservicess" json:"vrackservicess"`
}

func (v *VrackservicessModel) MergeWith(other *VrackservicessModel) {

	if (v.Vrackservicess.IsUnknown() || v.Vrackservicess.IsNull()) && !other.Vrackservicess.IsUnknown() {
		v.Vrackservicess = other.Vrackservicess
	}

}

var _ basetypes.ObjectTypable = VrackservicessType{}

type VrackservicessType struct {
	basetypes.ObjectType
}

func (t VrackservicessType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessType) String() string {
	return "VrackservicessType"
}

func (t VrackservicessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	checksumAttribute, ok := attributes["checksum"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checksum is missing from object`)

		return nil, diags
	}

	checksumVal, ok := checksumAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checksum expected to be ovhtypes.TfStringValue, was: %T`, checksumAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	currentStateAttribute, ok := attributes["current_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_state is missing from object`)

		return nil, diags
	}

	currentStateVal, ok := currentStateAttribute.(VrackservicessCurrentStateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_state expected to be VrackservicessCurrentStateValue, was: %T`, currentStateAttribute))
	}

	currentTasksAttribute, ok := attributes["current_tasks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_tasks is missing from object`)

		return nil, diags
	}

	currentTasksVal, ok := currentTasksAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentTasksValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_tasks expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentTasksValue], was: %T`, currentTasksAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return nil, diags
	}

	iamVal, ok := iamAttribute.(VrackservicessIamValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be VrackservicessIamValue, was: %T`, iamAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	resourceStatusAttribute, ok := attributes["resource_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_status is missing from object`)

		return nil, diags
	}

	resourceStatusVal, ok := resourceStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_status expected to be ovhtypes.TfStringValue, was: %T`, resourceStatusAttribute))
	}

	targetSpecAttribute, ok := attributes["target_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_spec is missing from object`)

		return nil, diags
	}

	targetSpecVal, ok := targetSpecAttribute.(VrackservicessTargetSpecValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_spec expected to be VrackservicessTargetSpecValue, was: %T`, targetSpecAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessValue{
		Checksum:       checksumVal,
		CreatedAt:      createdAtVal,
		CurrentState:   currentStateVal,
		CurrentTasks:   currentTasksVal,
		Iam:            iamVal,
		Id:             idVal,
		ResourceStatus: resourceStatusVal,
		TargetSpec:     targetSpecVal,
		UpdatedAt:      updatedAtVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessValueNull() VrackservicessValue {
	return VrackservicessValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessValueUnknown() VrackservicessValue {
	return VrackservicessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessValue Attribute Value",
				"While creating a VrackservicessValue value, a missing attribute value was detected. "+
					"A VrackservicessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessValue Attribute Type",
				"While creating a VrackservicessValue value, an invalid attribute value was detected. "+
					"A VrackservicessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessValue Attribute Value",
				"While creating a VrackservicessValue value, an extra attribute value was detected. "+
					"A VrackservicessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessValueUnknown(), diags
	}

	checksumAttribute, ok := attributes["checksum"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checksum is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	checksumVal, ok := checksumAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checksum expected to be ovhtypes.TfStringValue, was: %T`, checksumAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	currentStateAttribute, ok := attributes["current_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_state is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	currentStateVal, ok := currentStateAttribute.(VrackservicessCurrentStateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_state expected to be VrackservicessCurrentStateValue, was: %T`, currentStateAttribute))
	}

	currentTasksAttribute, ok := attributes["current_tasks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_tasks is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	currentTasksVal, ok := currentTasksAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentTasksValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_tasks expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentTasksValue], was: %T`, currentTasksAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	iamVal, ok := iamAttribute.(VrackservicessIamValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be VrackservicessIamValue, was: %T`, iamAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	resourceStatusAttribute, ok := attributes["resource_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_status is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	resourceStatusVal, ok := resourceStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_status expected to be ovhtypes.TfStringValue, was: %T`, resourceStatusAttribute))
	}

	targetSpecAttribute, ok := attributes["target_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_spec is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	targetSpecVal, ok := targetSpecAttribute.(VrackservicessTargetSpecValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_spec expected to be VrackservicessTargetSpecValue, was: %T`, targetSpecAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewVrackservicessValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessValueUnknown(), diags
	}

	return VrackservicessValue{
		Checksum:       checksumVal,
		CreatedAt:      createdAtVal,
		CurrentState:   currentStateVal,
		CurrentTasks:   currentTasksVal,
		Iam:            iamVal,
		Id:             idVal,
		ResourceStatus: resourceStatusVal,
		TargetSpec:     targetSpecVal,
		UpdatedAt:      updatedAtVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessValue {
	object, diags := NewVrackservicessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessValueMust(VrackservicessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessValue{}
}

var _ basetypes.ObjectValuable = VrackservicessValue{}

type VrackservicessValue struct {
	Checksum       ovhtypes.TfStringValue                                      `tfsdk:"checksum" json:"checksum"`
	CreatedAt      ovhtypes.TfStringValue                                      `tfsdk:"created_at" json:"createdAt"`
	CurrentState   VrackservicessCurrentStateValue                             `tfsdk:"current_state" json:"currentState"`
	CurrentTasks   ovhtypes.TfListNestedValue[VrackservicessCurrentTasksValue] `tfsdk:"current_tasks" json:"currentTasks"`
	Iam            VrackservicessIamValue                                      `tfsdk:"iam" json:"iam"`
	Id             ovhtypes.TfStringValue                                      `tfsdk:"id" json:"id"`
	ResourceStatus ovhtypes.TfStringValue                                      `tfsdk:"resource_status" json:"resourceStatus"`
	TargetSpec     VrackservicessTargetSpecValue                               `tfsdk:"target_spec" json:"targetSpec"`
	UpdatedAt      ovhtypes.TfStringValue                                      `tfsdk:"updated_at" json:"updatedAt"`
	state          attr.ValueState
}

func (v *VrackservicessValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessValue VrackservicessValue

	var tmp JsonVrackservicessValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Checksum = tmp.Checksum
	v.CreatedAt = tmp.CreatedAt
	v.CurrentState = tmp.CurrentState
	v.CurrentTasks = tmp.CurrentTasks
	v.Iam = tmp.Iam
	v.Id = tmp.Id
	v.ResourceStatus = tmp.ResourceStatus
	v.TargetSpec = tmp.TargetSpec
	v.UpdatedAt = tmp.UpdatedAt

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessValue) MergeWith(other *VrackservicessValue) {

	if (v.Checksum.IsUnknown() || v.Checksum.IsNull()) && !other.Checksum.IsUnknown() {
		v.Checksum = other.Checksum
	}

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if (v.CurrentState.IsUnknown() || v.CurrentState.IsNull()) && !other.CurrentState.IsUnknown() {
		v.CurrentState = other.CurrentState
	}

	if (v.CurrentTasks.IsUnknown() || v.CurrentTasks.IsNull()) && !other.CurrentTasks.IsUnknown() {
		v.CurrentTasks = other.CurrentTasks
	}

	if (v.Iam.IsUnknown() || v.Iam.IsNull()) && !other.Iam.IsUnknown() {
		v.Iam = other.Iam
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.ResourceStatus.IsUnknown() || v.ResourceStatus.IsNull()) && !other.ResourceStatus.IsUnknown() {
		v.ResourceStatus = other.ResourceStatus
	}

	if (v.TargetSpec.IsUnknown() || v.TargetSpec.IsNull()) && !other.TargetSpec.IsUnknown() {
		v.TargetSpec = other.TargetSpec
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"checksum":       v.Checksum,
		"createdAt":      v.CreatedAt,
		"currentState":   v.CurrentState,
		"currentTasks":   v.CurrentTasks,
		"iam":            v.Iam,
		"id":             v.Id,
		"resourceStatus": v.ResourceStatus,
		"targetSpec":     v.TargetSpec,
		"updatedAt":      v.UpdatedAt,
	}
}
func (v VrackservicessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["checksum"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["current_state"] = basetypes.ObjectType{
		AttrTypes: VrackservicessCurrentStateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["current_tasks"] = basetypes.ListType{
		ElemType: VrackservicessCurrentTasksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ObjectType{
		AttrTypes: VrackservicessIamValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["target_spec"] = basetypes.ObjectType{
		AttrTypes: VrackservicessTargetSpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Checksum.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["checksum"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CurrentState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_state"] = val

		val, err = v.CurrentTasks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_tasks"] = val

		val, err = v.Iam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ResourceStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_status"] = val

		val, err = v.TargetSpec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_spec"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessValue) String() string {
	return "VrackservicessValue"
}

func (v VrackservicessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"checksum":   ovhtypes.TfStringType{},
			"created_at": ovhtypes.TfStringType{},
			"current_state": VrackservicessCurrentStateType{
				basetypes.ObjectType{
					AttrTypes: VrackservicessCurrentStateValue{}.AttributeTypes(ctx),
				},
			},
			"current_tasks": ovhtypes.NewTfListNestedType[VrackservicessCurrentTasksValue](ctx),
			"iam": VrackservicessIamType{
				basetypes.ObjectType{
					AttrTypes: VrackservicessIamValue{}.AttributeTypes(ctx),
				},
			},
			"id":              ovhtypes.TfStringType{},
			"resource_status": ovhtypes.TfStringType{},
			"target_spec": VrackservicessTargetSpecType{
				basetypes.ObjectType{
					AttrTypes: VrackservicessTargetSpecValue{}.AttributeTypes(ctx),
				},
			},
			"updated_at": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"checksum":        v.Checksum,
			"created_at":      v.CreatedAt,
			"current_state":   v.CurrentState,
			"current_tasks":   v.CurrentTasks,
			"iam":             v.Iam,
			"id":              v.Id,
			"resource_status": v.ResourceStatus,
			"target_spec":     v.TargetSpec,
			"updated_at":      v.UpdatedAt,
		})

	return objVal, diags
}

func (v VrackservicessValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Checksum.Equal(other.Checksum) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CurrentState.Equal(other.CurrentState) {
		return false
	}

	if !v.CurrentTasks.Equal(other.CurrentTasks) {
		return false
	}

	if !v.Iam.Equal(other.Iam) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ResourceStatus.Equal(other.ResourceStatus) {
		return false
	}

	if !v.TargetSpec.Equal(other.TargetSpec) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v VrackservicessValue) Type(ctx context.Context) attr.Type {
	return VrackservicessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"checksum":        ovhtypes.TfStringType{},
		"created_at":      ovhtypes.TfStringType{},
		"current_state":   VrackservicessCurrentStateValue{}.Type(ctx),
		"current_tasks":   ovhtypes.NewTfListNestedType[VrackservicessCurrentTasksValue](ctx),
		"iam":             VrackservicessIamValue{}.Type(ctx),
		"id":              ovhtypes.TfStringType{},
		"resource_status": ovhtypes.TfStringType{},
		"target_spec":     VrackservicessTargetSpecValue{}.Type(ctx),
		"updated_at":      ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessCurrentStateType{}

type VrackservicessCurrentStateType struct {
	basetypes.ObjectType
}

func (t VrackservicessCurrentStateType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessCurrentStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessCurrentStateType) String() string {
	return "VrackservicessCurrentStateType"
}

func (t VrackservicessCurrentStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	productStatusAttribute, ok := attributes["product_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_status is missing from object`)

		return nil, diags
	}

	productStatusVal, ok := productStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_status expected to be ovhtypes.TfStringValue, was: %T`, productStatusAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsValue], was: %T`, subnetsAttribute))
	}

	vrackIdAttribute, ok := attributes["vrack_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrack_id is missing from object`)

		return nil, diags
	}

	vrackIdVal, ok := vrackIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrack_id expected to be ovhtypes.TfStringValue, was: %T`, vrackIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessCurrentStateValue{
		ProductStatus: productStatusVal,
		Region:        regionVal,
		Subnets:       subnetsVal,
		VrackId:       vrackIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateValueNull() VrackservicessCurrentStateValue {
	return VrackservicessCurrentStateValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessCurrentStateValueUnknown() VrackservicessCurrentStateValue {
	return VrackservicessCurrentStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessCurrentStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessCurrentStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessCurrentStateValue Attribute Value",
				"While creating a VrackservicessCurrentStateValue value, a missing attribute value was detected. "+
					"A VrackservicessCurrentStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessCurrentStateValue Attribute Type",
				"While creating a VrackservicessCurrentStateValue value, an invalid attribute value was detected. "+
					"A VrackservicessCurrentStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessCurrentStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessCurrentStateValue Attribute Value",
				"While creating a VrackservicessCurrentStateValue value, an extra attribute value was detected. "+
					"A VrackservicessCurrentStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessCurrentStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateValueUnknown(), diags
	}

	productStatusAttribute, ok := attributes["product_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_status is missing from object`)

		return NewVrackservicessCurrentStateValueUnknown(), diags
	}

	productStatusVal, ok := productStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_status expected to be ovhtypes.TfStringValue, was: %T`, productStatusAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewVrackservicessCurrentStateValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewVrackservicessCurrentStateValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsValue], was: %T`, subnetsAttribute))
	}

	vrackIdAttribute, ok := attributes["vrack_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrack_id is missing from object`)

		return NewVrackservicessCurrentStateValueUnknown(), diags
	}

	vrackIdVal, ok := vrackIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrack_id expected to be ovhtypes.TfStringValue, was: %T`, vrackIdAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateValueUnknown(), diags
	}

	return VrackservicessCurrentStateValue{
		ProductStatus: productStatusVal,
		Region:        regionVal,
		Subnets:       subnetsVal,
		VrackId:       vrackIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessCurrentStateValue {
	object, diags := NewVrackservicessCurrentStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessCurrentStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessCurrentStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessCurrentStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessCurrentStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessCurrentStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessCurrentStateValueMust(VrackservicessCurrentStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessCurrentStateType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessCurrentStateValue{}
}

var _ basetypes.ObjectValuable = VrackservicessCurrentStateValue{}

type VrackservicessCurrentStateValue struct {
	ProductStatus ovhtypes.TfStringValue                                             `tfsdk:"product_status" json:"productStatus"`
	Region        ovhtypes.TfStringValue                                             `tfsdk:"region" json:"region"`
	Subnets       ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsValue] `tfsdk:"subnets" json:"subnets"`
	VrackId       ovhtypes.TfStringValue                                             `tfsdk:"vrack_id" json:"vrackId"`
	state         attr.ValueState
}

func (v *VrackservicessCurrentStateValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessCurrentStateValue VrackservicessCurrentStateValue

	var tmp JsonVrackservicessCurrentStateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.ProductStatus = tmp.ProductStatus
	v.Region = tmp.Region
	v.Subnets = tmp.Subnets
	v.VrackId = tmp.VrackId

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessCurrentStateValue) MergeWith(other *VrackservicessCurrentStateValue) {

	if (v.ProductStatus.IsUnknown() || v.ProductStatus.IsNull()) && !other.ProductStatus.IsUnknown() {
		v.ProductStatus = other.ProductStatus
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.Subnets.IsUnknown() || v.Subnets.IsNull()) && !other.Subnets.IsUnknown() {
		v.Subnets = other.Subnets
	}

	if (v.VrackId.IsUnknown() || v.VrackId.IsNull()) && !other.VrackId.IsUnknown() {
		v.VrackId = other.VrackId
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessCurrentStateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"productStatus": v.ProductStatus,
		"region":        v.Region,
		"subnets":       v.Subnets,
		"vrackId":       v.VrackId,
	}
}
func (v VrackservicessCurrentStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["product_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: VrackservicessCurrentStateSubnetsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vrack_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ProductStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["product_status"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.VrackId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrack_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessCurrentStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessCurrentStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessCurrentStateValue) String() string {
	return "VrackservicessCurrentStateValue"
}

func (v VrackservicessCurrentStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"product_status": ovhtypes.TfStringType{},
			"region":         ovhtypes.TfStringType{},
			"subnets":        ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsValue](ctx),
			"vrack_id":       ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"product_status": v.ProductStatus,
			"region":         v.Region,
			"subnets":        v.Subnets,
			"vrack_id":       v.VrackId,
		})

	return objVal, diags
}

func (v VrackservicessCurrentStateValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessCurrentStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProductStatus.Equal(other.ProductStatus) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.VrackId.Equal(other.VrackId) {
		return false
	}

	return true
}

func (v VrackservicessCurrentStateValue) Type(ctx context.Context) attr.Type {
	return VrackservicessCurrentStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessCurrentStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"product_status": ovhtypes.TfStringType{},
		"region":         ovhtypes.TfStringType{},
		"subnets":        ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsValue](ctx),
		"vrack_id":       ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessCurrentStateSubnetsType{}

type VrackservicessCurrentStateSubnetsType struct {
	basetypes.ObjectType
}

func (t VrackservicessCurrentStateSubnetsType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessCurrentStateSubnetsType) String() string {
	return "VrackservicessCurrentStateSubnetsType"
}

func (t VrackservicessCurrentStateSubnetsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return nil, diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return nil, diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(VrackservicessCurrentStateSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be VrackservicessCurrentStateSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessCurrentStateSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsValueNull() VrackservicessCurrentStateSubnetsValue {
	return VrackservicessCurrentStateSubnetsValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessCurrentStateSubnetsValueUnknown() VrackservicessCurrentStateSubnetsValue {
	return VrackservicessCurrentStateSubnetsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessCurrentStateSubnetsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessCurrentStateSubnetsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessCurrentStateSubnetsValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsValue value, a missing attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessCurrentStateSubnetsValue Attribute Type",
				"While creating a VrackservicessCurrentStateSubnetsValue value, an invalid attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessCurrentStateSubnetsValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsValue value, an extra attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessCurrentStateSubnetsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewVrackservicessCurrentStateSubnetsValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewVrackservicessCurrentStateSubnetsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return NewVrackservicessCurrentStateSubnetsValueUnknown(), diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return NewVrackservicessCurrentStateSubnetsValueUnknown(), diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(VrackservicessCurrentStateSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be VrackservicessCurrentStateSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewVrackservicessCurrentStateSubnetsValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsValueUnknown(), diags
	}

	return VrackservicessCurrentStateSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessCurrentStateSubnetsValue {
	object, diags := NewVrackservicessCurrentStateSubnetsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessCurrentStateSubnetsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessCurrentStateSubnetsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessCurrentStateSubnetsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessCurrentStateSubnetsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessCurrentStateSubnetsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessCurrentStateSubnetsValueMust(VrackservicessCurrentStateSubnetsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessCurrentStateSubnetsType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessCurrentStateSubnetsValue{}
}

var _ basetypes.ObjectValuable = VrackservicessCurrentStateSubnetsValue{}

type VrackservicessCurrentStateSubnetsValue struct {
	Cidr             ovhtypes.TfStringValue                                                             `tfsdk:"cidr" json:"cidr"`
	DisplayName      ovhtypes.TfStringValue                                                             `tfsdk:"display_name" json:"displayName"`
	ServiceEndpoints ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsValue] `tfsdk:"service_endpoints" json:"serviceEndpoints"`
	ServiceRange     VrackservicessCurrentStateSubnetsServiceRangeValue                                 `tfsdk:"service_range" json:"serviceRange"`
	Vlan             ovhtypes.TfInt64Value                                                              `tfsdk:"vlan" json:"vlan"`
	state            attr.ValueState
}

func (v *VrackservicessCurrentStateSubnetsValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessCurrentStateSubnetsValue VrackservicessCurrentStateSubnetsValue

	var tmp JsonVrackservicessCurrentStateSubnetsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr
	v.DisplayName = tmp.DisplayName
	v.ServiceEndpoints = tmp.ServiceEndpoints
	v.ServiceRange = tmp.ServiceRange
	v.Vlan = tmp.Vlan

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessCurrentStateSubnetsValue) MergeWith(other *VrackservicessCurrentStateSubnetsValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if (v.ServiceEndpoints.IsUnknown() || v.ServiceEndpoints.IsNull()) && !other.ServiceEndpoints.IsUnknown() {
		v.ServiceEndpoints = other.ServiceEndpoints
	}

	if (v.ServiceRange.IsUnknown() || v.ServiceRange.IsNull()) && !other.ServiceRange.IsUnknown() {
		v.ServiceRange = other.ServiceRange
	}

	if (v.Vlan.IsUnknown() || v.Vlan.IsNull()) && !other.Vlan.IsUnknown() {
		v.Vlan = other.Vlan
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessCurrentStateSubnetsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr":             v.Cidr,
		"displayName":      v.DisplayName,
		"serviceEndpoints": v.ServiceEndpoints,
		"serviceRange":     v.ServiceRange,
		"vlan":             v.Vlan,
	}
}
func (v VrackservicessCurrentStateSubnetsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_endpoints"] = basetypes.ListType{
		ElemType: VrackservicessCurrentStateSubnetsServiceEndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_range"] = basetypes.ObjectType{
		AttrTypes: VrackservicessCurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.ServiceEndpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_endpoints"] = val

		val, err = v.ServiceRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_range"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessCurrentStateSubnetsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessCurrentStateSubnetsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessCurrentStateSubnetsValue) String() string {
	return "VrackservicessCurrentStateSubnetsValue"
}

func (v VrackservicessCurrentStateSubnetsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr":              ovhtypes.TfStringType{},
			"display_name":      ovhtypes.TfStringType{},
			"service_endpoints": ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsServiceEndpointsValue](ctx),
			"service_range": VrackservicessCurrentStateSubnetsServiceRangeType{
				basetypes.ObjectType{
					AttrTypes: VrackservicessCurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx),
				},
			},
			"vlan": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"display_name":      v.DisplayName,
			"service_endpoints": v.ServiceEndpoints,
			"service_range":     v.ServiceRange,
			"vlan":              v.Vlan,
		})

	return objVal, diags
}

func (v VrackservicessCurrentStateSubnetsValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.ServiceEndpoints.Equal(other.ServiceEndpoints) {
		return false
	}

	if !v.ServiceRange.Equal(other.ServiceRange) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	return true
}

func (v VrackservicessCurrentStateSubnetsValue) Type(ctx context.Context) attr.Type {
	return VrackservicessCurrentStateSubnetsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessCurrentStateSubnetsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              ovhtypes.TfStringType{},
		"display_name":      ovhtypes.TfStringType{},
		"service_endpoints": ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsServiceEndpointsValue](ctx),
		"service_range":     VrackservicessCurrentStateSubnetsServiceRangeValue{}.Type(ctx),
		"vlan":              ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessCurrentStateSubnetsServiceEndpointsType{}

type VrackservicessCurrentStateSubnetsServiceEndpointsType struct {
	basetypes.ObjectType
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsServiceEndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsType) String() string {
	return "VrackservicessCurrentStateSubnetsServiceEndpointsType"
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return nil, diags
	}

	endpointsVal, ok := endpointsAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue], was: %T`, endpointsAttribute))
	}

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return nil, diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessCurrentStateSubnetsServiceEndpointsValue{
		Endpoints:         endpointsVal,
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsValueNull() VrackservicessCurrentStateSubnetsServiceEndpointsValue {
	return VrackservicessCurrentStateSubnetsServiceEndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsValueUnknown() VrackservicessCurrentStateSubnetsServiceEndpointsValue {
	return VrackservicessCurrentStateSubnetsServiceEndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessCurrentStateSubnetsServiceEndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessCurrentStateSubnetsServiceEndpointsValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsServiceEndpointsValue value, a missing attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceEndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessCurrentStateSubnetsServiceEndpointsValue Attribute Type",
				"While creating a VrackservicessCurrentStateSubnetsServiceEndpointsValue value, an invalid attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceEndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceEndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessCurrentStateSubnetsServiceEndpointsValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsServiceEndpointsValue value, an extra attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceEndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessCurrentStateSubnetsServiceEndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	endpointsVal, ok := endpointsAttribute.(ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue], was: %T`, endpointsAttribute))
	}

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueUnknown(), diags
	}

	return VrackservicessCurrentStateSubnetsServiceEndpointsValue{
		Endpoints:         endpointsVal,
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessCurrentStateSubnetsServiceEndpointsValue {
	object, diags := NewVrackservicessCurrentStateSubnetsServiceEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessCurrentStateSubnetsServiceEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessCurrentStateSubnetsServiceEndpointsValueMust(VrackservicessCurrentStateSubnetsServiceEndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessCurrentStateSubnetsServiceEndpointsValue{}
}

var _ basetypes.ObjectValuable = VrackservicessCurrentStateSubnetsServiceEndpointsValue{}

type VrackservicessCurrentStateSubnetsServiceEndpointsValue struct {
	Endpoints         ovhtypes.TfListNestedValue[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue] `tfsdk:"endpoints" json:"endpoints"`
	ManagedServiceUrn ovhtypes.TfStringValue                                                                      `tfsdk:"managed_service_urn" json:"managedServiceUrn"`
	state             attr.ValueState
}

func (v *VrackservicessCurrentStateSubnetsServiceEndpointsValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessCurrentStateSubnetsServiceEndpointsValue VrackservicessCurrentStateSubnetsServiceEndpointsValue

	var tmp JsonVrackservicessCurrentStateSubnetsServiceEndpointsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Endpoints = tmp.Endpoints
	v.ManagedServiceUrn = tmp.ManagedServiceUrn

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessCurrentStateSubnetsServiceEndpointsValue) MergeWith(other *VrackservicessCurrentStateSubnetsServiceEndpointsValue) {

	if (v.Endpoints.IsUnknown() || v.Endpoints.IsNull()) && !other.Endpoints.IsUnknown() {
		v.Endpoints = other.Endpoints
	}

	if (v.ManagedServiceUrn.IsUnknown() || v.ManagedServiceUrn.IsNull()) && !other.ManagedServiceUrn.IsUnknown() {
		v.ManagedServiceUrn = other.ManagedServiceUrn
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"endpoints":         v.Endpoints,
		"managedServiceUrn": v.ManagedServiceUrn,
	}
}
func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["endpoints"] = basetypes.ListType{
		ElemType: VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["managed_service_urn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Endpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoints"] = val

		val, err = v.ManagedServiceUrn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_service_urn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) String() string {
	return "VrackservicessCurrentStateSubnetsServiceEndpointsValue"
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"endpoints":           ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue](ctx),
			"managed_service_urn": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"endpoints":           v.Endpoints,
			"managed_service_urn": v.ManagedServiceUrn,
		})

	return objVal, diags
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsServiceEndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Endpoints.Equal(other.Endpoints) {
		return false
	}

	if !v.ManagedServiceUrn.Equal(other.ManagedServiceUrn) {
		return false
	}

	return true
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) Type(ctx context.Context) attr.Type {
	return VrackservicessCurrentStateSubnetsServiceEndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"endpoints":           ovhtypes.NewTfListNestedType[VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue](ctx),
		"managed_service_urn": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType{}

type VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType struct {
	basetypes.ObjectType
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType) String() string {
	return "VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType"
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{
		Description: descriptionVal,
		Ip:          ipVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueNull() VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue {
	return VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown() VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue {
	return VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue value, a missing attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Type",
				"While creating a VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue value, an invalid attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue value, an extra attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), diags
	}

	return VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{
		Description: descriptionVal,
		Ip:          ipVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue {
	object, diags := NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValueMust(VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{}
}

var _ basetypes.ObjectValuable = VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue{}

type VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue struct {
	Description ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	Ip          ovhtypes.TfStringValue `tfsdk:"ip" json:"ip"`
	state       attr.ValueState
}

func (v *VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue

	var tmp JsonVrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Description = tmp.Description
	v.Ip = tmp.Ip

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) MergeWith(other *VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) {

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.Ip.IsUnknown() || v.Ip.IsNull()) && !other.Ip.IsUnknown() {
		v.Ip = other.Ip
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"description": v.Description,
		"ip":          v.Ip,
	}
}
func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) String() string {
	return "VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue"
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"description": ovhtypes.TfStringType{},
			"ip":          ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"description": v.Description,
			"ip":          v.Ip,
		})

	return objVal, diags
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	return true
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) Type(ctx context.Context) attr.Type {
	return VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessCurrentStateSubnetsServiceEndpointsEndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": ovhtypes.TfStringType{},
		"ip":          ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessCurrentStateSubnetsServiceRangeType{}

type VrackservicessCurrentStateSubnetsServiceRangeType struct {
	basetypes.ObjectType
}

func (t VrackservicessCurrentStateSubnetsServiceRangeType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsServiceRangeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessCurrentStateSubnetsServiceRangeType) String() string {
	return "VrackservicessCurrentStateSubnetsServiceRangeType"
}

func (t VrackservicessCurrentStateSubnetsServiceRangeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	remainingIpsAttribute, ok := attributes["remaining_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remaining_ips is missing from object`)

		return nil, diags
	}

	remainingIpsVal, ok := remainingIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remaining_ips expected to be ovhtypes.TfInt64Value, was: %T`, remainingIpsAttribute))
	}

	reservedIpsAttribute, ok := attributes["reserved_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_ips is missing from object`)

		return nil, diags
	}

	reservedIpsVal, ok := reservedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_ips expected to be ovhtypes.TfInt64Value, was: %T`, reservedIpsAttribute))
	}

	usedIpsAttribute, ok := attributes["used_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`used_ips is missing from object`)

		return nil, diags
	}

	usedIpsVal, ok := usedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`used_ips expected to be ovhtypes.TfInt64Value, was: %T`, usedIpsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessCurrentStateSubnetsServiceRangeValue{
		Cidr:         cidrVal,
		RemainingIps: remainingIpsVal,
		ReservedIps:  reservedIpsVal,
		UsedIps:      usedIpsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsServiceRangeValueNull() VrackservicessCurrentStateSubnetsServiceRangeValue {
	return VrackservicessCurrentStateSubnetsServiceRangeValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown() VrackservicessCurrentStateSubnetsServiceRangeValue {
	return VrackservicessCurrentStateSubnetsServiceRangeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessCurrentStateSubnetsServiceRangeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessCurrentStateSubnetsServiceRangeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessCurrentStateSubnetsServiceRangeValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsServiceRangeValue value, a missing attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceRangeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessCurrentStateSubnetsServiceRangeValue Attribute Type",
				"While creating a VrackservicessCurrentStateSubnetsServiceRangeValue value, an invalid attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceRangeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessCurrentStateSubnetsServiceRangeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessCurrentStateSubnetsServiceRangeValue Attribute Value",
				"While creating a VrackservicessCurrentStateSubnetsServiceRangeValue value, an extra attribute value was detected. "+
					"A VrackservicessCurrentStateSubnetsServiceRangeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessCurrentStateSubnetsServiceRangeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	remainingIpsAttribute, ok := attributes["remaining_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remaining_ips is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	remainingIpsVal, ok := remainingIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remaining_ips expected to be ovhtypes.TfInt64Value, was: %T`, remainingIpsAttribute))
	}

	reservedIpsAttribute, ok := attributes["reserved_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_ips is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	reservedIpsVal, ok := reservedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_ips expected to be ovhtypes.TfInt64Value, was: %T`, reservedIpsAttribute))
	}

	usedIpsAttribute, ok := attributes["used_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`used_ips is missing from object`)

		return NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	usedIpsVal, ok := usedIpsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`used_ips expected to be ovhtypes.TfInt64Value, was: %T`, usedIpsAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown(), diags
	}

	return VrackservicessCurrentStateSubnetsServiceRangeValue{
		Cidr:         cidrVal,
		RemainingIps: remainingIpsVal,
		ReservedIps:  reservedIpsVal,
		UsedIps:      usedIpsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentStateSubnetsServiceRangeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessCurrentStateSubnetsServiceRangeValue {
	object, diags := NewVrackservicessCurrentStateSubnetsServiceRangeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessCurrentStateSubnetsServiceRangeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessCurrentStateSubnetsServiceRangeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessCurrentStateSubnetsServiceRangeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessCurrentStateSubnetsServiceRangeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessCurrentStateSubnetsServiceRangeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessCurrentStateSubnetsServiceRangeValueMust(VrackservicessCurrentStateSubnetsServiceRangeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessCurrentStateSubnetsServiceRangeType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessCurrentStateSubnetsServiceRangeValue{}
}

var _ basetypes.ObjectValuable = VrackservicessCurrentStateSubnetsServiceRangeValue{}

type VrackservicessCurrentStateSubnetsServiceRangeValue struct {
	Cidr         ovhtypes.TfStringValue `tfsdk:"cidr" json:"cidr"`
	RemainingIps ovhtypes.TfInt64Value  `tfsdk:"remaining_ips" json:"remainingIps"`
	ReservedIps  ovhtypes.TfInt64Value  `tfsdk:"reserved_ips" json:"reservedIps"`
	UsedIps      ovhtypes.TfInt64Value  `tfsdk:"used_ips" json:"usedIps"`
	state        attr.ValueState
}

func (v *VrackservicessCurrentStateSubnetsServiceRangeValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessCurrentStateSubnetsServiceRangeValue VrackservicessCurrentStateSubnetsServiceRangeValue

	var tmp JsonVrackservicessCurrentStateSubnetsServiceRangeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr
	v.RemainingIps = tmp.RemainingIps
	v.ReservedIps = tmp.ReservedIps
	v.UsedIps = tmp.UsedIps

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessCurrentStateSubnetsServiceRangeValue) MergeWith(other *VrackservicessCurrentStateSubnetsServiceRangeValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.RemainingIps.IsUnknown() || v.RemainingIps.IsNull()) && !other.RemainingIps.IsUnknown() {
		v.RemainingIps = other.RemainingIps
	}

	if (v.ReservedIps.IsUnknown() || v.ReservedIps.IsNull()) && !other.ReservedIps.IsUnknown() {
		v.ReservedIps = other.ReservedIps
	}

	if (v.UsedIps.IsUnknown() || v.UsedIps.IsNull()) && !other.UsedIps.IsUnknown() {
		v.UsedIps = other.UsedIps
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr":         v.Cidr,
		"remainingIps": v.RemainingIps,
		"reservedIps":  v.ReservedIps,
		"usedIps":      v.UsedIps,
	}
}
func (v VrackservicessCurrentStateSubnetsServiceRangeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remaining_ips"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["reserved_ips"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["used_ips"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.RemainingIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remaining_ips"] = val

		val, err = v.ReservedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reserved_ips"] = val

		val, err = v.UsedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["used_ips"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) String() string {
	return "VrackservicessCurrentStateSubnetsServiceRangeValue"
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr":          ovhtypes.TfStringType{},
			"remaining_ips": ovhtypes.TfInt64Type{},
			"reserved_ips":  ovhtypes.TfInt64Type{},
			"used_ips":      ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cidr":          v.Cidr,
			"remaining_ips": v.RemainingIps,
			"reserved_ips":  v.ReservedIps,
			"used_ips":      v.UsedIps,
		})

	return objVal, diags
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessCurrentStateSubnetsServiceRangeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.RemainingIps.Equal(other.RemainingIps) {
		return false
	}

	if !v.ReservedIps.Equal(other.ReservedIps) {
		return false
	}

	if !v.UsedIps.Equal(other.UsedIps) {
		return false
	}

	return true
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) Type(ctx context.Context) attr.Type {
	return VrackservicessCurrentStateSubnetsServiceRangeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessCurrentStateSubnetsServiceRangeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":          ovhtypes.TfStringType{},
		"remaining_ips": ovhtypes.TfInt64Type{},
		"reserved_ips":  ovhtypes.TfInt64Type{},
		"used_ips":      ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessCurrentTasksType{}

type VrackservicessCurrentTasksType struct {
	basetypes.ObjectType
}

func (t VrackservicessCurrentTasksType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessCurrentTasksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessCurrentTasksType) String() string {
	return "VrackservicessCurrentTasksType"
}

func (t VrackservicessCurrentTasksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return nil, diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessCurrentTasksValue{
		Id:                             idVal,
		Link:                           linkVal,
		Status:                         statusVal,
		VrackservicessCurrentTasksType: typeVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentTasksValueNull() VrackservicessCurrentTasksValue {
	return VrackservicessCurrentTasksValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessCurrentTasksValueUnknown() VrackservicessCurrentTasksValue {
	return VrackservicessCurrentTasksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessCurrentTasksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessCurrentTasksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessCurrentTasksValue Attribute Value",
				"While creating a VrackservicessCurrentTasksValue value, a missing attribute value was detected. "+
					"A VrackservicessCurrentTasksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentTasksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessCurrentTasksValue Attribute Type",
				"While creating a VrackservicessCurrentTasksValue value, an invalid attribute value was detected. "+
					"A VrackservicessCurrentTasksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessCurrentTasksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessCurrentTasksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessCurrentTasksValue Attribute Value",
				"While creating a VrackservicessCurrentTasksValue value, an extra attribute value was detected. "+
					"A VrackservicessCurrentTasksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessCurrentTasksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessCurrentTasksValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVrackservicessCurrentTasksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return NewVrackservicessCurrentTasksValueUnknown(), diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewVrackservicessCurrentTasksValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVrackservicessCurrentTasksValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessCurrentTasksValueUnknown(), diags
	}

	return VrackservicessCurrentTasksValue{
		Id:                             idVal,
		Link:                           linkVal,
		Status:                         statusVal,
		VrackservicessCurrentTasksType: typeVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessCurrentTasksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessCurrentTasksValue {
	object, diags := NewVrackservicessCurrentTasksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessCurrentTasksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessCurrentTasksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessCurrentTasksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessCurrentTasksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessCurrentTasksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessCurrentTasksValueMust(VrackservicessCurrentTasksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessCurrentTasksType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessCurrentTasksValue{}
}

var _ basetypes.ObjectValuable = VrackservicessCurrentTasksValue{}

type VrackservicessCurrentTasksValue struct {
	Id                             ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	Link                           ovhtypes.TfStringValue `tfsdk:"link" json:"link"`
	Status                         ovhtypes.TfStringValue `tfsdk:"status" json:"status"`
	VrackservicessCurrentTasksType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state                          attr.ValueState
}

func (v *VrackservicessCurrentTasksValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessCurrentTasksValue VrackservicessCurrentTasksValue

	var tmp JsonVrackservicessCurrentTasksValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id
	v.Link = tmp.Link
	v.Status = tmp.Status
	v.VrackservicessCurrentTasksType = tmp.VrackservicessCurrentTasksType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessCurrentTasksValue) MergeWith(other *VrackservicessCurrentTasksValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Link.IsUnknown() || v.Link.IsNull()) && !other.Link.IsUnknown() {
		v.Link = other.Link
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.VrackservicessCurrentTasksType.IsUnknown() || v.VrackservicessCurrentTasksType.IsNull()) && !other.VrackservicessCurrentTasksType.IsUnknown() {
		v.VrackservicessCurrentTasksType = other.VrackservicessCurrentTasksType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessCurrentTasksValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id":     v.Id,
		"link":   v.Link,
		"status": v.Status,
		"type":   v.VrackservicessCurrentTasksType,
	}
}
func (v VrackservicessCurrentTasksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Link.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.VrackservicessCurrentTasksType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessCurrentTasksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessCurrentTasksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessCurrentTasksValue) String() string {
	return "VrackservicessCurrentTasksValue"
}

func (v VrackservicessCurrentTasksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":     ovhtypes.TfStringType{},
			"link":   ovhtypes.TfStringType{},
			"status": ovhtypes.TfStringType{},
			"type":   ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id":     v.Id,
			"link":   v.Link,
			"status": v.Status,
			"type":   v.VrackservicessCurrentTasksType,
		})

	return objVal, diags
}

func (v VrackservicessCurrentTasksValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessCurrentTasksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Link.Equal(other.Link) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.VrackservicessCurrentTasksType.Equal(other.VrackservicessCurrentTasksType) {
		return false
	}

	return true
}

func (v VrackservicessCurrentTasksValue) Type(ctx context.Context) attr.Type {
	return VrackservicessCurrentTasksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessCurrentTasksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":     ovhtypes.TfStringType{},
		"link":   ovhtypes.TfStringType{},
		"status": ovhtypes.TfStringType{},
		"type":   ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessIamType{}

type VrackservicessIamType struct {
	basetypes.ObjectType
}

func (t VrackservicessIamType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessIamType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessIamType) String() string {
	return "VrackservicessIamType"
}

func (t VrackservicessIamType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue], was: %T`, tagsAttribute))
	}

	urnAttribute, ok := attributes["urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`urn is missing from object`)

		return nil, diags
	}

	urnVal, ok := urnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`urn expected to be ovhtypes.TfStringValue, was: %T`, urnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessIamValue{
		DisplayName: displayNameVal,
		Id:          idVal,
		State:       stateVal,
		Tags:        tagsVal,
		Urn:         urnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessIamValueNull() VrackservicessIamValue {
	return VrackservicessIamValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessIamValueUnknown() VrackservicessIamValue {
	return VrackservicessIamValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessIamValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessIamValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessIamValue Attribute Value",
				"While creating a VrackservicessIamValue value, a missing attribute value was detected. "+
					"A VrackservicessIamValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessIamValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessIamValue Attribute Type",
				"While creating a VrackservicessIamValue value, an invalid attribute value was detected. "+
					"A VrackservicessIamValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessIamValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessIamValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessIamValue Attribute Value",
				"While creating a VrackservicessIamValue value, an extra attribute value was detected. "+
					"A VrackservicessIamValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessIamValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessIamValueUnknown(), diags
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewVrackservicessIamValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVrackservicessIamValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewVrackservicessIamValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewVrackservicessIamValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue], was: %T`, tagsAttribute))
	}

	urnAttribute, ok := attributes["urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`urn is missing from object`)

		return NewVrackservicessIamValueUnknown(), diags
	}

	urnVal, ok := urnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`urn expected to be ovhtypes.TfStringValue, was: %T`, urnAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessIamValueUnknown(), diags
	}

	return VrackservicessIamValue{
		DisplayName: displayNameVal,
		Id:          idVal,
		State:       stateVal,
		Tags:        tagsVal,
		Urn:         urnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessIamValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessIamValue {
	object, diags := NewVrackservicessIamValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessIamValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessIamType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessIamValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessIamValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessIamValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessIamValueMust(VrackservicessIamValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessIamType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessIamValue{}
}

var _ basetypes.ObjectValuable = VrackservicessIamValue{}

type VrackservicessIamValue struct {
	DisplayName ovhtypes.TfStringValue                            `tfsdk:"display_name" json:"displayName"`
	Id          ovhtypes.TfStringValue                            `tfsdk:"id" json:"id"`
	State       ovhtypes.TfStringValue                            `tfsdk:"state" json:"state"`
	Tags        ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue] `tfsdk:"tags" json:"tags"`
	Urn         ovhtypes.TfStringValue                            `tfsdk:"urn" json:"urn"`
	state       attr.ValueState
}

func (v *VrackservicessIamValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessIamValue VrackservicessIamValue

	var tmp JsonVrackservicessIamValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DisplayName = tmp.DisplayName
	v.Id = tmp.Id
	v.State = tmp.State
	v.Tags = tmp.Tags
	v.Urn = tmp.Urn

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessIamValue) MergeWith(other *VrackservicessIamValue) {

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.Tags.IsUnknown() || v.Tags.IsNull()) && !other.Tags.IsUnknown() {
		v.Tags = other.Tags
	}

	if (v.Urn.IsUnknown() || v.Urn.IsNull()) && !other.Urn.IsUnknown() {
		v.Urn = other.Urn
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessIamValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"displayName": v.DisplayName,
		"id":          v.Id,
		"state":       v.State,
		"tags":        v.Tags,
		"urn":         v.Urn,
	}
}
func (v VrackservicessIamValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["urn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Urn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["urn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessIamValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessIamValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessIamValue) String() string {
	return "VrackservicessIamValue"
}

func (v VrackservicessIamValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"display_name": ovhtypes.TfStringType{},
			"id":           ovhtypes.TfStringType{},
			"state":        ovhtypes.TfStringType{},
			"tags":         ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
			"urn":          ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"display_name": v.DisplayName,
			"id":           v.Id,
			"state":        v.State,
			"tags":         v.Tags,
			"urn":          v.Urn,
		})

	return objVal, diags
}

func (v VrackservicessIamValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessIamValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Urn.Equal(other.Urn) {
		return false
	}

	return true
}

func (v VrackservicessIamValue) Type(ctx context.Context) attr.Type {
	return VrackservicessIamType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessIamValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"display_name": ovhtypes.TfStringType{},
		"id":           ovhtypes.TfStringType{},
		"state":        ovhtypes.TfStringType{},
		"tags":         ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
		"urn":          ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessTargetSpecType{}

type VrackservicessTargetSpecType struct {
	basetypes.ObjectType
}

func (t VrackservicessTargetSpecType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessTargetSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessTargetSpecType) String() string {
	return "VrackservicessTargetSpecType"
}

func (t VrackservicessTargetSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsValue], was: %T`, subnetsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessTargetSpecValue{
		Subnets: subnetsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecValueNull() VrackservicessTargetSpecValue {
	return VrackservicessTargetSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessTargetSpecValueUnknown() VrackservicessTargetSpecValue {
	return VrackservicessTargetSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessTargetSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessTargetSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessTargetSpecValue Attribute Value",
				"While creating a VrackservicessTargetSpecValue value, a missing attribute value was detected. "+
					"A VrackservicessTargetSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessTargetSpecValue Attribute Type",
				"While creating a VrackservicessTargetSpecValue value, an invalid attribute value was detected. "+
					"A VrackservicessTargetSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessTargetSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessTargetSpecValue Attribute Value",
				"While creating a VrackservicessTargetSpecValue value, an extra attribute value was detected. "+
					"A VrackservicessTargetSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessTargetSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecValueUnknown(), diags
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewVrackservicessTargetSpecValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsValue], was: %T`, subnetsAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecValueUnknown(), diags
	}

	return VrackservicessTargetSpecValue{
		Subnets: subnetsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessTargetSpecValue {
	object, diags := NewVrackservicessTargetSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessTargetSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessTargetSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessTargetSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessTargetSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessTargetSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessTargetSpecValueMust(VrackservicessTargetSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessTargetSpecType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessTargetSpecValue{}
}

var _ basetypes.ObjectValuable = VrackservicessTargetSpecValue{}

type VrackservicessTargetSpecValue struct {
	Subnets ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsValue] `tfsdk:"subnets" json:"subnets"`
	state   attr.ValueState
}

func (v *VrackservicessTargetSpecValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessTargetSpecValue VrackservicessTargetSpecValue

	var tmp JsonVrackservicessTargetSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Subnets = tmp.Subnets

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessTargetSpecValue) MergeWith(other *VrackservicessTargetSpecValue) {

	if (v.Subnets.IsUnknown() || v.Subnets.IsNull()) && !other.Subnets.IsUnknown() {
		v.Subnets = other.Subnets
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessTargetSpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"subnets": v.Subnets,
	}
}
func (v VrackservicessTargetSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["subnets"] = basetypes.ListType{
		ElemType: VrackservicessTargetSpecSubnetsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessTargetSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessTargetSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessTargetSpecValue) String() string {
	return "VrackservicessTargetSpecValue"
}

func (v VrackservicessTargetSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"subnets": ovhtypes.NewTfListNestedType[VrackservicessTargetSpecSubnetsValue](ctx),
		},
		map[string]attr.Value{
			"subnets": v.Subnets,
		})

	return objVal, diags
}

func (v VrackservicessTargetSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessTargetSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	return true
}

func (v VrackservicessTargetSpecValue) Type(ctx context.Context) attr.Type {
	return VrackservicessTargetSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessTargetSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"subnets": ovhtypes.NewTfListNestedType[VrackservicessTargetSpecSubnetsValue](ctx),
	}
}

var _ basetypes.ObjectTypable = VrackservicessTargetSpecSubnetsType{}

type VrackservicessTargetSpecSubnetsType struct {
	basetypes.ObjectType
}

func (t VrackservicessTargetSpecSubnetsType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessTargetSpecSubnetsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessTargetSpecSubnetsType) String() string {
	return "VrackservicessTargetSpecSubnetsType"
}

func (t VrackservicessTargetSpecSubnetsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return nil, diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return nil, diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(VrackservicessTargetSpecSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be VrackservicessTargetSpecSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessTargetSpecSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecSubnetsValueNull() VrackservicessTargetSpecSubnetsValue {
	return VrackservicessTargetSpecSubnetsValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessTargetSpecSubnetsValueUnknown() VrackservicessTargetSpecSubnetsValue {
	return VrackservicessTargetSpecSubnetsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessTargetSpecSubnetsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessTargetSpecSubnetsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessTargetSpecSubnetsValue Attribute Value",
				"While creating a VrackservicessTargetSpecSubnetsValue value, a missing attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessTargetSpecSubnetsValue Attribute Type",
				"While creating a VrackservicessTargetSpecSubnetsValue value, an invalid attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessTargetSpecSubnetsValue Attribute Value",
				"While creating a VrackservicessTargetSpecSubnetsValue value, an extra attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessTargetSpecSubnetsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecSubnetsValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewVrackservicessTargetSpecSubnetsValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewVrackservicessTargetSpecSubnetsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be ovhtypes.TfStringValue, was: %T`, displayNameAttribute))
	}

	serviceEndpointsAttribute, ok := attributes["service_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_endpoints is missing from object`)

		return NewVrackservicessTargetSpecSubnetsValueUnknown(), diags
	}

	serviceEndpointsVal, ok := serviceEndpointsAttribute.(ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsServiceEndpointsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_endpoints expected to be ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsServiceEndpointsValue], was: %T`, serviceEndpointsAttribute))
	}

	serviceRangeAttribute, ok := attributes["service_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_range is missing from object`)

		return NewVrackservicessTargetSpecSubnetsValueUnknown(), diags
	}

	serviceRangeVal, ok := serviceRangeAttribute.(VrackservicessTargetSpecSubnetsServiceRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_range expected to be VrackservicessTargetSpecSubnetsServiceRangeValue, was: %T`, serviceRangeAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewVrackservicessTargetSpecSubnetsValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be ovhtypes.TfInt64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecSubnetsValueUnknown(), diags
	}

	return VrackservicessTargetSpecSubnetsValue{
		Cidr:             cidrVal,
		DisplayName:      displayNameVal,
		ServiceEndpoints: serviceEndpointsVal,
		ServiceRange:     serviceRangeVal,
		Vlan:             vlanVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecSubnetsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessTargetSpecSubnetsValue {
	object, diags := NewVrackservicessTargetSpecSubnetsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessTargetSpecSubnetsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessTargetSpecSubnetsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessTargetSpecSubnetsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessTargetSpecSubnetsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessTargetSpecSubnetsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessTargetSpecSubnetsValueMust(VrackservicessTargetSpecSubnetsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessTargetSpecSubnetsType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessTargetSpecSubnetsValue{}
}

var _ basetypes.ObjectValuable = VrackservicessTargetSpecSubnetsValue{}

type VrackservicessTargetSpecSubnetsValue struct {
	Cidr             ovhtypes.TfStringValue                                                           `tfsdk:"cidr" json:"cidr"`
	DisplayName      ovhtypes.TfStringValue                                                           `tfsdk:"display_name" json:"displayName"`
	ServiceEndpoints ovhtypes.TfListNestedValue[VrackservicessTargetSpecSubnetsServiceEndpointsValue] `tfsdk:"service_endpoints" json:"serviceEndpoints"`
	ServiceRange     VrackservicessTargetSpecSubnetsServiceRangeValue                                 `tfsdk:"service_range" json:"serviceRange"`
	Vlan             ovhtypes.TfInt64Value                                                            `tfsdk:"vlan" json:"vlan"`
	state            attr.ValueState
}

func (v *VrackservicessTargetSpecSubnetsValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessTargetSpecSubnetsValue VrackservicessTargetSpecSubnetsValue

	var tmp JsonVrackservicessTargetSpecSubnetsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr
	v.DisplayName = tmp.DisplayName
	v.ServiceEndpoints = tmp.ServiceEndpoints
	v.ServiceRange = tmp.ServiceRange
	v.Vlan = tmp.Vlan

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessTargetSpecSubnetsValue) MergeWith(other *VrackservicessTargetSpecSubnetsValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.DisplayName.IsUnknown() || v.DisplayName.IsNull()) && !other.DisplayName.IsUnknown() {
		v.DisplayName = other.DisplayName
	}

	if (v.ServiceEndpoints.IsUnknown() || v.ServiceEndpoints.IsNull()) && !other.ServiceEndpoints.IsUnknown() {
		v.ServiceEndpoints = other.ServiceEndpoints
	}

	if (v.ServiceRange.IsUnknown() || v.ServiceRange.IsNull()) && !other.ServiceRange.IsUnknown() {
		v.ServiceRange = other.ServiceRange
	}

	if (v.Vlan.IsUnknown() || v.Vlan.IsNull()) && !other.Vlan.IsUnknown() {
		v.Vlan = other.Vlan
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessTargetSpecSubnetsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr":             v.Cidr,
		"displayName":      v.DisplayName,
		"serviceEndpoints": v.ServiceEndpoints,
		"serviceRange":     v.ServiceRange,
		"vlan":             v.Vlan,
	}
}
func (v VrackservicessTargetSpecSubnetsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_endpoints"] = basetypes.ListType{
		ElemType: VrackservicessTargetSpecSubnetsServiceEndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_range"] = basetypes.ObjectType{
		AttrTypes: VrackservicessTargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.ServiceEndpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_endpoints"] = val

		val, err = v.ServiceRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_range"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessTargetSpecSubnetsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessTargetSpecSubnetsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessTargetSpecSubnetsValue) String() string {
	return "VrackservicessTargetSpecSubnetsValue"
}

func (v VrackservicessTargetSpecSubnetsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr":              ovhtypes.TfStringType{},
			"display_name":      ovhtypes.TfStringType{},
			"service_endpoints": ovhtypes.NewTfListNestedType[VrackservicessTargetSpecSubnetsServiceEndpointsValue](ctx),
			"service_range": VrackservicessTargetSpecSubnetsServiceRangeType{
				basetypes.ObjectType{
					AttrTypes: VrackservicessTargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx),
				},
			},
			"vlan": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"display_name":      v.DisplayName,
			"service_endpoints": v.ServiceEndpoints,
			"service_range":     v.ServiceRange,
			"vlan":              v.Vlan,
		})

	return objVal, diags
}

func (v VrackservicessTargetSpecSubnetsValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessTargetSpecSubnetsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.ServiceEndpoints.Equal(other.ServiceEndpoints) {
		return false
	}

	if !v.ServiceRange.Equal(other.ServiceRange) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	return true
}

func (v VrackservicessTargetSpecSubnetsValue) Type(ctx context.Context) attr.Type {
	return VrackservicessTargetSpecSubnetsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessTargetSpecSubnetsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              ovhtypes.TfStringType{},
		"display_name":      ovhtypes.TfStringType{},
		"service_endpoints": ovhtypes.NewTfListNestedType[VrackservicessTargetSpecSubnetsServiceEndpointsValue](ctx),
		"service_range":     VrackservicessTargetSpecSubnetsServiceRangeValue{}.Type(ctx),
		"vlan":              ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessTargetSpecSubnetsServiceEndpointsType{}

type VrackservicessTargetSpecSubnetsServiceEndpointsType struct {
	basetypes.ObjectType
}

func (t VrackservicessTargetSpecSubnetsServiceEndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessTargetSpecSubnetsServiceEndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessTargetSpecSubnetsServiceEndpointsType) String() string {
	return "VrackservicessTargetSpecSubnetsServiceEndpointsType"
}

func (t VrackservicessTargetSpecSubnetsServiceEndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return nil, diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessTargetSpecSubnetsServiceEndpointsValue{
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecSubnetsServiceEndpointsValueNull() VrackservicessTargetSpecSubnetsServiceEndpointsValue {
	return VrackservicessTargetSpecSubnetsServiceEndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessTargetSpecSubnetsServiceEndpointsValueUnknown() VrackservicessTargetSpecSubnetsServiceEndpointsValue {
	return VrackservicessTargetSpecSubnetsServiceEndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessTargetSpecSubnetsServiceEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessTargetSpecSubnetsServiceEndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessTargetSpecSubnetsServiceEndpointsValue Attribute Value",
				"While creating a VrackservicessTargetSpecSubnetsServiceEndpointsValue value, a missing attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsServiceEndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessTargetSpecSubnetsServiceEndpointsValue Attribute Type",
				"While creating a VrackservicessTargetSpecSubnetsServiceEndpointsValue value, an invalid attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsServiceEndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsServiceEndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsServiceEndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessTargetSpecSubnetsServiceEndpointsValue Attribute Value",
				"While creating a VrackservicessTargetSpecSubnetsServiceEndpointsValue value, an extra attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsServiceEndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessTargetSpecSubnetsServiceEndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecSubnetsServiceEndpointsValueUnknown(), diags
	}

	managedServiceUrnAttribute, ok := attributes["managed_service_urn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_service_urn is missing from object`)

		return NewVrackservicessTargetSpecSubnetsServiceEndpointsValueUnknown(), diags
	}

	managedServiceUrnVal, ok := managedServiceUrnAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_service_urn expected to be ovhtypes.TfStringValue, was: %T`, managedServiceUrnAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecSubnetsServiceEndpointsValueUnknown(), diags
	}

	return VrackservicessTargetSpecSubnetsServiceEndpointsValue{
		ManagedServiceUrn: managedServiceUrnVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecSubnetsServiceEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessTargetSpecSubnetsServiceEndpointsValue {
	object, diags := NewVrackservicessTargetSpecSubnetsServiceEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessTargetSpecSubnetsServiceEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessTargetSpecSubnetsServiceEndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessTargetSpecSubnetsServiceEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessTargetSpecSubnetsServiceEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessTargetSpecSubnetsServiceEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessTargetSpecSubnetsServiceEndpointsValueMust(VrackservicessTargetSpecSubnetsServiceEndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessTargetSpecSubnetsServiceEndpointsType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessTargetSpecSubnetsServiceEndpointsValue{}
}

var _ basetypes.ObjectValuable = VrackservicessTargetSpecSubnetsServiceEndpointsValue{}

type VrackservicessTargetSpecSubnetsServiceEndpointsValue struct {
	ManagedServiceUrn ovhtypes.TfStringValue `tfsdk:"managed_service_urn" json:"managedServiceUrn"`
	state             attr.ValueState
}

func (v *VrackservicessTargetSpecSubnetsServiceEndpointsValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessTargetSpecSubnetsServiceEndpointsValue VrackservicessTargetSpecSubnetsServiceEndpointsValue

	var tmp JsonVrackservicessTargetSpecSubnetsServiceEndpointsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.ManagedServiceUrn = tmp.ManagedServiceUrn

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessTargetSpecSubnetsServiceEndpointsValue) MergeWith(other *VrackservicessTargetSpecSubnetsServiceEndpointsValue) {

	if (v.ManagedServiceUrn.IsUnknown() || v.ManagedServiceUrn.IsNull()) && !other.ManagedServiceUrn.IsUnknown() {
		v.ManagedServiceUrn = other.ManagedServiceUrn
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"managedServiceUrn": v.ManagedServiceUrn,
	}
}
func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["managed_service_urn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ManagedServiceUrn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_service_urn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) String() string {
	return "VrackservicessTargetSpecSubnetsServiceEndpointsValue"
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"managed_service_urn": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"managed_service_urn": v.ManagedServiceUrn,
		})

	return objVal, diags
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessTargetSpecSubnetsServiceEndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ManagedServiceUrn.Equal(other.ManagedServiceUrn) {
		return false
	}

	return true
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) Type(ctx context.Context) attr.Type {
	return VrackservicessTargetSpecSubnetsServiceEndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessTargetSpecSubnetsServiceEndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"managed_service_urn": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackservicessTargetSpecSubnetsServiceRangeType{}

type VrackservicessTargetSpecSubnetsServiceRangeType struct {
	basetypes.ObjectType
}

func (t VrackservicessTargetSpecSubnetsServiceRangeType) Equal(o attr.Type) bool {
	other, ok := o.(VrackservicessTargetSpecSubnetsServiceRangeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackservicessTargetSpecSubnetsServiceRangeType) String() string {
	return "VrackservicessTargetSpecSubnetsServiceRangeType"
}

func (t VrackservicessTargetSpecSubnetsServiceRangeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackservicessTargetSpecSubnetsServiceRangeValue{
		Cidr:  cidrVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecSubnetsServiceRangeValueNull() VrackservicessTargetSpecSubnetsServiceRangeValue {
	return VrackservicessTargetSpecSubnetsServiceRangeValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackservicessTargetSpecSubnetsServiceRangeValueUnknown() VrackservicessTargetSpecSubnetsServiceRangeValue {
	return VrackservicessTargetSpecSubnetsServiceRangeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackservicessTargetSpecSubnetsServiceRangeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackservicessTargetSpecSubnetsServiceRangeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackservicessTargetSpecSubnetsServiceRangeValue Attribute Value",
				"While creating a VrackservicessTargetSpecSubnetsServiceRangeValue value, a missing attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsServiceRangeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackservicessTargetSpecSubnetsServiceRangeValue Attribute Type",
				"While creating a VrackservicessTargetSpecSubnetsServiceRangeValue value, an invalid attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsServiceRangeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsServiceRangeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackservicessTargetSpecSubnetsServiceRangeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackservicessTargetSpecSubnetsServiceRangeValue Attribute Value",
				"While creating a VrackservicessTargetSpecSubnetsServiceRangeValue value, an extra attribute value was detected. "+
					"A VrackservicessTargetSpecSubnetsServiceRangeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackservicessTargetSpecSubnetsServiceRangeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecSubnetsServiceRangeValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewVrackservicessTargetSpecSubnetsServiceRangeValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	if diags.HasError() {
		return NewVrackservicessTargetSpecSubnetsServiceRangeValueUnknown(), diags
	}

	return VrackservicessTargetSpecSubnetsServiceRangeValue{
		Cidr:  cidrVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrackservicessTargetSpecSubnetsServiceRangeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackservicessTargetSpecSubnetsServiceRangeValue {
	object, diags := NewVrackservicessTargetSpecSubnetsServiceRangeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackservicessTargetSpecSubnetsServiceRangeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackservicessTargetSpecSubnetsServiceRangeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackservicessTargetSpecSubnetsServiceRangeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackservicessTargetSpecSubnetsServiceRangeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackservicessTargetSpecSubnetsServiceRangeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackservicessTargetSpecSubnetsServiceRangeValueMust(VrackservicessTargetSpecSubnetsServiceRangeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackservicessTargetSpecSubnetsServiceRangeType) ValueType(ctx context.Context) attr.Value {
	return VrackservicessTargetSpecSubnetsServiceRangeValue{}
}

var _ basetypes.ObjectValuable = VrackservicessTargetSpecSubnetsServiceRangeValue{}

type VrackservicessTargetSpecSubnetsServiceRangeValue struct {
	Cidr  ovhtypes.TfStringValue `tfsdk:"cidr" json:"cidr"`
	state attr.ValueState
}

func (v *VrackservicessTargetSpecSubnetsServiceRangeValue) UnmarshalJSON(data []byte) error {
	type JsonVrackservicessTargetSpecSubnetsServiceRangeValue VrackservicessTargetSpecSubnetsServiceRangeValue

	var tmp JsonVrackservicessTargetSpecSubnetsServiceRangeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cidr = tmp.Cidr

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackservicessTargetSpecSubnetsServiceRangeValue) MergeWith(other *VrackservicessTargetSpecSubnetsServiceRangeValue) {

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidr": v.Cidr,
	}
}
func (v VrackservicessTargetSpecSubnetsServiceRangeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) String() string {
	return "VrackservicessTargetSpecSubnetsServiceRangeValue"
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cidr": v.Cidr,
		})

	return objVal, diags
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackservicessTargetSpecSubnetsServiceRangeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	return true
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) Type(ctx context.Context) attr.Type {
	return VrackservicessTargetSpecSubnetsServiceRangeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackservicessTargetSpecSubnetsServiceRangeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr": ovhtypes.TfStringType{},
	}
}
