// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func VmwareCloudDirectorBackupDataSourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"backup_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Backup ID",
			MarkdownDescription: "Backup ID",
		},
		"created_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Datetime when backup was enabled",
			MarkdownDescription: "Datetime when backup was enabled",
		},
		"current_state": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"az_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Availability zone of VMware Cloud Director organization backup",
					MarkdownDescription: "Availability zone of VMware Cloud Director organization backup",
				},
				"offers": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Backup service offer type (BRONZE|SILVER|GOLD)",
								MarkdownDescription: "Backup service offer type (BRONZE|SILVER|GOLD)",
							},
							"protection_primary_region": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Backup repository primary region",
								MarkdownDescription: "Backup repository primary region",
							},
							"protection_replicated_region": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Backup repository replicated region",
								MarkdownDescription: "Backup repository replicated region",
							},
							"quota_in_tb": schema.Int64Attribute{
								CustomType:          ovhtypes.TfInt64Type{},
								Computed:            true,
								Description:         "Backup repository quota in TB",
								MarkdownDescription: "Backup repository quota in TB",
							},
							"status": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Backup offer status",
								MarkdownDescription: "Backup offer status",
							},
							"used_space_in_gb": schema.NumberAttribute{
								CustomType:          ovhtypes.TfNumberType{},
								Computed:            true,
								Description:         "Backup repository used space in GB",
								MarkdownDescription: "Backup repository used space in GB",
							},
						},
						CustomType: CurrentStateOffersType{
							ObjectType: types.ObjectType{
								AttrTypes: CurrentStateOffersValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[CurrentStateOffersValue](ctx),
					Computed:            true,
					Description:         "List of your VMware Cloud Director organization backup offers",
					MarkdownDescription: "List of your VMware Cloud Director organization backup offers",
				},
			},
			CustomType: VCDBackupCurrentStateType{
				ObjectType: types.ObjectType{
					AttrTypes: VCDBackupCurrentStateValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "VMware Cloud Director Backup service current state",
			MarkdownDescription: "VMware Cloud Director Backup service current state",
		},
		"current_tasks": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Identifier of the current task",
						MarkdownDescription: "Identifier of the current task",
					},
					"link": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Link to the task details",
						MarkdownDescription: "Link to the task details",
					},
					"status": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Current global status of the current task",
						MarkdownDescription: "Current global status of the current task",
					},
					"type": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Type of the current task",
						MarkdownDescription: "Type of the current task",
					},
				},
				CustomType: CurrentTasksType{
					ObjectType: types.ObjectType{
						AttrTypes: CurrentTasksValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[CurrentTasksValue](ctx),
			Computed:            true,
			Description:         "Asynchronous operations ongoing on the VMware Cloud Director organization backup service",
			MarkdownDescription: "Asynchronous operations ongoing on the VMware Cloud Director organization backup service",
		},
		"iam": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"display_name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Resource display name",
					MarkdownDescription: "Resource display name",
				},
				"id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique identifier of the resource",
					MarkdownDescription: "Unique identifier of the resource",
				},
				"tags": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Resource tags. Tags that were internally computed are prefixed with ovh:",
					MarkdownDescription: "Resource tags. Tags that were internally computed are prefixed with ovh:",
				},
				"urn": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Unique resource name used in policies",
					MarkdownDescription: "Unique resource name used in policies",
				},
			},
			CustomType: IamType{
				ObjectType: types.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "IAM resource metadata",
			MarkdownDescription: "IAM resource metadata",
		},
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Unique identifier of the VMware Cloud Director backup",
			MarkdownDescription: "Unique identifier of the VMware Cloud Director backup",
		},
		"resource_status": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Reflects the readiness of the VMware Cloud Director organization backup service. A new target specification request will be accepted only in `READY` status",
			MarkdownDescription: "Reflects the readiness of the VMware Cloud Director organization backup service. A new target specification request will be accepted only in `READY` status",
		},
		"target_spec": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"offers": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Backup service offer type (BRONZE|SILVER|GOLD)",
								MarkdownDescription: "Backup service offer type (BRONZE|SILVER|GOLD)",
							},
							"quota_in_tb": schema.Int64Attribute{
								CustomType:          ovhtypes.TfInt64Type{},
								Computed:            true,
								Description:         "Backup repository quota in TB",
								MarkdownDescription: "Backup repository quota in TB",
							},
						},
						CustomType: TargetSpecOffersType{
							ObjectType: types.ObjectType{
								AttrTypes: TargetSpecOffersValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[TargetSpecOffersValue](ctx),
					Computed:            true,
					Description:         "List of your VMware Cloud Director backup offers",
					MarkdownDescription: "List of your VMware Cloud Director backup offers",
				},
			},
			CustomType: VCDBackupTargetSpecType{
				ObjectType: types.ObjectType{
					AttrTypes: VCDBackupTargetSpecValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "VMware Cloud Director Backup target spec",
			MarkdownDescription: "VMware Cloud Director Backup target spec",
		},
		"updated_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Datetime when backup is modified",
			MarkdownDescription: "Datetime when backup is modified",
		},
	}

	return schema.Schema{
		Description: "Get VMware Cloud Director Backup service",
		Attributes:  attrs,
	}
}

type VmwareCloudDirectorBackupModel struct {
	BackupId       ovhtypes.TfStringValue                        `tfsdk:"backup_id" json:"backupId"`
	CreatedAt      ovhtypes.TfStringValue                        `tfsdk:"created_at" json:"createdAt"`
	CurrentState   VCDBackupCurrentStateValue                    `tfsdk:"current_state" json:"currentState"`
	CurrentTasks   ovhtypes.TfListNestedValue[CurrentTasksValue] `tfsdk:"current_tasks" json:"currentTasks"`
	Iam            IamValue                                      `tfsdk:"iam" json:"iam"`
	Id             ovhtypes.TfStringValue                        `tfsdk:"id" json:"id"`
	ResourceStatus ovhtypes.TfStringValue                        `tfsdk:"resource_status" json:"resourceStatus"`
	TargetSpec     VCDBackupTargetSpecValue                      `tfsdk:"target_spec" json:"targetSpec"`
	UpdatedAt      ovhtypes.TfStringValue                        `tfsdk:"updated_at" json:"updatedAt"`
}

func (v *VmwareCloudDirectorBackupModel) MergeWith(other *VmwareCloudDirectorBackupModel) {

	if (v.BackupId.IsUnknown() || v.BackupId.IsNull()) && !other.BackupId.IsUnknown() {
		v.BackupId = other.BackupId
	}

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if (v.CurrentState.IsUnknown() || v.CurrentState.IsNull()) && !other.CurrentState.IsUnknown() {
		v.CurrentState = other.CurrentState
	}

	if (v.CurrentTasks.IsUnknown() || v.CurrentTasks.IsNull()) && !other.CurrentTasks.IsUnknown() {
		v.CurrentTasks = other.CurrentTasks
	}

	if (v.Iam.IsUnknown() || v.Iam.IsNull()) && !other.Iam.IsUnknown() {
		v.Iam = other.Iam
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.ResourceStatus.IsUnknown() || v.ResourceStatus.IsNull()) && !other.ResourceStatus.IsUnknown() {
		v.ResourceStatus = other.ResourceStatus
	}

	if (v.TargetSpec.IsUnknown() || v.TargetSpec.IsNull()) && !other.TargetSpec.IsUnknown() {
		v.TargetSpec = other.TargetSpec
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

}

var _ basetypes.ObjectTypable = VCDBackupCurrentStateType{}

type VCDBackupCurrentStateType struct {
	basetypes.ObjectType
}

func (t VCDBackupCurrentStateType) Equal(o attr.Type) bool {
	other, ok := o.(VCDBackupCurrentStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VCDBackupCurrentStateType) String() string {
	return "VCDBackupCurrentStateType"
}

func (t VCDBackupCurrentStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	azNameAttribute, ok := attributes["az_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`az_name is missing from object`)

		return nil, diags
	}

	azNameVal, ok := azNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`az_name expected to be ovhtypes.TfStringValue, was: %T`, azNameAttribute))
	}

	offersAttribute, ok := attributes["offers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offers is missing from object`)

		return nil, diags
	}

	offersVal, ok := offersAttribute.(ovhtypes.TfListNestedValue[CurrentStateOffersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offers expected to be ovhtypes.TfListNestedValue[CurrentStateOffersValue], was: %T`, offersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VCDBackupCurrentStateValue{
		AzName: azNameVal,
		Offers: offersVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVCDBackupCurrentStateValueNull() VCDBackupCurrentStateValue {
	return VCDBackupCurrentStateValue{
		state: attr.ValueStateNull,
	}
}

func NewVCDBackupCurrentStateValueUnknown() VCDBackupCurrentStateValue {
	return VCDBackupCurrentStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVCDBackupCurrentStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VCDBackupCurrentStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VCDBackupCurrentStateValue Attribute Value",
				"While creating a VCDBackupCurrentStateValue value, a missing attribute value was detected. "+
					"A VCDBackupCurrentStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VCDBackupCurrentStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VCDBackupCurrentStateValue Attribute Type",
				"While creating a VCDBackupCurrentStateValue value, an invalid attribute value was detected. "+
					"A VCDBackupCurrentStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VCDBackupCurrentStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VCDBackupCurrentStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VCDBackupCurrentStateValue Attribute Value",
				"While creating a VCDBackupCurrentStateValue value, an extra attribute value was detected. "+
					"A VCDBackupCurrentStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VCDBackupCurrentStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVCDBackupCurrentStateValueUnknown(), diags
	}

	azNameAttribute, ok := attributes["az_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`az_name is missing from object`)

		return NewVCDBackupCurrentStateValueUnknown(), diags
	}

	azNameVal, ok := azNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`az_name expected to be ovhtypes.TfStringValue, was: %T`, azNameAttribute))
	}

	offersAttribute, ok := attributes["offers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offers is missing from object`)

		return NewVCDBackupCurrentStateValueUnknown(), diags
	}

	offersVal, ok := offersAttribute.(ovhtypes.TfListNestedValue[CurrentStateOffersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offers expected to be ovhtypes.TfListNestedValue[CurrentStateOffersValue], was: %T`, offersAttribute))
	}

	if diags.HasError() {
		return NewVCDBackupCurrentStateValueUnknown(), diags
	}

	return VCDBackupCurrentStateValue{
		AzName: azNameVal,
		Offers: offersVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVCDBackupCurrentStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VCDBackupCurrentStateValue {
	object, diags := NewVCDBackupCurrentStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVCDBackupCurrentStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VCDBackupCurrentStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVCDBackupCurrentStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVCDBackupCurrentStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVCDBackupCurrentStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVCDBackupCurrentStateValueMust(VCDBackupCurrentStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VCDBackupCurrentStateType) ValueType(ctx context.Context) attr.Value {
	return VCDBackupCurrentStateValue{}
}

var _ basetypes.ObjectValuable = VCDBackupCurrentStateValue{}

type VCDBackupCurrentStateValue struct {
	AzName ovhtypes.TfStringValue                              `tfsdk:"az_name" json:"azName"`
	Offers ovhtypes.TfListNestedValue[CurrentStateOffersValue] `tfsdk:"offers" json:"offers"`
	state  attr.ValueState
}

func (v *VCDBackupCurrentStateValue) UnmarshalJSON(data []byte) error {
	type JsonVCDBackupCurrentStateValue VCDBackupCurrentStateValue

	var tmp JsonVCDBackupCurrentStateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.AzName = tmp.AzName
	v.Offers = tmp.Offers

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VCDBackupCurrentStateValue) MergeWith(other *VCDBackupCurrentStateValue) {

	if (v.AzName.IsUnknown() || v.AzName.IsNull()) && !other.AzName.IsUnknown() {
		v.AzName = other.AzName
	}

	if (v.Offers.IsUnknown() || v.Offers.IsNull()) && !other.Offers.IsUnknown() {
		v.Offers = other.Offers
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VCDBackupCurrentStateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"azName": v.AzName,
		"offers": v.Offers,
	}
}
func (v VCDBackupCurrentStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["az_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["offers"] = basetypes.ListType{
		ElemType: CurrentStateOffersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AzName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["az_name"] = val

		val, err = v.Offers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VCDBackupCurrentStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VCDBackupCurrentStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VCDBackupCurrentStateValue) String() string {
	return "VCDBackupCurrentStateValue"
}

func (v VCDBackupCurrentStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"az_name": ovhtypes.TfStringType{},
			"offers":  ovhtypes.NewTfListNestedType[CurrentStateOffersValue](ctx),
		},
		map[string]attr.Value{
			"az_name": v.AzName,
			"offers":  v.Offers,
		})

	return objVal, diags
}

func (v VCDBackupCurrentStateValue) Equal(o attr.Value) bool {
	other, ok := o.(VCDBackupCurrentStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AzName.Equal(other.AzName) {
		return false
	}

	if !v.Offers.Equal(other.Offers) {
		return false
	}

	return true
}

func (v VCDBackupCurrentStateValue) Type(ctx context.Context) attr.Type {
	return VCDBackupCurrentStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VCDBackupCurrentStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"az_name": ovhtypes.TfStringType{},
		"offers":  ovhtypes.NewTfListNestedType[CurrentStateOffersValue](ctx),
	}
}

var _ basetypes.ObjectTypable = CurrentStateOffersType{}

type CurrentStateOffersType struct {
	basetypes.ObjectType
}

func (t CurrentStateOffersType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateOffersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateOffersType) String() string {
	return "CurrentStateOffersType"
}

func (t CurrentStateOffersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protectionPrimaryRegionAttribute, ok := attributes["protection_primary_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protection_primary_region is missing from object`)

		return nil, diags
	}

	protectionPrimaryRegionVal, ok := protectionPrimaryRegionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protection_primary_region expected to be ovhtypes.TfStringValue, was: %T`, protectionPrimaryRegionAttribute))
	}

	protectionReplicatedRegionAttribute, ok := attributes["protection_replicated_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protection_replicated_region is missing from object`)

		return nil, diags
	}

	protectionReplicatedRegionVal, ok := protectionReplicatedRegionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protection_replicated_region expected to be ovhtypes.TfStringValue, was: %T`, protectionReplicatedRegionAttribute))
	}

	quotaInTbAttribute, ok := attributes["quota_in_tb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quota_in_tb is missing from object`)

		return nil, diags
	}

	quotaInTbVal, ok := quotaInTbAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quota_in_tb expected to be ovhtypes.TfInt64Value, was: %T`, quotaInTbAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	usedSpaceInGbAttribute, ok := attributes["used_space_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`used_space_in_gb is missing from object`)

		return nil, diags
	}

	usedSpaceInGbVal, ok := usedSpaceInGbAttribute.(ovhtypes.TfNumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`used_space_in_gb expected to be ovhtypes.TfNumberValue, was: %T`, usedSpaceInGbAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateOffersValue{
		Name:                       nameVal,
		ProtectionPrimaryRegion:    protectionPrimaryRegionVal,
		ProtectionReplicatedRegion: protectionReplicatedRegionVal,
		QuotaInTb:                  quotaInTbVal,
		Status:                     statusVal,
		UsedSpaceInGb:              usedSpaceInGbVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateOffersValueNull() CurrentStateOffersValue {
	return CurrentStateOffersValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateOffersValueUnknown() CurrentStateOffersValue {
	return CurrentStateOffersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateOffersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateOffersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateOffersValue Attribute Value",
				"While creating a CurrentStateOffersValue value, a missing attribute value was detected. "+
					"A CurrentStateOffersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateOffersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateOffersValue Attribute Type",
				"While creating a CurrentStateOffersValue value, an invalid attribute value was detected. "+
					"A CurrentStateOffersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateOffersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateOffersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateOffersValue Attribute Value",
				"While creating a CurrentStateOffersValue value, an extra attribute value was detected. "+
					"A CurrentStateOffersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateOffersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateOffersValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCurrentStateOffersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protectionPrimaryRegionAttribute, ok := attributes["protection_primary_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protection_primary_region is missing from object`)

		return NewCurrentStateOffersValueUnknown(), diags
	}

	protectionPrimaryRegionVal, ok := protectionPrimaryRegionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protection_primary_region expected to be ovhtypes.TfStringValue, was: %T`, protectionPrimaryRegionAttribute))
	}

	protectionReplicatedRegionAttribute, ok := attributes["protection_replicated_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protection_replicated_region is missing from object`)

		return NewCurrentStateOffersValueUnknown(), diags
	}

	protectionReplicatedRegionVal, ok := protectionReplicatedRegionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protection_replicated_region expected to be ovhtypes.TfStringValue, was: %T`, protectionReplicatedRegionAttribute))
	}

	quotaInTbAttribute, ok := attributes["quota_in_tb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quota_in_tb is missing from object`)

		return NewCurrentStateOffersValueUnknown(), diags
	}

	quotaInTbVal, ok := quotaInTbAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quota_in_tb expected to be ovhtypes.TfInt64Value, was: %T`, quotaInTbAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewCurrentStateOffersValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	usedSpaceInGbAttribute, ok := attributes["used_space_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`used_space_in_gb is missing from object`)

		return NewCurrentStateOffersValueUnknown(), diags
	}

	usedSpaceInGbVal, ok := usedSpaceInGbAttribute.(ovhtypes.TfNumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`used_space_in_gb expected to be ovhtypes.TfNumberValue, was: %T`, usedSpaceInGbAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateOffersValueUnknown(), diags
	}

	return CurrentStateOffersValue{
		Name:                       nameVal,
		ProtectionPrimaryRegion:    protectionPrimaryRegionVal,
		ProtectionReplicatedRegion: protectionReplicatedRegionVal,
		QuotaInTb:                  quotaInTbVal,
		Status:                     statusVal,
		UsedSpaceInGb:              usedSpaceInGbVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateOffersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateOffersValue {
	object, diags := NewCurrentStateOffersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateOffersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateOffersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateOffersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateOffersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateOffersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateOffersValueMust(CurrentStateOffersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateOffersType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateOffersValue{}
}

var _ basetypes.ObjectValuable = CurrentStateOffersValue{}

type CurrentStateOffersValue struct {
	Name                       ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	ProtectionPrimaryRegion    ovhtypes.TfStringValue `tfsdk:"protection_primary_region" json:"protectionPrimaryRegion"`
	ProtectionReplicatedRegion ovhtypes.TfStringValue `tfsdk:"protection_replicated_region" json:"protectionReplicatedRegion"`
	QuotaInTb                  ovhtypes.TfInt64Value  `tfsdk:"quota_in_tb" json:"quotaInTb"`
	Status                     ovhtypes.TfStringValue `tfsdk:"status" json:"status"`
	UsedSpaceInGb              ovhtypes.TfNumberValue `tfsdk:"used_space_in_gb" json:"usedSpaceInGb"`
	state                      attr.ValueState
}

func (v *CurrentStateOffersValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateOffersValue CurrentStateOffersValue

	var tmp JsonCurrentStateOffersValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name
	v.ProtectionPrimaryRegion = tmp.ProtectionPrimaryRegion
	v.ProtectionReplicatedRegion = tmp.ProtectionReplicatedRegion
	v.QuotaInTb = tmp.QuotaInTb
	v.Status = tmp.Status
	v.UsedSpaceInGb = tmp.UsedSpaceInGb

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateOffersValue) MergeWith(other *CurrentStateOffersValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.ProtectionPrimaryRegion.IsUnknown() || v.ProtectionPrimaryRegion.IsNull()) && !other.ProtectionPrimaryRegion.IsUnknown() {
		v.ProtectionPrimaryRegion = other.ProtectionPrimaryRegion
	}

	if (v.ProtectionReplicatedRegion.IsUnknown() || v.ProtectionReplicatedRegion.IsNull()) && !other.ProtectionReplicatedRegion.IsUnknown() {
		v.ProtectionReplicatedRegion = other.ProtectionReplicatedRegion
	}

	if (v.QuotaInTb.IsUnknown() || v.QuotaInTb.IsNull()) && !other.QuotaInTb.IsUnknown() {
		v.QuotaInTb = other.QuotaInTb
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.UsedSpaceInGb.IsUnknown() || v.UsedSpaceInGb.IsNull()) && !other.UsedSpaceInGb.IsUnknown() {
		v.UsedSpaceInGb = other.UsedSpaceInGb
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateOffersValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name":                       v.Name,
		"protectionPrimaryRegion":    v.ProtectionPrimaryRegion,
		"protectionReplicatedRegion": v.ProtectionReplicatedRegion,
		"quotaInTb":                  v.QuotaInTb,
		"status":                     v.Status,
		"usedSpaceInGb":              v.UsedSpaceInGb,
	}
}
func (v CurrentStateOffersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protection_primary_region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protection_replicated_region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quota_in_tb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["used_space_in_gb"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ProtectionPrimaryRegion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protection_primary_region"] = val

		val, err = v.ProtectionReplicatedRegion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protection_replicated_region"] = val

		val, err = v.QuotaInTb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quota_in_tb"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.UsedSpaceInGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["used_space_in_gb"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateOffersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateOffersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateOffersValue) String() string {
	return "CurrentStateOffersValue"
}

func (v CurrentStateOffersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name":                         ovhtypes.TfStringType{},
			"protection_primary_region":    ovhtypes.TfStringType{},
			"protection_replicated_region": ovhtypes.TfStringType{},
			"quota_in_tb":                  ovhtypes.TfInt64Type{},
			"status":                       ovhtypes.TfStringType{},
			"used_space_in_gb":             ovhtypes.TfNumberType{},
		},
		map[string]attr.Value{
			"name":                         v.Name,
			"protection_primary_region":    v.ProtectionPrimaryRegion,
			"protection_replicated_region": v.ProtectionReplicatedRegion,
			"quota_in_tb":                  v.QuotaInTb,
			"status":                       v.Status,
			"used_space_in_gb":             v.UsedSpaceInGb,
		})

	return objVal, diags
}

func (v CurrentStateOffersValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateOffersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ProtectionPrimaryRegion.Equal(other.ProtectionPrimaryRegion) {
		return false
	}

	if !v.ProtectionReplicatedRegion.Equal(other.ProtectionReplicatedRegion) {
		return false
	}

	if !v.QuotaInTb.Equal(other.QuotaInTb) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.UsedSpaceInGb.Equal(other.UsedSpaceInGb) {
		return false
	}

	return true
}

func (v CurrentStateOffersValue) Type(ctx context.Context) attr.Type {
	return CurrentStateOffersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateOffersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":                         ovhtypes.TfStringType{},
		"protection_primary_region":    ovhtypes.TfStringType{},
		"protection_replicated_region": ovhtypes.TfStringType{},
		"quota_in_tb":                  ovhtypes.TfInt64Type{},
		"status":                       ovhtypes.TfStringType{},
		"used_space_in_gb":             ovhtypes.TfNumberType{},
	}
}

var _ basetypes.ObjectTypable = VCDBackupTargetSpecType{}

type VCDBackupTargetSpecType struct {
	basetypes.ObjectType
}

func (t VCDBackupTargetSpecType) Equal(o attr.Type) bool {
	other, ok := o.(VCDBackupTargetSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VCDBackupTargetSpecType) String() string {
	return "VCDBackupTargetSpecType"
}

func (t VCDBackupTargetSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	offersAttribute, ok := attributes["offers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offers is missing from object`)

		return nil, diags
	}

	offersVal, ok := offersAttribute.(ovhtypes.TfListNestedValue[TargetSpecOffersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offers expected to be ovhtypes.TfListNestedValue[TargetSpecOffersValue], was: %T`, offersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VCDBackupTargetSpecValue{
		Offers: offersVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVCDBackupTargetSpecValueNull() VCDBackupTargetSpecValue {
	return VCDBackupTargetSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewVCDBackupTargetSpecValueUnknown() VCDBackupTargetSpecValue {
	return VCDBackupTargetSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVCDBackupTargetSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VCDBackupTargetSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VCDBackupTargetSpecValue Attribute Value",
				"While creating a VCDBackupTargetSpecValue value, a missing attribute value was detected. "+
					"A VCDBackupTargetSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VCDBackupTargetSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VCDBackupTargetSpecValue Attribute Type",
				"While creating a VCDBackupTargetSpecValue value, an invalid attribute value was detected. "+
					"A VCDBackupTargetSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VCDBackupTargetSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VCDBackupTargetSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VCDBackupTargetSpecValue Attribute Value",
				"While creating a VCDBackupTargetSpecValue value, an extra attribute value was detected. "+
					"A VCDBackupTargetSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VCDBackupTargetSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVCDBackupTargetSpecValueUnknown(), diags
	}

	offersAttribute, ok := attributes["offers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offers is missing from object`)

		return NewVCDBackupTargetSpecValueUnknown(), diags
	}

	offersVal, ok := offersAttribute.(ovhtypes.TfListNestedValue[TargetSpecOffersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offers expected to be ovhtypes.TfListNestedValue[TargetSpecOffersValue], was: %T`, offersAttribute))
	}

	if diags.HasError() {
		return NewVCDBackupTargetSpecValueUnknown(), diags
	}

	return VCDBackupTargetSpecValue{
		Offers: offersVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVCDBackupTargetSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VCDBackupTargetSpecValue {
	object, diags := NewVCDBackupTargetSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVCDBackupTargetSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VCDBackupTargetSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVCDBackupTargetSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVCDBackupTargetSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVCDBackupTargetSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVCDBackupTargetSpecValueMust(VCDBackupTargetSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VCDBackupTargetSpecType) ValueType(ctx context.Context) attr.Value {
	return VCDBackupTargetSpecValue{}
}

var _ basetypes.ObjectValuable = VCDBackupTargetSpecValue{}

type VCDBackupTargetSpecValue struct {
	Offers ovhtypes.TfListNestedValue[TargetSpecOffersValue] `tfsdk:"offers" json:"offers"`
	state  attr.ValueState
}

func (v *VCDBackupTargetSpecValue) UnmarshalJSON(data []byte) error {
	type JsonVCDBackupTargetSpecValue VCDBackupTargetSpecValue

	var tmp JsonVCDBackupTargetSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Offers = tmp.Offers

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VCDBackupTargetSpecValue) MergeWith(other *VCDBackupTargetSpecValue) {

	if (v.Offers.IsUnknown() || v.Offers.IsNull()) && !other.Offers.IsUnknown() {
		v.Offers = other.Offers
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VCDBackupTargetSpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"offers": v.Offers,
	}
}
func (v VCDBackupTargetSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["offers"] = basetypes.ListType{
		ElemType: TargetSpecOffersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Offers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VCDBackupTargetSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VCDBackupTargetSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VCDBackupTargetSpecValue) String() string {
	return "VCDBackupTargetSpecValue"
}

func (v VCDBackupTargetSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"offers": ovhtypes.NewTfListNestedType[TargetSpecOffersValue](ctx),
		},
		map[string]attr.Value{
			"offers": v.Offers,
		})

	return objVal, diags
}

func (v VCDBackupTargetSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(VCDBackupTargetSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Offers.Equal(other.Offers) {
		return false
	}

	return true
}

func (v VCDBackupTargetSpecValue) Type(ctx context.Context) attr.Type {
	return VCDBackupTargetSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VCDBackupTargetSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"offers": ovhtypes.NewTfListNestedType[TargetSpecOffersValue](ctx),
	}
}

var _ basetypes.ObjectTypable = TargetSpecOffersType{}

type TargetSpecOffersType struct {
	basetypes.ObjectType
}

func (t TargetSpecOffersType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecOffersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecOffersType) String() string {
	return "TargetSpecOffersType"
}

func (t TargetSpecOffersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	quotaInTbAttribute, ok := attributes["quota_in_tb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quota_in_tb is missing from object`)

		return nil, diags
	}

	quotaInTbVal, ok := quotaInTbAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quota_in_tb expected to be ovhtypes.TfInt64Value, was: %T`, quotaInTbAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecOffersValue{
		Name:      nameVal,
		QuotaInTb: quotaInTbVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecOffersValueNull() TargetSpecOffersValue {
	return TargetSpecOffersValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecOffersValueUnknown() TargetSpecOffersValue {
	return TargetSpecOffersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecOffersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecOffersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecOffersValue Attribute Value",
				"While creating a TargetSpecOffersValue value, a missing attribute value was detected. "+
					"A TargetSpecOffersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecOffersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecOffersValue Attribute Type",
				"While creating a TargetSpecOffersValue value, an invalid attribute value was detected. "+
					"A TargetSpecOffersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecOffersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecOffersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecOffersValue Attribute Value",
				"While creating a TargetSpecOffersValue value, an extra attribute value was detected. "+
					"A TargetSpecOffersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecOffersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecOffersValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTargetSpecOffersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	quotaInTbAttribute, ok := attributes["quota_in_tb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quota_in_tb is missing from object`)

		return NewTargetSpecOffersValueUnknown(), diags
	}

	quotaInTbVal, ok := quotaInTbAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quota_in_tb expected to be ovhtypes.TfInt64Value, was: %T`, quotaInTbAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecOffersValueUnknown(), diags
	}

	return TargetSpecOffersValue{
		Name:      nameVal,
		QuotaInTb: quotaInTbVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecOffersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecOffersValue {
	object, diags := NewTargetSpecOffersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecOffersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecOffersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecOffersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecOffersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecOffersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecOffersValueMust(TargetSpecOffersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecOffersType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecOffersValue{}
}

var _ basetypes.ObjectValuable = TargetSpecOffersValue{}

type TargetSpecOffersValue struct {
	Name      ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	QuotaInTb ovhtypes.TfInt64Value  `tfsdk:"quota_in_tb" json:"quotaInTb"`
	state     attr.ValueState
}

func (v *TargetSpecOffersValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecOffersValue TargetSpecOffersValue

	var tmp JsonTargetSpecOffersValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name
	v.QuotaInTb = tmp.QuotaInTb

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecOffersValue) MergeWith(other *TargetSpecOffersValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.QuotaInTb.IsUnknown() || v.QuotaInTb.IsNull()) && !other.QuotaInTb.IsUnknown() {
		v.QuotaInTb = other.QuotaInTb
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecOffersValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name":      v.Name,
		"quotaInTb": v.QuotaInTb,
	}
}
func (v TargetSpecOffersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quota_in_tb"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.QuotaInTb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quota_in_tb"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecOffersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecOffersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecOffersValue) String() string {
	return "TargetSpecOffersValue"
}

func (v TargetSpecOffersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name":        ovhtypes.TfStringType{},
			"quota_in_tb": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"name":        v.Name,
			"quota_in_tb": v.QuotaInTb,
		})

	return objVal, diags
}

func (v TargetSpecOffersValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecOffersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.QuotaInTb.Equal(other.QuotaInTb) {
		return false
	}

	return true
}

func (v TargetSpecOffersValue) Type(ctx context.Context) attr.Type {
	return TargetSpecOffersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecOffersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":        ovhtypes.TfStringType{},
		"quota_in_tb": ovhtypes.TfInt64Type{},
	}
}
