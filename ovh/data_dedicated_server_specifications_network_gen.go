// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DedicatedServerSpecificationsNetworkDataSourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"bandwidth": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"internet_to_ovh": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: BandwidthInternetToOvhType{
						ObjectType: types.ObjectType{
							AttrTypes: BandwidthInternetToOvhValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "bandwidth limitation Internet to OVH",
					MarkdownDescription: "bandwidth limitation Internet to OVH",
				},
				"ovh_to_internet": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: BandwidthOvhToInternetType{
						ObjectType: types.ObjectType{
							AttrTypes: BandwidthOvhToInternetValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "bandwidth limitation OVH to Internet",
					MarkdownDescription: "bandwidth limitation OVH to Internet",
				},
				"ovh_to_ovh": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: BandwidthOvhToOvhType{
						ObjectType: types.ObjectType{
							AttrTypes: BandwidthOvhToOvhValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "bandwidth limitation OVH to OVH",
					MarkdownDescription: "bandwidth limitation OVH to OVH",
				},
				"type": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "bandwidth offer type",
					MarkdownDescription: "bandwidth offer type",
				},
			},
			CustomType: BandwidthType{
				ObjectType: types.ObjectType{
					AttrTypes: BandwidthValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Bandwidth details",
			MarkdownDescription: "Bandwidth details",
		},
		"connection_val": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"unit": schema.StringAttribute{
					CustomType: ovhtypes.TfStringType{},
					Computed:   true,
				},
				"value": schema.Int64Attribute{
					CustomType: ovhtypes.TfInt64Type{},
					Computed:   true,
				},
			},
			CustomType: ConnectionType{
				ObjectType: types.ObjectType{
					AttrTypes: ConnectionValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Network connection flow rate",
			MarkdownDescription: "Network connection flow rate",
		},
		"ola": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"available": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Computed:            true,
					Description:         "Is the OLA feature available",
					MarkdownDescription: "Is the OLA feature available",
				},
				"available_modes": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"default": schema.BoolAttribute{
								CustomType:          ovhtypes.TfBoolType{},
								Computed:            true,
								Description:         "Is it the default configuration of the server",
								MarkdownDescription: "Is it the default configuration of the server",
							},
							"interfaces": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"aggregation": schema.BoolAttribute{
											CustomType:          ovhtypes.TfBoolType{},
											Computed:            true,
											Description:         "Interface aggregation status",
											MarkdownDescription: "Interface aggregation status",
										},
										"count": schema.Int64Attribute{
											CustomType:          ovhtypes.TfInt64Type{},
											Computed:            true,
											Description:         "Interface count",
											MarkdownDescription: "Interface count",
										},
										"type": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Computed:            true,
											Description:         "An enum describing OVH Link Aggregation interface types",
											MarkdownDescription: "An enum describing OVH Link Aggregation interface types",
										},
									},
									CustomType: OlaAvailableModesInterfacesType{
										ObjectType: types.ObjectType{
											AttrTypes: OlaAvailableModesInterfacesValue{}.AttributeTypes(ctx),
										},
									},
								},
								CustomType:          ovhtypes.NewTfListNestedType[OlaAvailableModesInterfacesValue](ctx),
								Computed:            true,
								Description:         "Interface layout",
								MarkdownDescription: "Interface layout",
							},
							"name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Mode name",
								MarkdownDescription: "Mode name",
							},
						},
						CustomType: OlaAvailableModesType{
							ObjectType: types.ObjectType{
								AttrTypes: OlaAvailableModesValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[OlaAvailableModesValue](ctx),
					Computed:            true,
					Description:         "What modes are supported",
					MarkdownDescription: "What modes are supported",
				},
				"supported_modes": schema.ListAttribute{
					CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "(DEPRECATED) What modes are supported",
					MarkdownDescription: "(DEPRECATED) What modes are supported",
				},
			},
			CustomType: OlaType{
				ObjectType: types.ObjectType{
					AttrTypes: OlaValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "OLA details",
			MarkdownDescription: "OLA details",
		},
		"routing": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"ipv4": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"gateway": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Server gateway",
							MarkdownDescription: "Server gateway",
						},
						"ip": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Server main IP",
							MarkdownDescription: "Server main IP",
						},
						"network": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Server network",
							MarkdownDescription: "Server network",
						},
					},
					CustomType: RoutingIpv4Type{
						ObjectType: types.ObjectType{
							AttrTypes: RoutingIpv4Value{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Ipv4 routing details",
					MarkdownDescription: "Ipv4 routing details",
				},
				"ipv6": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"gateway": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Server gateway",
							MarkdownDescription: "Server gateway",
						},
						"ip": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Server main IP",
							MarkdownDescription: "Server main IP",
						},
						"network": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Server network",
							MarkdownDescription: "Server network",
						},
					},
					CustomType: RoutingIpv6Type{
						ObjectType: types.ObjectType{
							AttrTypes: RoutingIpv6Value{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Ipv6 routing details",
					MarkdownDescription: "Ipv6 routing details",
				},
			},
			CustomType: RoutingType{
				ObjectType: types.ObjectType{
					AttrTypes: RoutingValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Routing details",
			MarkdownDescription: "Routing details",
		},
		"service_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "The internal name of your dedicated server",
			MarkdownDescription: "The internal name of your dedicated server",
		},
		"switching": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Switch name",
					MarkdownDescription: "Switch name",
				},
			},
			CustomType: SwitchingType{
				ObjectType: types.ObjectType{
					AttrTypes: SwitchingValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Switching details",
			MarkdownDescription: "Switching details",
		},
		"traffic": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"input_quota_size": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: TrafficInputQuotaSizeType{
						ObjectType: types.ObjectType{
							AttrTypes: TrafficInputQuotaSizeValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Monthly input traffic quota allowed",
					MarkdownDescription: "Monthly input traffic quota allowed",
				},
				"input_quota_used": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: TrafficInputQuotaUsedType{
						ObjectType: types.ObjectType{
							AttrTypes: TrafficInputQuotaUsedValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Monthly input traffic consumed this month",
					MarkdownDescription: "Monthly input traffic consumed this month",
				},
				"is_throttled": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Computed:            true,
					Description:         "Is bandwidth throttleted for being over quota",
					MarkdownDescription: "Is bandwidth throttleted for being over quota",
				},
				"output_quota_size": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: TrafficOutputQuotaSizeType{
						ObjectType: types.ObjectType{
							AttrTypes: TrafficOutputQuotaSizeValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Monthly output traffic quota allowed",
					MarkdownDescription: "Monthly output traffic quota allowed",
				},
				"output_quota_used": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: TrafficOutputQuotaUsedType{
						ObjectType: types.ObjectType{
							AttrTypes: TrafficOutputQuotaUsedValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Monthly output traffic consumed this month",
					MarkdownDescription: "Monthly output traffic consumed this month",
				},
				"reset_quota_date": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Next reset quota date for traffic counter",
					MarkdownDescription: "Next reset quota date for traffic counter",
				},
			},
			CustomType: TrafficType{
				ObjectType: types.ObjectType{
					AttrTypes: TrafficValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Traffic details",
			MarkdownDescription: "Traffic details",
		},
		"vmac": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"supported": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Computed:            true,
					Description:         "Server is compatible vmac or not",
					MarkdownDescription: "Server is compatible vmac or not",
				},
			},
			CustomType: VmacType{
				ObjectType: types.ObjectType{
					AttrTypes: VmacValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "A structure describing VMAC Infos for this dedicated server",
			MarkdownDescription: "A structure describing VMAC Infos for this dedicated server",
		},
		"vrack": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"bandwidth": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: VrackBandwidthType{
						ObjectType: types.ObjectType{
							AttrTypes: VrackBandwidthValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "vrack bandwidth limitation",
					MarkdownDescription: "vrack bandwidth limitation",
				},
				"type": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "bandwidth offer type",
					MarkdownDescription: "bandwidth offer type",
				},
			},
			CustomType: VrackType{
				ObjectType: types.ObjectType{
					AttrTypes: VrackValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "vRack details",
			MarkdownDescription: "vRack details",
		},
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type DedicatedServerSpecificationsNetworkModel struct {
	Bandwidth   BandwidthValue         `tfsdk:"bandwidth" json:"bandwidth"`
	Connection  ConnectionValue        `tfsdk:"connection_val" json:"connection"`
	Ola         OlaValue               `tfsdk:"ola" json:"ola"`
	Routing     RoutingValue           `tfsdk:"routing" json:"routing"`
	ServiceName ovhtypes.TfStringValue `tfsdk:"service_name" json:"serviceName"`
	Switching   SwitchingValue         `tfsdk:"switching" json:"switching"`
	Traffic     TrafficValue           `tfsdk:"traffic" json:"traffic"`
	Vmac        VmacValue              `tfsdk:"vmac" json:"vmac"`
	Vrack       VrackValue             `tfsdk:"vrack" json:"vrack"`
}

func (v *DedicatedServerSpecificationsNetworkModel) MergeWith(other *DedicatedServerSpecificationsNetworkModel) {

	if (v.Bandwidth.IsUnknown() || v.Bandwidth.IsNull()) && !other.Bandwidth.IsUnknown() {
		v.Bandwidth = other.Bandwidth
	}

	if (v.Connection.IsUnknown() || v.Connection.IsNull()) && !other.Connection.IsUnknown() {
		v.Connection = other.Connection
	}

	if (v.Ola.IsUnknown() || v.Ola.IsNull()) && !other.Ola.IsUnknown() {
		v.Ola = other.Ola
	}

	if (v.Routing.IsUnknown() || v.Routing.IsNull()) && !other.Routing.IsUnknown() {
		v.Routing = other.Routing
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

	if (v.Switching.IsUnknown() || v.Switching.IsNull()) && !other.Switching.IsUnknown() {
		v.Switching = other.Switching
	}

	if (v.Traffic.IsUnknown() || v.Traffic.IsNull()) && !other.Traffic.IsUnknown() {
		v.Traffic = other.Traffic
	}

	if (v.Vmac.IsUnknown() || v.Vmac.IsNull()) && !other.Vmac.IsUnknown() {
		v.Vmac = other.Vmac
	}

	if (v.Vrack.IsUnknown() || v.Vrack.IsNull()) && !other.Vrack.IsUnknown() {
		v.Vrack = other.Vrack
	}

}

var _ basetypes.ObjectTypable = BandwidthType{}

type BandwidthType struct {
	basetypes.ObjectType
}

func (t BandwidthType) Equal(o attr.Type) bool {
	other, ok := o.(BandwidthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BandwidthType) String() string {
	return "BandwidthType"
}

func (t BandwidthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internetToOvhAttribute, ok := attributes["internet_to_ovh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_to_ovh is missing from object`)

		return nil, diags
	}

	internetToOvhVal, ok := internetToOvhAttribute.(BandwidthInternetToOvhValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_to_ovh expected to be BandwidthInternetToOvhValue, was: %T`, internetToOvhAttribute))
	}

	ovhToInternetAttribute, ok := attributes["ovh_to_internet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ovh_to_internet is missing from object`)

		return nil, diags
	}

	ovhToInternetVal, ok := ovhToInternetAttribute.(BandwidthOvhToInternetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ovh_to_internet expected to be BandwidthOvhToInternetValue, was: %T`, ovhToInternetAttribute))
	}

	ovhToOvhAttribute, ok := attributes["ovh_to_ovh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ovh_to_ovh is missing from object`)

		return nil, diags
	}

	ovhToOvhVal, ok := ovhToOvhAttribute.(BandwidthOvhToOvhValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ovh_to_ovh expected to be BandwidthOvhToOvhValue, was: %T`, ovhToOvhAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BandwidthValue{
		InternetToOvh: internetToOvhVal,
		OvhToInternet: ovhToInternetVal,
		OvhToOvh:      ovhToOvhVal,
		BandwidthType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBandwidthValueNull() BandwidthValue {
	return BandwidthValue{
		state: attr.ValueStateNull,
	}
}

func NewBandwidthValueUnknown() BandwidthValue {
	return BandwidthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBandwidthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BandwidthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BandwidthValue Attribute Value",
				"While creating a BandwidthValue value, a missing attribute value was detected. "+
					"A BandwidthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BandwidthValue Attribute Type",
				"While creating a BandwidthValue value, an invalid attribute value was detected. "+
					"A BandwidthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BandwidthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BandwidthValue Attribute Value",
				"While creating a BandwidthValue value, an extra attribute value was detected. "+
					"A BandwidthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BandwidthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBandwidthValueUnknown(), diags
	}

	internetToOvhAttribute, ok := attributes["internet_to_ovh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_to_ovh is missing from object`)

		return NewBandwidthValueUnknown(), diags
	}

	internetToOvhVal, ok := internetToOvhAttribute.(BandwidthInternetToOvhValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_to_ovh expected to be BandwidthInternetToOvhValue, was: %T`, internetToOvhAttribute))
	}

	ovhToInternetAttribute, ok := attributes["ovh_to_internet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ovh_to_internet is missing from object`)

		return NewBandwidthValueUnknown(), diags
	}

	ovhToInternetVal, ok := ovhToInternetAttribute.(BandwidthOvhToInternetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ovh_to_internet expected to be BandwidthOvhToInternetValue, was: %T`, ovhToInternetAttribute))
	}

	ovhToOvhAttribute, ok := attributes["ovh_to_ovh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ovh_to_ovh is missing from object`)

		return NewBandwidthValueUnknown(), diags
	}

	ovhToOvhVal, ok := ovhToOvhAttribute.(BandwidthOvhToOvhValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ovh_to_ovh expected to be BandwidthOvhToOvhValue, was: %T`, ovhToOvhAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewBandwidthValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewBandwidthValueUnknown(), diags
	}

	return BandwidthValue{
		InternetToOvh: internetToOvhVal,
		OvhToInternet: ovhToInternetVal,
		OvhToOvh:      ovhToOvhVal,
		BandwidthType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBandwidthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BandwidthValue {
	object, diags := NewBandwidthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBandwidthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BandwidthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBandwidthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBandwidthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBandwidthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBandwidthValueMust(BandwidthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BandwidthType) ValueType(ctx context.Context) attr.Value {
	return BandwidthValue{}
}

var _ basetypes.ObjectValuable = BandwidthValue{}

type BandwidthValue struct {
	InternetToOvh BandwidthInternetToOvhValue `tfsdk:"internet_to_ovh" json:"internetToOvh"`
	OvhToInternet BandwidthOvhToInternetValue `tfsdk:"ovh_to_internet" json:"ovhToInternet"`
	OvhToOvh      BandwidthOvhToOvhValue      `tfsdk:"ovh_to_ovh" json:"ovhToOvh"`
	BandwidthType ovhtypes.TfStringValue      `tfsdk:"type" json:"type"`
	state         attr.ValueState
}

func (v *BandwidthValue) UnmarshalJSON(data []byte) error {
	type JsonBandwidthValue BandwidthValue

	var tmp JsonBandwidthValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.InternetToOvh = tmp.InternetToOvh
	v.OvhToInternet = tmp.OvhToInternet
	v.OvhToOvh = tmp.OvhToOvh
	v.BandwidthType = tmp.BandwidthType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *BandwidthValue) MergeWith(other *BandwidthValue) {

	if (v.InternetToOvh.IsUnknown() || v.InternetToOvh.IsNull()) && !other.InternetToOvh.IsUnknown() {
		v.InternetToOvh = other.InternetToOvh
	}

	if (v.OvhToInternet.IsUnknown() || v.OvhToInternet.IsNull()) && !other.OvhToInternet.IsUnknown() {
		v.OvhToInternet = other.OvhToInternet
	}

	if (v.OvhToOvh.IsUnknown() || v.OvhToOvh.IsNull()) && !other.OvhToOvh.IsUnknown() {
		v.OvhToOvh = other.OvhToOvh
	}

	if (v.BandwidthType.IsUnknown() || v.BandwidthType.IsNull()) && !other.BandwidthType.IsUnknown() {
		v.BandwidthType = other.BandwidthType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v BandwidthValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"internetToOvh": v.InternetToOvh,
		"ovhToInternet": v.OvhToInternet,
		"ovhToOvh":      v.OvhToOvh,
		"type":          v.BandwidthType,
	}
}
func (v BandwidthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["internet_to_ovh"] = basetypes.ObjectType{
		AttrTypes: BandwidthInternetToOvhValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ovh_to_internet"] = basetypes.ObjectType{
		AttrTypes: BandwidthOvhToInternetValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ovh_to_ovh"] = basetypes.ObjectType{
		AttrTypes: BandwidthOvhToOvhValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.InternetToOvh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internet_to_ovh"] = val

		val, err = v.OvhToInternet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ovh_to_internet"] = val

		val, err = v.OvhToOvh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ovh_to_ovh"] = val

		val, err = v.BandwidthType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BandwidthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BandwidthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BandwidthValue) String() string {
	return "BandwidthValue"
}

func (v BandwidthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"internet_to_ovh": BandwidthInternetToOvhType{
				basetypes.ObjectType{
					AttrTypes: BandwidthInternetToOvhValue{}.AttributeTypes(ctx),
				},
			},
			"ovh_to_internet": BandwidthOvhToInternetType{
				basetypes.ObjectType{
					AttrTypes: BandwidthOvhToInternetValue{}.AttributeTypes(ctx),
				},
			},
			"ovh_to_ovh": BandwidthOvhToOvhType{
				basetypes.ObjectType{
					AttrTypes: BandwidthOvhToOvhValue{}.AttributeTypes(ctx),
				},
			},
			"type": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"internet_to_ovh": v.InternetToOvh,
			"ovh_to_internet": v.OvhToInternet,
			"ovh_to_ovh":      v.OvhToOvh,
			"type":            v.BandwidthType,
		})

	return objVal, diags
}

func (v BandwidthValue) Equal(o attr.Value) bool {
	other, ok := o.(BandwidthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternetToOvh.Equal(other.InternetToOvh) {
		return false
	}

	if !v.OvhToInternet.Equal(other.OvhToInternet) {
		return false
	}

	if !v.OvhToOvh.Equal(other.OvhToOvh) {
		return false
	}

	if !v.BandwidthType.Equal(other.BandwidthType) {
		return false
	}

	return true
}

func (v BandwidthValue) Type(ctx context.Context) attr.Type {
	return BandwidthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BandwidthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internet_to_ovh": BandwidthInternetToOvhValue{}.Type(ctx),
		"ovh_to_internet": BandwidthOvhToInternetValue{}.Type(ctx),
		"ovh_to_ovh":      BandwidthOvhToOvhValue{}.Type(ctx),
		"type":            ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = BandwidthInternetToOvhType{}

type BandwidthInternetToOvhType struct {
	basetypes.ObjectType
}

func (t BandwidthInternetToOvhType) Equal(o attr.Type) bool {
	other, ok := o.(BandwidthInternetToOvhType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BandwidthInternetToOvhType) String() string {
	return "BandwidthInternetToOvhType"
}

func (t BandwidthInternetToOvhType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BandwidthInternetToOvhValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBandwidthInternetToOvhValueNull() BandwidthInternetToOvhValue {
	return BandwidthInternetToOvhValue{
		state: attr.ValueStateNull,
	}
}

func NewBandwidthInternetToOvhValueUnknown() BandwidthInternetToOvhValue {
	return BandwidthInternetToOvhValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBandwidthInternetToOvhValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BandwidthInternetToOvhValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BandwidthInternetToOvhValue Attribute Value",
				"While creating a BandwidthInternetToOvhValue value, a missing attribute value was detected. "+
					"A BandwidthInternetToOvhValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthInternetToOvhValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BandwidthInternetToOvhValue Attribute Type",
				"While creating a BandwidthInternetToOvhValue value, an invalid attribute value was detected. "+
					"A BandwidthInternetToOvhValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthInternetToOvhValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BandwidthInternetToOvhValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BandwidthInternetToOvhValue Attribute Value",
				"While creating a BandwidthInternetToOvhValue value, an extra attribute value was detected. "+
					"A BandwidthInternetToOvhValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BandwidthInternetToOvhValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBandwidthInternetToOvhValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewBandwidthInternetToOvhValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewBandwidthInternetToOvhValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewBandwidthInternetToOvhValueUnknown(), diags
	}

	return BandwidthInternetToOvhValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBandwidthInternetToOvhValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BandwidthInternetToOvhValue {
	object, diags := NewBandwidthInternetToOvhValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBandwidthInternetToOvhValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BandwidthInternetToOvhType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBandwidthInternetToOvhValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBandwidthInternetToOvhValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBandwidthInternetToOvhValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBandwidthInternetToOvhValueMust(BandwidthInternetToOvhValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BandwidthInternetToOvhType) ValueType(ctx context.Context) attr.Value {
	return BandwidthInternetToOvhValue{}
}

var _ basetypes.ObjectValuable = BandwidthInternetToOvhValue{}

type BandwidthInternetToOvhValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *BandwidthInternetToOvhValue) UnmarshalJSON(data []byte) error {
	type JsonBandwidthInternetToOvhValue BandwidthInternetToOvhValue

	var tmp JsonBandwidthInternetToOvhValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *BandwidthInternetToOvhValue) MergeWith(other *BandwidthInternetToOvhValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v BandwidthInternetToOvhValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v BandwidthInternetToOvhValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BandwidthInternetToOvhValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BandwidthInternetToOvhValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BandwidthInternetToOvhValue) String() string {
	return "BandwidthInternetToOvhValue"
}

func (v BandwidthInternetToOvhValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v BandwidthInternetToOvhValue) Equal(o attr.Value) bool {
	other, ok := o.(BandwidthInternetToOvhValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v BandwidthInternetToOvhValue) Type(ctx context.Context) attr.Type {
	return BandwidthInternetToOvhType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BandwidthInternetToOvhValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = BandwidthOvhToInternetType{}

type BandwidthOvhToInternetType struct {
	basetypes.ObjectType
}

func (t BandwidthOvhToInternetType) Equal(o attr.Type) bool {
	other, ok := o.(BandwidthOvhToInternetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BandwidthOvhToInternetType) String() string {
	return "BandwidthOvhToInternetType"
}

func (t BandwidthOvhToInternetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BandwidthOvhToInternetValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBandwidthOvhToInternetValueNull() BandwidthOvhToInternetValue {
	return BandwidthOvhToInternetValue{
		state: attr.ValueStateNull,
	}
}

func NewBandwidthOvhToInternetValueUnknown() BandwidthOvhToInternetValue {
	return BandwidthOvhToInternetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBandwidthOvhToInternetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BandwidthOvhToInternetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BandwidthOvhToInternetValue Attribute Value",
				"While creating a BandwidthOvhToInternetValue value, a missing attribute value was detected. "+
					"A BandwidthOvhToInternetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthOvhToInternetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BandwidthOvhToInternetValue Attribute Type",
				"While creating a BandwidthOvhToInternetValue value, an invalid attribute value was detected. "+
					"A BandwidthOvhToInternetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthOvhToInternetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BandwidthOvhToInternetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BandwidthOvhToInternetValue Attribute Value",
				"While creating a BandwidthOvhToInternetValue value, an extra attribute value was detected. "+
					"A BandwidthOvhToInternetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BandwidthOvhToInternetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBandwidthOvhToInternetValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewBandwidthOvhToInternetValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewBandwidthOvhToInternetValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewBandwidthOvhToInternetValueUnknown(), diags
	}

	return BandwidthOvhToInternetValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBandwidthOvhToInternetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BandwidthOvhToInternetValue {
	object, diags := NewBandwidthOvhToInternetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBandwidthOvhToInternetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BandwidthOvhToInternetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBandwidthOvhToInternetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBandwidthOvhToInternetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBandwidthOvhToInternetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBandwidthOvhToInternetValueMust(BandwidthOvhToInternetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BandwidthOvhToInternetType) ValueType(ctx context.Context) attr.Value {
	return BandwidthOvhToInternetValue{}
}

var _ basetypes.ObjectValuable = BandwidthOvhToInternetValue{}

type BandwidthOvhToInternetValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *BandwidthOvhToInternetValue) UnmarshalJSON(data []byte) error {
	type JsonBandwidthOvhToInternetValue BandwidthOvhToInternetValue

	var tmp JsonBandwidthOvhToInternetValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *BandwidthOvhToInternetValue) MergeWith(other *BandwidthOvhToInternetValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v BandwidthOvhToInternetValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v BandwidthOvhToInternetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BandwidthOvhToInternetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BandwidthOvhToInternetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BandwidthOvhToInternetValue) String() string {
	return "BandwidthOvhToInternetValue"
}

func (v BandwidthOvhToInternetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v BandwidthOvhToInternetValue) Equal(o attr.Value) bool {
	other, ok := o.(BandwidthOvhToInternetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v BandwidthOvhToInternetValue) Type(ctx context.Context) attr.Type {
	return BandwidthOvhToInternetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BandwidthOvhToInternetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = BandwidthOvhToOvhType{}

type BandwidthOvhToOvhType struct {
	basetypes.ObjectType
}

func (t BandwidthOvhToOvhType) Equal(o attr.Type) bool {
	other, ok := o.(BandwidthOvhToOvhType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BandwidthOvhToOvhType) String() string {
	return "BandwidthOvhToOvhType"
}

func (t BandwidthOvhToOvhType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BandwidthOvhToOvhValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBandwidthOvhToOvhValueNull() BandwidthOvhToOvhValue {
	return BandwidthOvhToOvhValue{
		state: attr.ValueStateNull,
	}
}

func NewBandwidthOvhToOvhValueUnknown() BandwidthOvhToOvhValue {
	return BandwidthOvhToOvhValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBandwidthOvhToOvhValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BandwidthOvhToOvhValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BandwidthOvhToOvhValue Attribute Value",
				"While creating a BandwidthOvhToOvhValue value, a missing attribute value was detected. "+
					"A BandwidthOvhToOvhValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthOvhToOvhValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BandwidthOvhToOvhValue Attribute Type",
				"While creating a BandwidthOvhToOvhValue value, an invalid attribute value was detected. "+
					"A BandwidthOvhToOvhValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandwidthOvhToOvhValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BandwidthOvhToOvhValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BandwidthOvhToOvhValue Attribute Value",
				"While creating a BandwidthOvhToOvhValue value, an extra attribute value was detected. "+
					"A BandwidthOvhToOvhValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BandwidthOvhToOvhValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBandwidthOvhToOvhValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewBandwidthOvhToOvhValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewBandwidthOvhToOvhValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewBandwidthOvhToOvhValueUnknown(), diags
	}

	return BandwidthOvhToOvhValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBandwidthOvhToOvhValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BandwidthOvhToOvhValue {
	object, diags := NewBandwidthOvhToOvhValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBandwidthOvhToOvhValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BandwidthOvhToOvhType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBandwidthOvhToOvhValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBandwidthOvhToOvhValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBandwidthOvhToOvhValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBandwidthOvhToOvhValueMust(BandwidthOvhToOvhValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BandwidthOvhToOvhType) ValueType(ctx context.Context) attr.Value {
	return BandwidthOvhToOvhValue{}
}

var _ basetypes.ObjectValuable = BandwidthOvhToOvhValue{}

type BandwidthOvhToOvhValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *BandwidthOvhToOvhValue) UnmarshalJSON(data []byte) error {
	type JsonBandwidthOvhToOvhValue BandwidthOvhToOvhValue

	var tmp JsonBandwidthOvhToOvhValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *BandwidthOvhToOvhValue) MergeWith(other *BandwidthOvhToOvhValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v BandwidthOvhToOvhValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v BandwidthOvhToOvhValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BandwidthOvhToOvhValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BandwidthOvhToOvhValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BandwidthOvhToOvhValue) String() string {
	return "BandwidthOvhToOvhValue"
}

func (v BandwidthOvhToOvhValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v BandwidthOvhToOvhValue) Equal(o attr.Value) bool {
	other, ok := o.(BandwidthOvhToOvhValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v BandwidthOvhToOvhValue) Type(ctx context.Context) attr.Type {
	return BandwidthOvhToOvhType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BandwidthOvhToOvhValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = ConnectionType{}

type ConnectionType struct {
	basetypes.ObjectType
}

func (t ConnectionType) Equal(o attr.Type) bool {
	other, ok := o.(ConnectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConnectionType) String() string {
	return "ConnectionType"
}

func (t ConnectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConnectionValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConnectionValueNull() ConnectionValue {
	return ConnectionValue{
		state: attr.ValueStateNull,
	}
}

func NewConnectionValueUnknown() ConnectionValue {
	return ConnectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConnectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConnectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConnectionValue Attribute Value",
				"While creating a ConnectionValue value, a missing attribute value was detected. "+
					"A ConnectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConnectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConnectionValue Attribute Type",
				"While creating a ConnectionValue value, an invalid attribute value was detected. "+
					"A ConnectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConnectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConnectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConnectionValue Attribute Value",
				"While creating a ConnectionValue value, an extra attribute value was detected. "+
					"A ConnectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConnectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConnectionValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewConnectionValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConnectionValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConnectionValueUnknown(), diags
	}

	return ConnectionValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConnectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConnectionValue {
	object, diags := NewConnectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConnectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConnectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConnectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConnectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConnectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConnectionValueMust(ConnectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConnectionType) ValueType(ctx context.Context) attr.Value {
	return ConnectionValue{}
}

var _ basetypes.ObjectValuable = ConnectionValue{}

type ConnectionValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *ConnectionValue) UnmarshalJSON(data []byte) error {
	type JsonConnectionValue ConnectionValue

	var tmp JsonConnectionValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ConnectionValue) MergeWith(other *ConnectionValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ConnectionValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v ConnectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConnectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConnectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConnectionValue) String() string {
	return "ConnectionValue"
}

func (v ConnectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConnectionValue) Equal(o attr.Value) bool {
	other, ok := o.(ConnectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConnectionValue) Type(ctx context.Context) attr.Type {
	return ConnectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConnectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = OlaType{}

type OlaType struct {
	basetypes.ObjectType
}

func (t OlaType) Equal(o attr.Type) bool {
	other, ok := o.(OlaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OlaType) String() string {
	return "OlaType"
}

func (t OlaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return nil, diags
	}

	availableVal, ok := availableAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be ovhtypes.TfBoolValue, was: %T`, availableAttribute))
	}

	availableModesAttribute, ok := attributes["available_modes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available_modes is missing from object`)

		return nil, diags
	}

	availableModesVal, ok := availableModesAttribute.(ovhtypes.TfListNestedValue[OlaAvailableModesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available_modes expected to be basetypes.ListValue, was: %T`, availableModesAttribute))
	}

	supportedModesAttribute, ok := attributes["supported_modes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supported_modes is missing from object`)

		return nil, diags
	}

	supportedModesVal, ok := supportedModesAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supported_modes expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, supportedModesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OlaValue{
		Available:      availableVal,
		AvailableModes: availableModesVal,
		SupportedModes: supportedModesVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOlaValueNull() OlaValue {
	return OlaValue{
		state: attr.ValueStateNull,
	}
}

func NewOlaValueUnknown() OlaValue {
	return OlaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOlaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OlaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OlaValue Attribute Value",
				"While creating a OlaValue value, a missing attribute value was detected. "+
					"A OlaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OlaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OlaValue Attribute Type",
				"While creating a OlaValue value, an invalid attribute value was detected. "+
					"A OlaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OlaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OlaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OlaValue Attribute Value",
				"While creating a OlaValue value, an extra attribute value was detected. "+
					"A OlaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OlaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOlaValueUnknown(), diags
	}

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return NewOlaValueUnknown(), diags
	}

	availableVal, ok := availableAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be ovhtypes.TfBoolValue, was: %T`, availableAttribute))
	}

	availableModesAttribute, ok := attributes["available_modes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available_modes is missing from object`)

		return NewOlaValueUnknown(), diags
	}

	availableModesVal, ok := availableModesAttribute.(ovhtypes.TfListNestedValue[OlaAvailableModesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available_modes expected to be ovhtypes.TfListNestedValue[OlaAvailableModesValue], was: %T`, availableModesAttribute))
	}

	supportedModesAttribute, ok := attributes["supported_modes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supported_modes is missing from object`)

		return NewOlaValueUnknown(), diags
	}

	supportedModesVal, ok := supportedModesAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supported_modes expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, supportedModesAttribute))
	}

	if diags.HasError() {
		return NewOlaValueUnknown(), diags
	}

	return OlaValue{
		Available:      availableVal,
		AvailableModes: availableModesVal,
		SupportedModes: supportedModesVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOlaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OlaValue {
	object, diags := NewOlaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOlaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OlaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOlaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOlaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOlaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOlaValueMust(OlaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OlaType) ValueType(ctx context.Context) attr.Value {
	return OlaValue{}
}

var _ basetypes.ObjectValuable = OlaValue{}

type OlaValue struct {
	Available      ovhtypes.TfBoolValue                               `tfsdk:"available" json:"available"`
	AvailableModes ovhtypes.TfListNestedValue[OlaAvailableModesValue] `tfsdk:"available_modes" json:"availableModes"`
	SupportedModes ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"supported_modes" json:"supportedModes"`
	state          attr.ValueState
}

func (v *OlaValue) UnmarshalJSON(data []byte) error {
	type JsonOlaValue OlaValue

	var tmp JsonOlaValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Available = tmp.Available
	v.AvailableModes = tmp.AvailableModes
	v.SupportedModes = tmp.SupportedModes

	v.state = attr.ValueStateKnown

	return nil
}

func (v *OlaValue) MergeWith(other *OlaValue) {

	if (v.Available.IsUnknown() || v.Available.IsNull()) && !other.Available.IsUnknown() {
		v.Available = other.Available
	}

	if (v.AvailableModes.IsUnknown() || v.AvailableModes.IsNull()) && !other.AvailableModes.IsUnknown() {
		v.AvailableModes = other.AvailableModes
	}

	if (v.SupportedModes.IsUnknown() || v.SupportedModes.IsNull()) && !other.SupportedModes.IsUnknown() {
		v.SupportedModes = other.SupportedModes
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v OlaValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"available":      v.Available,
		"availableModes": v.AvailableModes,
		"supportedModes": v.SupportedModes,
	}
}
func (v OlaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["available"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["available_modes"] = basetypes.ListType{
		ElemType: OlaAvailableModesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["supported_modes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Available.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available"] = val

		val, err = v.AvailableModes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available_modes"] = val

		val, err = v.SupportedModes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["supported_modes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OlaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OlaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OlaValue) String() string {
	return "OlaValue"
}

func (v OlaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"available":       ovhtypes.TfBoolType{},
			"available_modes": ovhtypes.NewTfListNestedType[OlaAvailableModesValue](ctx),
			"supported_modes": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		},
		map[string]attr.Value{
			"available":       v.Available,
			"available_modes": v.AvailableModes,
			"supported_modes": v.SupportedModes,
		})

	return objVal, diags
}

func (v OlaValue) Equal(o attr.Value) bool {
	other, ok := o.(OlaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Available.Equal(other.Available) {
		return false
	}

	if !v.AvailableModes.Equal(other.AvailableModes) {
		return false
	}

	if !v.SupportedModes.Equal(other.SupportedModes) {
		return false
	}

	return true
}

func (v OlaValue) Type(ctx context.Context) attr.Type {
	return OlaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OlaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"available":       ovhtypes.TfBoolType{},
		"available_modes": ovhtypes.NewTfListNestedType[OlaAvailableModesValue](ctx),
		"supported_modes": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
	}
}

var _ basetypes.ObjectTypable = OlaAvailableModesType{}

type OlaAvailableModesType struct {
	basetypes.ObjectType
}

func (t OlaAvailableModesType) Equal(o attr.Type) bool {
	other, ok := o.(OlaAvailableModesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OlaAvailableModesType) String() string {
	return "OlaAvailableModesType"
}

func (t OlaAvailableModesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return nil, diags
	}

	defaultVal, ok := defaultAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be ovhtypes.TfBoolValue, was: %T`, defaultAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return nil, diags
	}

	interfacesVal, ok := interfacesAttribute.(ovhtypes.TfListNestedValue[OlaAvailableModesInterfacesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ListValue, was: %T`, interfacesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OlaAvailableModesValue{
		Default:    defaultVal,
		Interfaces: interfacesVal,
		Name:       nameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOlaAvailableModesValueNull() OlaAvailableModesValue {
	return OlaAvailableModesValue{
		state: attr.ValueStateNull,
	}
}

func NewOlaAvailableModesValueUnknown() OlaAvailableModesValue {
	return OlaAvailableModesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOlaAvailableModesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OlaAvailableModesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OlaAvailableModesValue Attribute Value",
				"While creating a OlaAvailableModesValue value, a missing attribute value was detected. "+
					"A OlaAvailableModesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OlaAvailableModesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OlaAvailableModesValue Attribute Type",
				"While creating a OlaAvailableModesValue value, an invalid attribute value was detected. "+
					"A OlaAvailableModesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OlaAvailableModesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OlaAvailableModesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OlaAvailableModesValue Attribute Value",
				"While creating a OlaAvailableModesValue value, an extra attribute value was detected. "+
					"A OlaAvailableModesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OlaAvailableModesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOlaAvailableModesValueUnknown(), diags
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return NewOlaAvailableModesValueUnknown(), diags
	}

	defaultVal, ok := defaultAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be ovhtypes.TfBoolValue, was: %T`, defaultAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return NewOlaAvailableModesValueUnknown(), diags
	}

	interfacesVal, ok := interfacesAttribute.(ovhtypes.TfListNestedValue[OlaAvailableModesInterfacesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be ovhtypes.TfListNestedValue[OlaAvailableModesInterfacesValue], was: %T`, interfacesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOlaAvailableModesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewOlaAvailableModesValueUnknown(), diags
	}

	return OlaAvailableModesValue{
		Default:    defaultVal,
		Interfaces: interfacesVal,
		Name:       nameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOlaAvailableModesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OlaAvailableModesValue {
	object, diags := NewOlaAvailableModesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOlaAvailableModesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OlaAvailableModesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOlaAvailableModesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOlaAvailableModesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOlaAvailableModesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOlaAvailableModesValueMust(OlaAvailableModesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OlaAvailableModesType) ValueType(ctx context.Context) attr.Value {
	return OlaAvailableModesValue{}
}

var _ basetypes.ObjectValuable = OlaAvailableModesValue{}

type OlaAvailableModesValue struct {
	Default    ovhtypes.TfBoolValue                                         `tfsdk:"default" json:"default"`
	Interfaces ovhtypes.TfListNestedValue[OlaAvailableModesInterfacesValue] `tfsdk:"interfaces" json:"interfaces"`
	Name       ovhtypes.TfStringValue                                       `tfsdk:"name" json:"name"`
	state      attr.ValueState
}

func (v *OlaAvailableModesValue) UnmarshalJSON(data []byte) error {
	type JsonOlaAvailableModesValue OlaAvailableModesValue

	var tmp JsonOlaAvailableModesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Default = tmp.Default
	v.Interfaces = tmp.Interfaces
	v.Name = tmp.Name

	v.state = attr.ValueStateKnown

	return nil
}

func (v *OlaAvailableModesValue) MergeWith(other *OlaAvailableModesValue) {

	if (v.Default.IsUnknown() || v.Default.IsNull()) && !other.Default.IsUnknown() {
		v.Default = other.Default
	}

	if (v.Interfaces.IsUnknown() || v.Interfaces.IsNull()) && !other.Interfaces.IsUnknown() {
		v.Interfaces = other.Interfaces
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v OlaAvailableModesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"default":    v.Default,
		"interfaces": v.Interfaces,
		"name":       v.Name,
	}
}
func (v OlaAvailableModesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["default"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interfaces"] = basetypes.ListType{
		ElemType: OlaAvailableModesInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Default.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default"] = val

		val, err = v.Interfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interfaces"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OlaAvailableModesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OlaAvailableModesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OlaAvailableModesValue) String() string {
	return "OlaAvailableModesValue"
}

func (v OlaAvailableModesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"default":    ovhtypes.TfBoolType{},
			"interfaces": ovhtypes.NewTfListNestedType[OlaAvailableModesInterfacesValue](ctx),
			"name":       ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"default":    v.Default,
			"interfaces": v.Interfaces,
			"name":       v.Name,
		})

	return objVal, diags
}

func (v OlaAvailableModesValue) Equal(o attr.Value) bool {
	other, ok := o.(OlaAvailableModesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Default.Equal(other.Default) {
		return false
	}

	if !v.Interfaces.Equal(other.Interfaces) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v OlaAvailableModesValue) Type(ctx context.Context) attr.Type {
	return OlaAvailableModesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OlaAvailableModesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default":    ovhtypes.TfBoolType{},
		"interfaces": ovhtypes.NewTfListNestedType[OlaAvailableModesInterfacesValue](ctx),
		"name":       ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = OlaAvailableModesInterfacesType{}

type OlaAvailableModesInterfacesType struct {
	basetypes.ObjectType
}

func (t OlaAvailableModesInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(OlaAvailableModesInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OlaAvailableModesInterfacesType) String() string {
	return "OlaAvailableModesInterfacesType"
}

func (t OlaAvailableModesInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggregationAttribute, ok := attributes["aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation is missing from object`)

		return nil, diags
	}

	aggregationVal, ok := aggregationAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation expected to be ovhtypes.TfBoolValue, was: %T`, aggregationAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be ovhtypes.TfInt64Value, was: %T`, countAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OlaAvailableModesInterfacesValue{
		Aggregation:                     aggregationVal,
		Count:                           countVal,
		OlaAvailableModesInterfacesType: typeVal,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewOlaAvailableModesInterfacesValueNull() OlaAvailableModesInterfacesValue {
	return OlaAvailableModesInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewOlaAvailableModesInterfacesValueUnknown() OlaAvailableModesInterfacesValue {
	return OlaAvailableModesInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOlaAvailableModesInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OlaAvailableModesInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OlaAvailableModesInterfacesValue Attribute Value",
				"While creating a OlaAvailableModesInterfacesValue value, a missing attribute value was detected. "+
					"A OlaAvailableModesInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OlaAvailableModesInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OlaAvailableModesInterfacesValue Attribute Type",
				"While creating a OlaAvailableModesInterfacesValue value, an invalid attribute value was detected. "+
					"A OlaAvailableModesInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OlaAvailableModesInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OlaAvailableModesInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OlaAvailableModesInterfacesValue Attribute Value",
				"While creating a OlaAvailableModesInterfacesValue value, an extra attribute value was detected. "+
					"A OlaAvailableModesInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OlaAvailableModesInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOlaAvailableModesInterfacesValueUnknown(), diags
	}

	aggregationAttribute, ok := attributes["aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation is missing from object`)

		return NewOlaAvailableModesInterfacesValueUnknown(), diags
	}

	aggregationVal, ok := aggregationAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation expected to be ovhtypes.TfBoolValue, was: %T`, aggregationAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewOlaAvailableModesInterfacesValueUnknown(), diags
	}

	countVal, ok := countAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be ovhtypes.TfInt64Value, was: %T`, countAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOlaAvailableModesInterfacesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOlaAvailableModesInterfacesValueUnknown(), diags
	}

	return OlaAvailableModesInterfacesValue{
		Aggregation:                     aggregationVal,
		Count:                           countVal,
		OlaAvailableModesInterfacesType: typeVal,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewOlaAvailableModesInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OlaAvailableModesInterfacesValue {
	object, diags := NewOlaAvailableModesInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOlaAvailableModesInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OlaAvailableModesInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOlaAvailableModesInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOlaAvailableModesInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOlaAvailableModesInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOlaAvailableModesInterfacesValueMust(OlaAvailableModesInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OlaAvailableModesInterfacesType) ValueType(ctx context.Context) attr.Value {
	return OlaAvailableModesInterfacesValue{}
}

var _ basetypes.ObjectValuable = OlaAvailableModesInterfacesValue{}

type OlaAvailableModesInterfacesValue struct {
	Aggregation                     ovhtypes.TfBoolValue   `tfsdk:"aggregation" json:"aggregation"`
	Count                           ovhtypes.TfInt64Value  `tfsdk:"count" json:"count"`
	OlaAvailableModesInterfacesType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state                           attr.ValueState
}

func (v *OlaAvailableModesInterfacesValue) UnmarshalJSON(data []byte) error {
	type JsonOlaAvailableModesInterfacesValue OlaAvailableModesInterfacesValue

	var tmp JsonOlaAvailableModesInterfacesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Aggregation = tmp.Aggregation
	v.Count = tmp.Count
	v.OlaAvailableModesInterfacesType = tmp.OlaAvailableModesInterfacesType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *OlaAvailableModesInterfacesValue) MergeWith(other *OlaAvailableModesInterfacesValue) {

	if (v.Aggregation.IsUnknown() || v.Aggregation.IsNull()) && !other.Aggregation.IsUnknown() {
		v.Aggregation = other.Aggregation
	}

	if (v.Count.IsUnknown() || v.Count.IsNull()) && !other.Count.IsUnknown() {
		v.Count = other.Count
	}

	if (v.OlaAvailableModesInterfacesType.IsUnknown() || v.OlaAvailableModesInterfacesType.IsNull()) && !other.OlaAvailableModesInterfacesType.IsUnknown() {
		v.OlaAvailableModesInterfacesType = other.OlaAvailableModesInterfacesType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v OlaAvailableModesInterfacesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"aggregation": v.Aggregation,
		"count":       v.Count,
		"type":        v.OlaAvailableModesInterfacesType,
	}
}
func (v OlaAvailableModesInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["aggregation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Aggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregation"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.OlaAvailableModesInterfacesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OlaAvailableModesInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OlaAvailableModesInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OlaAvailableModesInterfacesValue) String() string {
	return "OlaAvailableModesInterfacesValue"
}

func (v OlaAvailableModesInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"aggregation": ovhtypes.TfBoolType{},
			"count":       ovhtypes.TfInt64Type{},
			"type":        ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"aggregation": v.Aggregation,
			"count":       v.Count,
			"type":        v.OlaAvailableModesInterfacesType,
		})

	return objVal, diags
}

func (v OlaAvailableModesInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(OlaAvailableModesInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aggregation.Equal(other.Aggregation) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.OlaAvailableModesInterfacesType.Equal(other.OlaAvailableModesInterfacesType) {
		return false
	}

	return true
}

func (v OlaAvailableModesInterfacesValue) Type(ctx context.Context) attr.Type {
	return OlaAvailableModesInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OlaAvailableModesInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggregation": ovhtypes.TfBoolType{},
		"count":       ovhtypes.TfInt64Type{},
		"type":        ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = RoutingType{}

type RoutingType struct {
	basetypes.ObjectType
}

func (t RoutingType) Equal(o attr.Type) bool {
	other, ok := o.(RoutingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingType) String() string {
	return "RoutingType"
}

func (t RoutingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return nil, diags
	}

	ipv4Val, ok := ipv4Attribute.(RoutingIpv4Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be RoutingIpv4Value, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return nil, diags
	}

	ipv6Val, ok := ipv6Attribute.(RoutingIpv6Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be RoutingIpv6Value, was: %T`, ipv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingValue{
		Ipv4:  ipv4Val,
		Ipv6:  ipv6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRoutingValueNull() RoutingValue {
	return RoutingValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutingValueUnknown() RoutingValue {
	return RoutingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingValue Attribute Value",
				"While creating a RoutingValue value, a missing attribute value was detected. "+
					"A RoutingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingValue Attribute Type",
				"While creating a RoutingValue value, an invalid attribute value was detected. "+
					"A RoutingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingValue Attribute Value",
				"While creating a RoutingValue value, an extra attribute value was detected. "+
					"A RoutingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingValueUnknown(), diags
	}

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return NewRoutingValueUnknown(), diags
	}

	ipv4Val, ok := ipv4Attribute.(RoutingIpv4Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be RoutingIpv4Value, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return NewRoutingValueUnknown(), diags
	}

	ipv6Val, ok := ipv6Attribute.(RoutingIpv6Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be RoutingIpv6Value, was: %T`, ipv6Attribute))
	}

	if diags.HasError() {
		return NewRoutingValueUnknown(), diags
	}

	return RoutingValue{
		Ipv4:  ipv4Val,
		Ipv6:  ipv6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRoutingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingValue {
	object, diags := NewRoutingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingValueMust(RoutingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingType) ValueType(ctx context.Context) attr.Value {
	return RoutingValue{}
}

var _ basetypes.ObjectValuable = RoutingValue{}

type RoutingValue struct {
	Ipv4  RoutingIpv4Value `tfsdk:"ipv4" json:"ipv4"`
	Ipv6  RoutingIpv6Value `tfsdk:"ipv6" json:"ipv6"`
	state attr.ValueState
}

func (v *RoutingValue) UnmarshalJSON(data []byte) error {
	type JsonRoutingValue RoutingValue

	var tmp JsonRoutingValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Ipv4 = tmp.Ipv4
	v.Ipv6 = tmp.Ipv6

	v.state = attr.ValueStateKnown

	return nil
}

func (v *RoutingValue) MergeWith(other *RoutingValue) {

	if (v.Ipv4.IsUnknown() || v.Ipv4.IsNull()) && !other.Ipv4.IsUnknown() {
		v.Ipv4 = other.Ipv4
	}

	if (v.Ipv6.IsUnknown() || v.Ipv6.IsNull()) && !other.Ipv6.IsUnknown() {
		v.Ipv6 = other.Ipv6
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v RoutingValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"ipv4": v.Ipv4,
		"ipv6": v.Ipv6,
	}
}
func (v RoutingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ipv4"] = basetypes.ObjectType{
		AttrTypes: RoutingIpv4Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6"] = basetypes.ObjectType{
		AttrTypes: RoutingIpv6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ipv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4"] = val

		val, err = v.Ipv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingValue) String() string {
	return "RoutingValue"
}

func (v RoutingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ipv4": RoutingIpv4Type{
				basetypes.ObjectType{
					AttrTypes: RoutingIpv4Value{}.AttributeTypes(ctx),
				},
			},
			"ipv6": RoutingIpv6Type{
				basetypes.ObjectType{
					AttrTypes: RoutingIpv6Value{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"ipv4": v.Ipv4,
			"ipv6": v.Ipv6,
		})

	return objVal, diags
}

func (v RoutingValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv4.Equal(other.Ipv4) {
		return false
	}

	if !v.Ipv6.Equal(other.Ipv6) {
		return false
	}

	return true
}

func (v RoutingValue) Type(ctx context.Context) attr.Type {
	return RoutingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv4": RoutingIpv4Value{}.Type(ctx),
		"ipv6": RoutingIpv6Value{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = RoutingIpv4Type{}

type RoutingIpv4Type struct {
	basetypes.ObjectType
}

func (t RoutingIpv4Type) Equal(o attr.Type) bool {
	other, ok := o.(RoutingIpv4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingIpv4Type) String() string {
	return "RoutingIpv4Type"
}

func (t RoutingIpv4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be ovhtypes.TfStringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be ovhtypes.TfStringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingIpv4Value{
		Gateway: gatewayVal,
		Ip:      ipVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRoutingIpv4ValueNull() RoutingIpv4Value {
	return RoutingIpv4Value{
		state: attr.ValueStateNull,
	}
}

func NewRoutingIpv4ValueUnknown() RoutingIpv4Value {
	return RoutingIpv4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingIpv4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingIpv4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingIpv4Value Attribute Value",
				"While creating a RoutingIpv4Value value, a missing attribute value was detected. "+
					"A RoutingIpv4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingIpv4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingIpv4Value Attribute Type",
				"While creating a RoutingIpv4Value value, an invalid attribute value was detected. "+
					"A RoutingIpv4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingIpv4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingIpv4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingIpv4Value Attribute Value",
				"While creating a RoutingIpv4Value value, an extra attribute value was detected. "+
					"A RoutingIpv4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingIpv4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingIpv4ValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewRoutingIpv4ValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be ovhtypes.TfStringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewRoutingIpv4ValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRoutingIpv4ValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be ovhtypes.TfStringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return NewRoutingIpv4ValueUnknown(), diags
	}

	return RoutingIpv4Value{
		Gateway: gatewayVal,
		Ip:      ipVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRoutingIpv4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingIpv4Value {
	object, diags := NewRoutingIpv4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingIpv4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingIpv4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingIpv4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingIpv4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingIpv4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingIpv4ValueMust(RoutingIpv4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingIpv4Type) ValueType(ctx context.Context) attr.Value {
	return RoutingIpv4Value{}
}

var _ basetypes.ObjectValuable = RoutingIpv4Value{}

type RoutingIpv4Value struct {
	Gateway ovhtypes.TfStringValue `tfsdk:"gateway" json:"gateway"`
	Ip      ovhtypes.TfStringValue `tfsdk:"ip" json:"ip"`
	Network ovhtypes.TfStringValue `tfsdk:"network" json:"network"`
	state   attr.ValueState
}

func (v *RoutingIpv4Value) UnmarshalJSON(data []byte) error {
	type JsonRoutingIpv4Value RoutingIpv4Value

	var tmp JsonRoutingIpv4Value
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Gateway = tmp.Gateway
	v.Ip = tmp.Ip
	v.Network = tmp.Network

	v.state = attr.ValueStateKnown

	return nil
}

func (v *RoutingIpv4Value) MergeWith(other *RoutingIpv4Value) {

	if (v.Gateway.IsUnknown() || v.Gateway.IsNull()) && !other.Gateway.IsUnknown() {
		v.Gateway = other.Gateway
	}

	if (v.Ip.IsUnknown() || v.Ip.IsNull()) && !other.Ip.IsUnknown() {
		v.Ip = other.Ip
	}

	if (v.Network.IsUnknown() || v.Network.IsNull()) && !other.Network.IsUnknown() {
		v.Network = other.Network
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v RoutingIpv4Value) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"gateway": v.Gateway,
		"ip":      v.Ip,
		"network": v.Network,
	}
}
func (v RoutingIpv4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingIpv4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingIpv4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingIpv4Value) String() string {
	return "RoutingIpv4Value"
}

func (v RoutingIpv4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"gateway": ovhtypes.TfStringType{},
			"ip":      ovhtypes.TfStringType{},
			"network": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"gateway": v.Gateway,
			"ip":      v.Ip,
			"network": v.Network,
		})

	return objVal, diags
}

func (v RoutingIpv4Value) Equal(o attr.Value) bool {
	other, ok := o.(RoutingIpv4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	return true
}

func (v RoutingIpv4Value) Type(ctx context.Context) attr.Type {
	return RoutingIpv4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingIpv4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway": ovhtypes.TfStringType{},
		"ip":      ovhtypes.TfStringType{},
		"network": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = RoutingIpv6Type{}

type RoutingIpv6Type struct {
	basetypes.ObjectType
}

func (t RoutingIpv6Type) Equal(o attr.Type) bool {
	other, ok := o.(RoutingIpv6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingIpv6Type) String() string {
	return "RoutingIpv6Type"
}

func (t RoutingIpv6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be ovhtypes.TfStringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be ovhtypes.TfStringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingIpv6Value{
		Gateway: gatewayVal,
		Ip:      ipVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRoutingIpv6ValueNull() RoutingIpv6Value {
	return RoutingIpv6Value{
		state: attr.ValueStateNull,
	}
}

func NewRoutingIpv6ValueUnknown() RoutingIpv6Value {
	return RoutingIpv6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingIpv6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingIpv6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingIpv6Value Attribute Value",
				"While creating a RoutingIpv6Value value, a missing attribute value was detected. "+
					"A RoutingIpv6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingIpv6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingIpv6Value Attribute Type",
				"While creating a RoutingIpv6Value value, an invalid attribute value was detected. "+
					"A RoutingIpv6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingIpv6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingIpv6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingIpv6Value Attribute Value",
				"While creating a RoutingIpv6Value value, an extra attribute value was detected. "+
					"A RoutingIpv6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingIpv6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingIpv6ValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewRoutingIpv6ValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be ovhtypes.TfStringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewRoutingIpv6ValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be ovhtypes.TfStringValue, was: %T`, ipAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRoutingIpv6ValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be ovhtypes.TfStringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return NewRoutingIpv6ValueUnknown(), diags
	}

	return RoutingIpv6Value{
		Gateway: gatewayVal,
		Ip:      ipVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRoutingIpv6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingIpv6Value {
	object, diags := NewRoutingIpv6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingIpv6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingIpv6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingIpv6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingIpv6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingIpv6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingIpv6ValueMust(RoutingIpv6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingIpv6Type) ValueType(ctx context.Context) attr.Value {
	return RoutingIpv6Value{}
}

var _ basetypes.ObjectValuable = RoutingIpv6Value{}

type RoutingIpv6Value struct {
	Gateway ovhtypes.TfStringValue `tfsdk:"gateway" json:"gateway"`
	Ip      ovhtypes.TfStringValue `tfsdk:"ip" json:"ip"`
	Network ovhtypes.TfStringValue `tfsdk:"network" json:"network"`
	state   attr.ValueState
}

func (v *RoutingIpv6Value) UnmarshalJSON(data []byte) error {
	type JsonRoutingIpv6Value RoutingIpv6Value

	var tmp JsonRoutingIpv6Value
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Gateway = tmp.Gateway
	v.Ip = tmp.Ip
	v.Network = tmp.Network

	v.state = attr.ValueStateKnown

	return nil
}

func (v *RoutingIpv6Value) MergeWith(other *RoutingIpv6Value) {

	if (v.Gateway.IsUnknown() || v.Gateway.IsNull()) && !other.Gateway.IsUnknown() {
		v.Gateway = other.Gateway
	}

	if (v.Ip.IsUnknown() || v.Ip.IsNull()) && !other.Ip.IsUnknown() {
		v.Ip = other.Ip
	}

	if (v.Network.IsUnknown() || v.Network.IsNull()) && !other.Network.IsUnknown() {
		v.Network = other.Network
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v RoutingIpv6Value) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"gateway": v.Gateway,
		"ip":      v.Ip,
		"network": v.Network,
	}
}
func (v RoutingIpv6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingIpv6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingIpv6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingIpv6Value) String() string {
	return "RoutingIpv6Value"
}

func (v RoutingIpv6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"gateway": ovhtypes.TfStringType{},
			"ip":      ovhtypes.TfStringType{},
			"network": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"gateway": v.Gateway,
			"ip":      v.Ip,
			"network": v.Network,
		})

	return objVal, diags
}

func (v RoutingIpv6Value) Equal(o attr.Value) bool {
	other, ok := o.(RoutingIpv6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	return true
}

func (v RoutingIpv6Value) Type(ctx context.Context) attr.Type {
	return RoutingIpv6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingIpv6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway": ovhtypes.TfStringType{},
		"ip":      ovhtypes.TfStringType{},
		"network": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SwitchingType{}

type SwitchingType struct {
	basetypes.ObjectType
}

func (t SwitchingType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchingType) String() string {
	return "SwitchingType"
}

func (t SwitchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchingValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSwitchingValueNull() SwitchingValue {
	return SwitchingValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchingValueUnknown() SwitchingValue {
	return SwitchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchingValue Attribute Value",
				"While creating a SwitchingValue value, a missing attribute value was detected. "+
					"A SwitchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchingValue Attribute Type",
				"While creating a SwitchingValue value, an invalid attribute value was detected. "+
					"A SwitchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchingValue Attribute Value",
				"While creating a SwitchingValue value, an extra attribute value was detected. "+
					"A SwitchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchingValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSwitchingValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewSwitchingValueUnknown(), diags
	}

	return SwitchingValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSwitchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchingValue {
	object, diags := NewSwitchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchingValueMust(SwitchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchingType) ValueType(ctx context.Context) attr.Value {
	return SwitchingValue{}
}

var _ basetypes.ObjectValuable = SwitchingValue{}

type SwitchingValue struct {
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	state attr.ValueState
}

func (v *SwitchingValue) UnmarshalJSON(data []byte) error {
	type JsonSwitchingValue SwitchingValue

	var tmp JsonSwitchingValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SwitchingValue) MergeWith(other *SwitchingValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SwitchingValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name": v.Name,
	}
}
func (v SwitchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchingValue) String() string {
	return "SwitchingValue"
}

func (v SwitchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v SwitchingValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v SwitchingValue) Type(ctx context.Context) attr.Type {
	return SwitchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TrafficType{}

type TrafficType struct {
	basetypes.ObjectType
}

func (t TrafficType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficType) String() string {
	return "TrafficType"
}

func (t TrafficType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inputQuotaSizeAttribute, ok := attributes["input_quota_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_quota_size is missing from object`)

		return nil, diags
	}

	inputQuotaSizeVal, ok := inputQuotaSizeAttribute.(TrafficInputQuotaSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_quota_size expected to be TrafficInputQuotaSizeValue, was: %T`, inputQuotaSizeAttribute))
	}

	inputQuotaUsedAttribute, ok := attributes["input_quota_used"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_quota_used is missing from object`)

		return nil, diags
	}

	inputQuotaUsedVal, ok := inputQuotaUsedAttribute.(TrafficInputQuotaUsedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_quota_used expected to be TrafficInputQuotaUsedValue, was: %T`, inputQuotaUsedAttribute))
	}

	isThrottledAttribute, ok := attributes["is_throttled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_throttled is missing from object`)

		return nil, diags
	}

	isThrottledVal, ok := isThrottledAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_throttled expected to be ovhtypes.TfBoolValue, was: %T`, isThrottledAttribute))
	}

	outputQuotaSizeAttribute, ok := attributes["output_quota_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_quota_size is missing from object`)

		return nil, diags
	}

	outputQuotaSizeVal, ok := outputQuotaSizeAttribute.(TrafficOutputQuotaSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_quota_size expected to be TrafficOutputQuotaSizeValue, was: %T`, outputQuotaSizeAttribute))
	}

	outputQuotaUsedAttribute, ok := attributes["output_quota_used"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_quota_used is missing from object`)

		return nil, diags
	}

	outputQuotaUsedVal, ok := outputQuotaUsedAttribute.(TrafficOutputQuotaUsedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_quota_used expected to be TrafficOutputQuotaUsedValue, was: %T`, outputQuotaUsedAttribute))
	}

	resetQuotaDateAttribute, ok := attributes["reset_quota_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_quota_date is missing from object`)

		return nil, diags
	}

	resetQuotaDateVal, ok := resetQuotaDateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_quota_date expected to be ovhtypes.TfStringValue, was: %T`, resetQuotaDateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficValue{
		InputQuotaSize:  inputQuotaSizeVal,
		InputQuotaUsed:  inputQuotaUsedVal,
		IsThrottled:     isThrottledVal,
		OutputQuotaSize: outputQuotaSizeVal,
		OutputQuotaUsed: outputQuotaUsedVal,
		ResetQuotaDate:  resetQuotaDateVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewTrafficValueNull() TrafficValue {
	return TrafficValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficValueUnknown() TrafficValue {
	return TrafficValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficValue Attribute Value",
				"While creating a TrafficValue value, a missing attribute value was detected. "+
					"A TrafficValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficValue Attribute Type",
				"While creating a TrafficValue value, an invalid attribute value was detected. "+
					"A TrafficValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficValue Attribute Value",
				"While creating a TrafficValue value, an extra attribute value was detected. "+
					"A TrafficValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficValueUnknown(), diags
	}

	inputQuotaSizeAttribute, ok := attributes["input_quota_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_quota_size is missing from object`)

		return NewTrafficValueUnknown(), diags
	}

	inputQuotaSizeVal, ok := inputQuotaSizeAttribute.(TrafficInputQuotaSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_quota_size expected to be TrafficInputQuotaSizeValue, was: %T`, inputQuotaSizeAttribute))
	}

	inputQuotaUsedAttribute, ok := attributes["input_quota_used"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_quota_used is missing from object`)

		return NewTrafficValueUnknown(), diags
	}

	inputQuotaUsedVal, ok := inputQuotaUsedAttribute.(TrafficInputQuotaUsedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_quota_used expected to be TrafficInputQuotaUsedValue, was: %T`, inputQuotaUsedAttribute))
	}

	isThrottledAttribute, ok := attributes["is_throttled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_throttled is missing from object`)

		return NewTrafficValueUnknown(), diags
	}

	isThrottledVal, ok := isThrottledAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_throttled expected to be ovhtypes.TfBoolValue, was: %T`, isThrottledAttribute))
	}

	outputQuotaSizeAttribute, ok := attributes["output_quota_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_quota_size is missing from object`)

		return NewTrafficValueUnknown(), diags
	}

	outputQuotaSizeVal, ok := outputQuotaSizeAttribute.(TrafficOutputQuotaSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_quota_size expected to be TrafficOutputQuotaSizeValue, was: %T`, outputQuotaSizeAttribute))
	}

	outputQuotaUsedAttribute, ok := attributes["output_quota_used"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_quota_used is missing from object`)

		return NewTrafficValueUnknown(), diags
	}

	outputQuotaUsedVal, ok := outputQuotaUsedAttribute.(TrafficOutputQuotaUsedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_quota_used expected to be TrafficOutputQuotaUsedValue, was: %T`, outputQuotaUsedAttribute))
	}

	resetQuotaDateAttribute, ok := attributes["reset_quota_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_quota_date is missing from object`)

		return NewTrafficValueUnknown(), diags
	}

	resetQuotaDateVal, ok := resetQuotaDateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_quota_date expected to be ovhtypes.TfStringValue, was: %T`, resetQuotaDateAttribute))
	}

	if diags.HasError() {
		return NewTrafficValueUnknown(), diags
	}

	return TrafficValue{
		InputQuotaSize:  inputQuotaSizeVal,
		InputQuotaUsed:  inputQuotaUsedVal,
		IsThrottled:     isThrottledVal,
		OutputQuotaSize: outputQuotaSizeVal,
		OutputQuotaUsed: outputQuotaUsedVal,
		ResetQuotaDate:  resetQuotaDateVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewTrafficValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficValue {
	object, diags := NewTrafficValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficValueMust(TrafficValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficType) ValueType(ctx context.Context) attr.Value {
	return TrafficValue{}
}

var _ basetypes.ObjectValuable = TrafficValue{}

type TrafficValue struct {
	InputQuotaSize  TrafficInputQuotaSizeValue  `tfsdk:"input_quota_size" json:"inputQuotaSize"`
	InputQuotaUsed  TrafficInputQuotaUsedValue  `tfsdk:"input_quota_used" json:"inputQuotaUsed"`
	IsThrottled     ovhtypes.TfBoolValue        `tfsdk:"is_throttled" json:"isThrottled"`
	OutputQuotaSize TrafficOutputQuotaSizeValue `tfsdk:"output_quota_size" json:"outputQuotaSize"`
	OutputQuotaUsed TrafficOutputQuotaUsedValue `tfsdk:"output_quota_used" json:"outputQuotaUsed"`
	ResetQuotaDate  ovhtypes.TfStringValue      `tfsdk:"reset_quota_date" json:"resetQuotaDate"`
	state           attr.ValueState
}

func (v *TrafficValue) UnmarshalJSON(data []byte) error {
	type JsonTrafficValue TrafficValue

	var tmp JsonTrafficValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.InputQuotaSize = tmp.InputQuotaSize
	v.InputQuotaUsed = tmp.InputQuotaUsed
	v.IsThrottled = tmp.IsThrottled
	v.OutputQuotaSize = tmp.OutputQuotaSize
	v.OutputQuotaUsed = tmp.OutputQuotaUsed
	v.ResetQuotaDate = tmp.ResetQuotaDate

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TrafficValue) MergeWith(other *TrafficValue) {

	if (v.InputQuotaSize.IsUnknown() || v.InputQuotaSize.IsNull()) && !other.InputQuotaSize.IsUnknown() {
		v.InputQuotaSize = other.InputQuotaSize
	}

	if (v.InputQuotaUsed.IsUnknown() || v.InputQuotaUsed.IsNull()) && !other.InputQuotaUsed.IsUnknown() {
		v.InputQuotaUsed = other.InputQuotaUsed
	}

	if (v.IsThrottled.IsUnknown() || v.IsThrottled.IsNull()) && !other.IsThrottled.IsUnknown() {
		v.IsThrottled = other.IsThrottled
	}

	if (v.OutputQuotaSize.IsUnknown() || v.OutputQuotaSize.IsNull()) && !other.OutputQuotaSize.IsUnknown() {
		v.OutputQuotaSize = other.OutputQuotaSize
	}

	if (v.OutputQuotaUsed.IsUnknown() || v.OutputQuotaUsed.IsNull()) && !other.OutputQuotaUsed.IsUnknown() {
		v.OutputQuotaUsed = other.OutputQuotaUsed
	}

	if (v.ResetQuotaDate.IsUnknown() || v.ResetQuotaDate.IsNull()) && !other.ResetQuotaDate.IsUnknown() {
		v.ResetQuotaDate = other.ResetQuotaDate
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TrafficValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"inputQuotaSize":  v.InputQuotaSize,
		"inputQuotaUsed":  v.InputQuotaUsed,
		"isThrottled":     v.IsThrottled,
		"outputQuotaSize": v.OutputQuotaSize,
		"outputQuotaUsed": v.OutputQuotaUsed,
		"resetQuotaDate":  v.ResetQuotaDate,
	}
}
func (v TrafficValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["input_quota_size"] = basetypes.ObjectType{
		AttrTypes: TrafficInputQuotaSizeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["input_quota_used"] = basetypes.ObjectType{
		AttrTypes: TrafficInputQuotaUsedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["is_throttled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["output_quota_size"] = basetypes.ObjectType{
		AttrTypes: TrafficOutputQuotaSizeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["output_quota_used"] = basetypes.ObjectType{
		AttrTypes: TrafficOutputQuotaUsedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["reset_quota_date"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.InputQuotaSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_quota_size"] = val

		val, err = v.InputQuotaUsed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_quota_used"] = val

		val, err = v.IsThrottled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_throttled"] = val

		val, err = v.OutputQuotaSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_quota_size"] = val

		val, err = v.OutputQuotaUsed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_quota_used"] = val

		val, err = v.ResetQuotaDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reset_quota_date"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficValue) String() string {
	return "TrafficValue"
}

func (v TrafficValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"input_quota_size": TrafficInputQuotaSizeType{
				basetypes.ObjectType{
					AttrTypes: TrafficInputQuotaSizeValue{}.AttributeTypes(ctx),
				},
			},
			"input_quota_used": TrafficInputQuotaUsedType{
				basetypes.ObjectType{
					AttrTypes: TrafficInputQuotaUsedValue{}.AttributeTypes(ctx),
				},
			},
			"is_throttled": ovhtypes.TfBoolType{},
			"output_quota_size": TrafficOutputQuotaSizeType{
				basetypes.ObjectType{
					AttrTypes: TrafficOutputQuotaSizeValue{}.AttributeTypes(ctx),
				},
			},
			"output_quota_used": TrafficOutputQuotaUsedType{
				basetypes.ObjectType{
					AttrTypes: TrafficOutputQuotaUsedValue{}.AttributeTypes(ctx),
				},
			},
			"reset_quota_date": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"input_quota_size":  v.InputQuotaSize,
			"input_quota_used":  v.InputQuotaUsed,
			"is_throttled":      v.IsThrottled,
			"output_quota_size": v.OutputQuotaSize,
			"output_quota_used": v.OutputQuotaUsed,
			"reset_quota_date":  v.ResetQuotaDate,
		})

	return objVal, diags
}

func (v TrafficValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InputQuotaSize.Equal(other.InputQuotaSize) {
		return false
	}

	if !v.InputQuotaUsed.Equal(other.InputQuotaUsed) {
		return false
	}

	if !v.IsThrottled.Equal(other.IsThrottled) {
		return false
	}

	if !v.OutputQuotaSize.Equal(other.OutputQuotaSize) {
		return false
	}

	if !v.OutputQuotaUsed.Equal(other.OutputQuotaUsed) {
		return false
	}

	if !v.ResetQuotaDate.Equal(other.ResetQuotaDate) {
		return false
	}

	return true
}

func (v TrafficValue) Type(ctx context.Context) attr.Type {
	return TrafficType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"input_quota_size":  TrafficInputQuotaSizeValue{}.Type(ctx),
		"input_quota_used":  TrafficInputQuotaUsedValue{}.Type(ctx),
		"is_throttled":      ovhtypes.TfBoolType{},
		"output_quota_size": TrafficOutputQuotaSizeValue{}.Type(ctx),
		"output_quota_used": TrafficOutputQuotaUsedValue{}.Type(ctx),
		"reset_quota_date":  ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TrafficInputQuotaSizeType{}

type TrafficInputQuotaSizeType struct {
	basetypes.ObjectType
}

func (t TrafficInputQuotaSizeType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficInputQuotaSizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficInputQuotaSizeType) String() string {
	return "TrafficInputQuotaSizeType"
}

func (t TrafficInputQuotaSizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficInputQuotaSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficInputQuotaSizeValueNull() TrafficInputQuotaSizeValue {
	return TrafficInputQuotaSizeValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficInputQuotaSizeValueUnknown() TrafficInputQuotaSizeValue {
	return TrafficInputQuotaSizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficInputQuotaSizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficInputQuotaSizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficInputQuotaSizeValue Attribute Value",
				"While creating a TrafficInputQuotaSizeValue value, a missing attribute value was detected. "+
					"A TrafficInputQuotaSizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficInputQuotaSizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficInputQuotaSizeValue Attribute Type",
				"While creating a TrafficInputQuotaSizeValue value, an invalid attribute value was detected. "+
					"A TrafficInputQuotaSizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficInputQuotaSizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficInputQuotaSizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficInputQuotaSizeValue Attribute Value",
				"While creating a TrafficInputQuotaSizeValue value, an extra attribute value was detected. "+
					"A TrafficInputQuotaSizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficInputQuotaSizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficInputQuotaSizeValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewTrafficInputQuotaSizeValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTrafficInputQuotaSizeValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTrafficInputQuotaSizeValueUnknown(), diags
	}

	return TrafficInputQuotaSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficInputQuotaSizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficInputQuotaSizeValue {
	object, diags := NewTrafficInputQuotaSizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficInputQuotaSizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficInputQuotaSizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficInputQuotaSizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficInputQuotaSizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficInputQuotaSizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficInputQuotaSizeValueMust(TrafficInputQuotaSizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficInputQuotaSizeType) ValueType(ctx context.Context) attr.Value {
	return TrafficInputQuotaSizeValue{}
}

var _ basetypes.ObjectValuable = TrafficInputQuotaSizeValue{}

type TrafficInputQuotaSizeValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *TrafficInputQuotaSizeValue) UnmarshalJSON(data []byte) error {
	type JsonTrafficInputQuotaSizeValue TrafficInputQuotaSizeValue

	var tmp JsonTrafficInputQuotaSizeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TrafficInputQuotaSizeValue) MergeWith(other *TrafficInputQuotaSizeValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TrafficInputQuotaSizeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v TrafficInputQuotaSizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficInputQuotaSizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficInputQuotaSizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficInputQuotaSizeValue) String() string {
	return "TrafficInputQuotaSizeValue"
}

func (v TrafficInputQuotaSizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TrafficInputQuotaSizeValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficInputQuotaSizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TrafficInputQuotaSizeValue) Type(ctx context.Context) attr.Type {
	return TrafficInputQuotaSizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficInputQuotaSizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = TrafficInputQuotaUsedType{}

type TrafficInputQuotaUsedType struct {
	basetypes.ObjectType
}

func (t TrafficInputQuotaUsedType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficInputQuotaUsedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficInputQuotaUsedType) String() string {
	return "TrafficInputQuotaUsedType"
}

func (t TrafficInputQuotaUsedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficInputQuotaUsedValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficInputQuotaUsedValueNull() TrafficInputQuotaUsedValue {
	return TrafficInputQuotaUsedValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficInputQuotaUsedValueUnknown() TrafficInputQuotaUsedValue {
	return TrafficInputQuotaUsedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficInputQuotaUsedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficInputQuotaUsedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficInputQuotaUsedValue Attribute Value",
				"While creating a TrafficInputQuotaUsedValue value, a missing attribute value was detected. "+
					"A TrafficInputQuotaUsedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficInputQuotaUsedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficInputQuotaUsedValue Attribute Type",
				"While creating a TrafficInputQuotaUsedValue value, an invalid attribute value was detected. "+
					"A TrafficInputQuotaUsedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficInputQuotaUsedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficInputQuotaUsedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficInputQuotaUsedValue Attribute Value",
				"While creating a TrafficInputQuotaUsedValue value, an extra attribute value was detected. "+
					"A TrafficInputQuotaUsedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficInputQuotaUsedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficInputQuotaUsedValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewTrafficInputQuotaUsedValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTrafficInputQuotaUsedValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTrafficInputQuotaUsedValueUnknown(), diags
	}

	return TrafficInputQuotaUsedValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficInputQuotaUsedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficInputQuotaUsedValue {
	object, diags := NewTrafficInputQuotaUsedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficInputQuotaUsedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficInputQuotaUsedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficInputQuotaUsedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficInputQuotaUsedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficInputQuotaUsedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficInputQuotaUsedValueMust(TrafficInputQuotaUsedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficInputQuotaUsedType) ValueType(ctx context.Context) attr.Value {
	return TrafficInputQuotaUsedValue{}
}

var _ basetypes.ObjectValuable = TrafficInputQuotaUsedValue{}

type TrafficInputQuotaUsedValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *TrafficInputQuotaUsedValue) UnmarshalJSON(data []byte) error {
	type JsonTrafficInputQuotaUsedValue TrafficInputQuotaUsedValue

	var tmp JsonTrafficInputQuotaUsedValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TrafficInputQuotaUsedValue) MergeWith(other *TrafficInputQuotaUsedValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TrafficInputQuotaUsedValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v TrafficInputQuotaUsedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficInputQuotaUsedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficInputQuotaUsedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficInputQuotaUsedValue) String() string {
	return "TrafficInputQuotaUsedValue"
}

func (v TrafficInputQuotaUsedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TrafficInputQuotaUsedValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficInputQuotaUsedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TrafficInputQuotaUsedValue) Type(ctx context.Context) attr.Type {
	return TrafficInputQuotaUsedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficInputQuotaUsedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = TrafficOutputQuotaSizeType{}

type TrafficOutputQuotaSizeType struct {
	basetypes.ObjectType
}

func (t TrafficOutputQuotaSizeType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficOutputQuotaSizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficOutputQuotaSizeType) String() string {
	return "TrafficOutputQuotaSizeType"
}

func (t TrafficOutputQuotaSizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficOutputQuotaSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficOutputQuotaSizeValueNull() TrafficOutputQuotaSizeValue {
	return TrafficOutputQuotaSizeValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficOutputQuotaSizeValueUnknown() TrafficOutputQuotaSizeValue {
	return TrafficOutputQuotaSizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficOutputQuotaSizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficOutputQuotaSizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficOutputQuotaSizeValue Attribute Value",
				"While creating a TrafficOutputQuotaSizeValue value, a missing attribute value was detected. "+
					"A TrafficOutputQuotaSizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficOutputQuotaSizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficOutputQuotaSizeValue Attribute Type",
				"While creating a TrafficOutputQuotaSizeValue value, an invalid attribute value was detected. "+
					"A TrafficOutputQuotaSizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficOutputQuotaSizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficOutputQuotaSizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficOutputQuotaSizeValue Attribute Value",
				"While creating a TrafficOutputQuotaSizeValue value, an extra attribute value was detected. "+
					"A TrafficOutputQuotaSizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficOutputQuotaSizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficOutputQuotaSizeValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewTrafficOutputQuotaSizeValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTrafficOutputQuotaSizeValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTrafficOutputQuotaSizeValueUnknown(), diags
	}

	return TrafficOutputQuotaSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficOutputQuotaSizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficOutputQuotaSizeValue {
	object, diags := NewTrafficOutputQuotaSizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficOutputQuotaSizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficOutputQuotaSizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficOutputQuotaSizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficOutputQuotaSizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficOutputQuotaSizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficOutputQuotaSizeValueMust(TrafficOutputQuotaSizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficOutputQuotaSizeType) ValueType(ctx context.Context) attr.Value {
	return TrafficOutputQuotaSizeValue{}
}

var _ basetypes.ObjectValuable = TrafficOutputQuotaSizeValue{}

type TrafficOutputQuotaSizeValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *TrafficOutputQuotaSizeValue) UnmarshalJSON(data []byte) error {
	type JsonTrafficOutputQuotaSizeValue TrafficOutputQuotaSizeValue

	var tmp JsonTrafficOutputQuotaSizeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TrafficOutputQuotaSizeValue) MergeWith(other *TrafficOutputQuotaSizeValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TrafficOutputQuotaSizeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v TrafficOutputQuotaSizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficOutputQuotaSizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficOutputQuotaSizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficOutputQuotaSizeValue) String() string {
	return "TrafficOutputQuotaSizeValue"
}

func (v TrafficOutputQuotaSizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TrafficOutputQuotaSizeValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficOutputQuotaSizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TrafficOutputQuotaSizeValue) Type(ctx context.Context) attr.Type {
	return TrafficOutputQuotaSizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficOutputQuotaSizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = TrafficOutputQuotaUsedType{}

type TrafficOutputQuotaUsedType struct {
	basetypes.ObjectType
}

func (t TrafficOutputQuotaUsedType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficOutputQuotaUsedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficOutputQuotaUsedType) String() string {
	return "TrafficOutputQuotaUsedType"
}

func (t TrafficOutputQuotaUsedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficOutputQuotaUsedValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficOutputQuotaUsedValueNull() TrafficOutputQuotaUsedValue {
	return TrafficOutputQuotaUsedValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficOutputQuotaUsedValueUnknown() TrafficOutputQuotaUsedValue {
	return TrafficOutputQuotaUsedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficOutputQuotaUsedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficOutputQuotaUsedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficOutputQuotaUsedValue Attribute Value",
				"While creating a TrafficOutputQuotaUsedValue value, a missing attribute value was detected. "+
					"A TrafficOutputQuotaUsedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficOutputQuotaUsedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficOutputQuotaUsedValue Attribute Type",
				"While creating a TrafficOutputQuotaUsedValue value, an invalid attribute value was detected. "+
					"A TrafficOutputQuotaUsedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficOutputQuotaUsedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficOutputQuotaUsedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficOutputQuotaUsedValue Attribute Value",
				"While creating a TrafficOutputQuotaUsedValue value, an extra attribute value was detected. "+
					"A TrafficOutputQuotaUsedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficOutputQuotaUsedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficOutputQuotaUsedValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewTrafficOutputQuotaUsedValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTrafficOutputQuotaUsedValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTrafficOutputQuotaUsedValueUnknown(), diags
	}

	return TrafficOutputQuotaUsedValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTrafficOutputQuotaUsedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficOutputQuotaUsedValue {
	object, diags := NewTrafficOutputQuotaUsedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficOutputQuotaUsedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficOutputQuotaUsedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficOutputQuotaUsedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficOutputQuotaUsedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficOutputQuotaUsedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficOutputQuotaUsedValueMust(TrafficOutputQuotaUsedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficOutputQuotaUsedType) ValueType(ctx context.Context) attr.Value {
	return TrafficOutputQuotaUsedValue{}
}

var _ basetypes.ObjectValuable = TrafficOutputQuotaUsedValue{}

type TrafficOutputQuotaUsedValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *TrafficOutputQuotaUsedValue) UnmarshalJSON(data []byte) error {
	type JsonTrafficOutputQuotaUsedValue TrafficOutputQuotaUsedValue

	var tmp JsonTrafficOutputQuotaUsedValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TrafficOutputQuotaUsedValue) MergeWith(other *TrafficOutputQuotaUsedValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TrafficOutputQuotaUsedValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v TrafficOutputQuotaUsedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficOutputQuotaUsedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficOutputQuotaUsedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficOutputQuotaUsedValue) String() string {
	return "TrafficOutputQuotaUsedValue"
}

func (v TrafficOutputQuotaUsedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TrafficOutputQuotaUsedValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficOutputQuotaUsedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TrafficOutputQuotaUsedValue) Type(ctx context.Context) attr.Type {
	return TrafficOutputQuotaUsedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficOutputQuotaUsedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = VmacType{}

type VmacType struct {
	basetypes.ObjectType
}

func (t VmacType) Equal(o attr.Type) bool {
	other, ok := o.(VmacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VmacType) String() string {
	return "VmacType"
}

func (t VmacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	supportedAttribute, ok := attributes["supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supported is missing from object`)

		return nil, diags
	}

	supportedVal, ok := supportedAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supported expected to be ovhtypes.TfBoolValue, was: %T`, supportedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VmacValue{
		Supported: supportedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVmacValueNull() VmacValue {
	return VmacValue{
		state: attr.ValueStateNull,
	}
}

func NewVmacValueUnknown() VmacValue {
	return VmacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVmacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VmacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VmacValue Attribute Value",
				"While creating a VmacValue value, a missing attribute value was detected. "+
					"A VmacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VmacValue Attribute Type",
				"While creating a VmacValue value, an invalid attribute value was detected. "+
					"A VmacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VmacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VmacValue Attribute Value",
				"While creating a VmacValue value, an extra attribute value was detected. "+
					"A VmacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VmacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVmacValueUnknown(), diags
	}

	supportedAttribute, ok := attributes["supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supported is missing from object`)

		return NewVmacValueUnknown(), diags
	}

	supportedVal, ok := supportedAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supported expected to be ovhtypes.TfBoolValue, was: %T`, supportedAttribute))
	}

	if diags.HasError() {
		return NewVmacValueUnknown(), diags
	}

	return VmacValue{
		Supported: supportedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVmacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VmacValue {
	object, diags := NewVmacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVmacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VmacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVmacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVmacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVmacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVmacValueMust(VmacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VmacType) ValueType(ctx context.Context) attr.Value {
	return VmacValue{}
}

var _ basetypes.ObjectValuable = VmacValue{}

type VmacValue struct {
	Supported ovhtypes.TfBoolValue `tfsdk:"supported" json:"supported"`
	state     attr.ValueState
}

func (v *VmacValue) UnmarshalJSON(data []byte) error {
	type JsonVmacValue VmacValue

	var tmp JsonVmacValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Supported = tmp.Supported

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VmacValue) MergeWith(other *VmacValue) {

	if (v.Supported.IsUnknown() || v.Supported.IsNull()) && !other.Supported.IsUnknown() {
		v.Supported = other.Supported
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VmacValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"supported": v.Supported,
	}
}
func (v VmacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["supported"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Supported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["supported"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VmacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VmacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VmacValue) String() string {
	return "VmacValue"
}

func (v VmacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"supported": ovhtypes.TfBoolType{},
		},
		map[string]attr.Value{
			"supported": v.Supported,
		})

	return objVal, diags
}

func (v VmacValue) Equal(o attr.Value) bool {
	other, ok := o.(VmacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Supported.Equal(other.Supported) {
		return false
	}

	return true
}

func (v VmacValue) Type(ctx context.Context) attr.Type {
	return VmacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VmacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"supported": ovhtypes.TfBoolType{},
	}
}

var _ basetypes.ObjectTypable = VrackType{}

type VrackType struct {
	basetypes.ObjectType
}

func (t VrackType) Equal(o attr.Type) bool {
	other, ok := o.(VrackType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackType) String() string {
	return "VrackType"
}

func (t VrackType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(VrackBandwidthValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be VrackBandwidthValue, was: %T`, bandwidthAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackValue{
		Bandwidth: bandwidthVal,
		VrackType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVrackValueNull() VrackValue {
	return VrackValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackValueUnknown() VrackValue {
	return VrackValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackValue Attribute Value",
				"While creating a VrackValue value, a missing attribute value was detected. "+
					"A VrackValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackValue Attribute Type",
				"While creating a VrackValue value, an invalid attribute value was detected. "+
					"A VrackValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackValue Attribute Value",
				"While creating a VrackValue value, an extra attribute value was detected. "+
					"A VrackValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackValueUnknown(), diags
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewVrackValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(VrackBandwidthValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be VrackBandwidthValue, was: %T`, bandwidthAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVrackValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewVrackValueUnknown(), diags
	}

	return VrackValue{
		Bandwidth: bandwidthVal,
		VrackType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVrackValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackValue {
	object, diags := NewVrackValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackValueMust(VrackValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackType) ValueType(ctx context.Context) attr.Value {
	return VrackValue{}
}

var _ basetypes.ObjectValuable = VrackValue{}

type VrackValue struct {
	Bandwidth VrackBandwidthValue    `tfsdk:"bandwidth" json:"bandwidth"`
	VrackType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state     attr.ValueState
}

func (v *VrackValue) UnmarshalJSON(data []byte) error {
	type JsonVrackValue VrackValue

	var tmp JsonVrackValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Bandwidth = tmp.Bandwidth
	v.VrackType = tmp.VrackType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackValue) MergeWith(other *VrackValue) {

	if (v.Bandwidth.IsUnknown() || v.Bandwidth.IsNull()) && !other.Bandwidth.IsUnknown() {
		v.Bandwidth = other.Bandwidth
	}

	if (v.VrackType.IsUnknown() || v.VrackType.IsNull()) && !other.VrackType.IsUnknown() {
		v.VrackType = other.VrackType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"bandwidth": v.Bandwidth,
		"type":      v.VrackType,
	}
}
func (v VrackValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bandwidth"] = basetypes.ObjectType{
		AttrTypes: VrackBandwidthValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.VrackType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackValue) String() string {
	return "VrackValue"
}

func (v VrackValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bandwidth": VrackBandwidthType{
				basetypes.ObjectType{
					AttrTypes: VrackBandwidthValue{}.AttributeTypes(ctx),
				},
			},
			"type": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"bandwidth": v.Bandwidth,
			"type":      v.VrackType,
		})

	return objVal, diags
}

func (v VrackValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.VrackType.Equal(other.VrackType) {
		return false
	}

	return true
}

func (v VrackValue) Type(ctx context.Context) attr.Type {
	return VrackType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bandwidth": VrackBandwidthValue{}.Type(ctx),
		"type":      ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VrackBandwidthType{}

type VrackBandwidthType struct {
	basetypes.ObjectType
}

func (t VrackBandwidthType) Equal(o attr.Type) bool {
	other, ok := o.(VrackBandwidthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrackBandwidthType) String() string {
	return "VrackBandwidthType"
}

func (t VrackBandwidthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrackBandwidthValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrackBandwidthValueNull() VrackBandwidthValue {
	return VrackBandwidthValue{
		state: attr.ValueStateNull,
	}
}

func NewVrackBandwidthValueUnknown() VrackBandwidthValue {
	return VrackBandwidthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrackBandwidthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrackBandwidthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrackBandwidthValue Attribute Value",
				"While creating a VrackBandwidthValue value, a missing attribute value was detected. "+
					"A VrackBandwidthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackBandwidthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrackBandwidthValue Attribute Type",
				"While creating a VrackBandwidthValue value, an invalid attribute value was detected. "+
					"A VrackBandwidthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrackBandwidthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrackBandwidthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrackBandwidthValue Attribute Value",
				"While creating a VrackBandwidthValue value, an extra attribute value was detected. "+
					"A VrackBandwidthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrackBandwidthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrackBandwidthValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewVrackBandwidthValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewVrackBandwidthValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewVrackBandwidthValueUnknown(), diags
	}

	return VrackBandwidthValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrackBandwidthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrackBandwidthValue {
	object, diags := NewVrackBandwidthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrackBandwidthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrackBandwidthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrackBandwidthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrackBandwidthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrackBandwidthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrackBandwidthValueMust(VrackBandwidthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrackBandwidthType) ValueType(ctx context.Context) attr.Value {
	return VrackBandwidthValue{}
}

var _ basetypes.ObjectValuable = VrackBandwidthValue{}

type VrackBandwidthValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *VrackBandwidthValue) UnmarshalJSON(data []byte) error {
	type JsonVrackBandwidthValue VrackBandwidthValue

	var tmp JsonVrackBandwidthValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VrackBandwidthValue) MergeWith(other *VrackBandwidthValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VrackBandwidthValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v VrackBandwidthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrackBandwidthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrackBandwidthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrackBandwidthValue) String() string {
	return "VrackBandwidthValue"
}

func (v VrackBandwidthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v VrackBandwidthValue) Equal(o attr.Value) bool {
	other, ok := o.(VrackBandwidthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v VrackBandwidthValue) Type(ctx context.Context) attr.Type {
	return VrackBandwidthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrackBandwidthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}
