// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CloudProjectRegionStorageResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"created_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "The date and timestamp when the resource was created",
			MarkdownDescription: "The date and timestamp when the resource was created",
		},
		"encryption": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"sse_algorithm": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Encryption algorithm",
					MarkdownDescription: "Encryption algorithm",
					Validators: []validator.String{
						stringvalidator.OneOf(
							"AES256",
							"plaintext",
						),
					},
				},
			},
			CustomType: EncryptionType{
				ObjectType: types.ObjectType{
					AttrTypes: EncryptionValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "Encryption configuration",
			MarkdownDescription: "Encryption configuration",
		},
		"limit": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Computed:            true,
			Description:         "Limit the number of objects returned (1000 maximum, defaults to 1000)",
			MarkdownDescription: "Limit the number of objects returned (1000 maximum, defaults to 1000)",
		},
		"marker": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Key to start with when listing objects",
			MarkdownDescription: "Key to start with when listing objects",
		},
		"name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Container name",
			MarkdownDescription: "Container name",
		},
		"objects": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"etag": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "ETag",
						MarkdownDescription: "ETag",
					},
					"is_delete_marker": schema.BoolAttribute{
						CustomType:          ovhtypes.TfBoolType{},
						Computed:            true,
						Description:         "Whether this object is a delete marker",
						MarkdownDescription: "Whether this object is a delete marker",
					},
					"is_latest": schema.BoolAttribute{
						CustomType:          ovhtypes.TfBoolType{},
						Computed:            true,
						Description:         "Whether this is the latest version of the object",
						MarkdownDescription: "Whether this is the latest version of the object",
					},
					"key": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Key",
						MarkdownDescription: "Key",
					},
					"last_modified": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Last modification date",
						MarkdownDescription: "Last modification date",
					},
					"size": schema.Int64Attribute{
						CustomType:          ovhtypes.TfInt64Type{},
						Computed:            true,
						Description:         "Size (bytes)",
						MarkdownDescription: "Size (bytes)",
					},
					"storage_class": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Storage class",
						MarkdownDescription: "Storage class",
					},
					"version_id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Version ID of the object",
						MarkdownDescription: "Version ID of the object",
					},
				},
				CustomType: ObjectsType{
					ObjectType: types.ObjectType{
						AttrTypes: ObjectsValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[ObjectsValue](ctx),
			Computed:            true,
			Description:         "Container objects",
			MarkdownDescription: "Container objects",
		},
		"objects_count": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Computed:            true,
			Description:         "Container total objects count",
			MarkdownDescription: "Container total objects count",
		},
		"objects_size": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Computed:            true,
			Description:         "Container total objects size (bytes)",
			MarkdownDescription: "Container total objects size (bytes)",
		},
		"owner_id": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Computed:            true,
			Description:         "Container owner user ID",
			MarkdownDescription: "Container owner user ID",
		},
		"prefix": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "List objects whose key begins with this prefix",
			MarkdownDescription: "List objects whose key begins with this prefix",
		},
		"region": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Container region",
			MarkdownDescription: "Container region",
		},
		"region_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Region name",
			MarkdownDescription: "Region name",
		},
		"replication": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"rules": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"delete_marker_replication": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Delete marker replication",
								MarkdownDescription: "Delete marker replication",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"disabled",
										"enabled",
									),
								},
							},
							"destination": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Destination bucket name",
										MarkdownDescription: "Destination bucket name",
									},
									"region": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Destination region",
										MarkdownDescription: "Destination region",
									},
									"storage_class": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Destination storage class",
										MarkdownDescription: "Destination storage class",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"HIGH_PERF",
												"STANDARD",
												"STANDARD_IA",
											),
										},
									},
								},
								CustomType: ReplicationRulesDestinationType{
									ObjectType: types.ObjectType{
										AttrTypes: ReplicationRulesDestinationValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Rule destination configuration",
								MarkdownDescription: "Rule destination configuration",
							},
							"filter": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"prefix": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Prefix filter",
										MarkdownDescription: "Prefix filter",
									},
									"tags": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"key": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Required:            true,
													Description:         "Tag key",
													MarkdownDescription: "Tag key",
												},
												"value": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Required:            true,
													Description:         "Tag value",
													MarkdownDescription: "Tag value",
												},
											},
											CustomType: ReplicationRulesFilterTagsType{
												ObjectType: types.ObjectType{
													AttrTypes: ReplicationRulesFilterTagsValue{}.AttributeTypes(ctx),
												},
											},
										},
										CustomType:          ovhtypes.NewTfListNestedType[ReplicationRulesFilterTagsValue](ctx),
										Optional:            true,
										Computed:            true,
										Description:         "Tags filter",
										MarkdownDescription: "Tags filter",
									},
								},
								CustomType: ReplicationRulesFilterType{
									ObjectType: types.ObjectType{
										AttrTypes: ReplicationRulesFilterValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Rule filters",
								MarkdownDescription: "Rule filters",
							},
							"id": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Rule ID",
								MarkdownDescription: "Rule ID",
							},
							"priority": schema.Int64Attribute{
								CustomType:          ovhtypes.TfInt64Type{},
								Optional:            true,
								Computed:            true,
								Description:         "Rule priority",
								MarkdownDescription: "Rule priority",
							},
							"status": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Rule status",
								MarkdownDescription: "Rule status",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"disabled",
										"enabled",
									),
								},
							},
						},
						CustomType: ReplicationRulesType{
							ObjectType: types.ObjectType{
								AttrTypes: ReplicationRulesValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[ReplicationRulesValue](ctx),
					Optional:            true,
					Computed:            true,
					Description:         "Replication rules",
					MarkdownDescription: "Replication rules",
				},
			},
			CustomType: ReplicationType{
				ObjectType: types.ObjectType{
					AttrTypes: ReplicationValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "Replication configuration",
			MarkdownDescription: "Replication configuration",
		},
		"service_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Service name",
			MarkdownDescription: "Service name",
		},
		"versioning": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"status": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Versioning status",
					MarkdownDescription: "Versioning status",
					Validators: []validator.String{
						stringvalidator.OneOf(
							"disabled",
							"enabled",
							"suspended",
						),
					},
				},
			},
			CustomType: VersioningType{
				ObjectType: types.ObjectType{
					AttrTypes: VersioningValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "Versioning configuration",
			MarkdownDescription: "Versioning configuration",
		},
		"virtual_host": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Container virtual host",
			MarkdownDescription: "Container virtual host",
		},
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type CloudProjectRegionStorageModel struct {
	CreatedAt    ovhtypes.TfStringValue                   `tfsdk:"created_at" json:"createdAt"`
	Encryption   EncryptionValue                          `tfsdk:"encryption" json:"encryption"`
	Limit        ovhtypes.TfInt64Value                    `tfsdk:"limit" json:"limit"`
	Marker       ovhtypes.TfStringValue                   `tfsdk:"marker" json:"marker"`
	Name         ovhtypes.TfStringValue                   `tfsdk:"name" json:"name"`
	Objects      ovhtypes.TfListNestedValue[ObjectsValue] `tfsdk:"objects" json:"objects"`
	ObjectsCount ovhtypes.TfInt64Value                    `tfsdk:"objects_count" json:"objectsCount"`
	ObjectsSize  ovhtypes.TfInt64Value                    `tfsdk:"objects_size" json:"objectsSize"`
	OwnerId      ovhtypes.TfInt64Value                    `tfsdk:"owner_id" json:"ownerId"`
	Prefix       ovhtypes.TfStringValue                   `tfsdk:"prefix" json:"prefix"`
	Region       ovhtypes.TfStringValue                   `tfsdk:"region" json:"region"`
	RegionName   ovhtypes.TfStringValue                   `tfsdk:"region_name" json:"regionName"`
	Replication  ReplicationValue                         `tfsdk:"replication" json:"replication"`
	ServiceName  ovhtypes.TfStringValue                   `tfsdk:"service_name" json:"serviceName"`
	Versioning   VersioningValue                          `tfsdk:"versioning" json:"versioning"`
	VirtualHost  ovhtypes.TfStringValue                   `tfsdk:"virtual_host" json:"virtualHost"`
}

func (v *CloudProjectRegionStorageModel) MergeWith(other *CloudProjectRegionStorageModel) {

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if v.Encryption.IsUnknown() && !other.Encryption.IsUnknown() {
		v.Encryption = other.Encryption
	} else if !other.Encryption.IsUnknown() {
		v.Encryption.MergeWith(&other.Encryption)
	}

	if (v.Limit.IsUnknown() || v.Limit.IsNull()) && !other.Limit.IsUnknown() {
		v.Limit = other.Limit
	}

	if (v.Marker.IsUnknown() || v.Marker.IsNull()) && !other.Marker.IsUnknown() {
		v.Marker = other.Marker
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Objects.IsUnknown() || v.Objects.IsNull()) && !other.Objects.IsUnknown() {
		v.Objects = other.Objects
	} else if !other.Objects.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Objects.Elements()
		newElems := other.Objects.Elements()

		if len(elems) != len(newElems) {
			v.Objects = other.Objects
		} else {
			for idx, e := range elems {
				tmp := e.(ObjectsValue)
				tmp2 := newElems[idx].(ObjectsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Objects = ovhtypes.TfListNestedValue[ObjectsValue]{
				ListValue: basetypes.NewListValueMust(ObjectsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.ObjectsCount.IsUnknown() || v.ObjectsCount.IsNull()) && !other.ObjectsCount.IsUnknown() {
		v.ObjectsCount = other.ObjectsCount
	}

	if (v.ObjectsSize.IsUnknown() || v.ObjectsSize.IsNull()) && !other.ObjectsSize.IsUnknown() {
		v.ObjectsSize = other.ObjectsSize
	}

	if (v.OwnerId.IsUnknown() || v.OwnerId.IsNull()) && !other.OwnerId.IsUnknown() {
		v.OwnerId = other.OwnerId
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.RegionName.IsUnknown() || v.RegionName.IsNull()) && !other.RegionName.IsUnknown() {
		v.RegionName = other.RegionName
	}

	if v.Replication.IsUnknown() && !other.Replication.IsUnknown() {
		v.Replication = other.Replication
	} else if !other.Replication.IsUnknown() {
		v.Replication.MergeWith(&other.Replication)
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

	if v.Versioning.IsUnknown() && !other.Versioning.IsUnknown() {
		v.Versioning = other.Versioning
	} else if !other.Versioning.IsUnknown() {
		v.Versioning.MergeWith(&other.Versioning)
	}

	if (v.VirtualHost.IsUnknown() || v.VirtualHost.IsNull()) && !other.VirtualHost.IsUnknown() {
		v.VirtualHost = other.VirtualHost
	}

}

type CloudProjectRegionStorageWritableModel struct {
	Encryption  *EncryptionWritableValue  `tfsdk:"encryption" json:"encryption,omitempty"`
	Name        *ovhtypes.TfStringValue   `tfsdk:"name" json:"name,omitempty"`
	OwnerId     *ovhtypes.TfInt64Value    `tfsdk:"owner_id" json:"ownerId,omitempty"`
	Replication *ReplicationWritableValue `tfsdk:"replication" json:"replication,omitempty"`
	Versioning  *VersioningWritableValue  `tfsdk:"versioning" json:"versioning,omitempty"`
}

func (v CloudProjectRegionStorageModel) ToCreate() *CloudProjectRegionStorageWritableModel {
	res := &CloudProjectRegionStorageWritableModel{}

	if !v.Encryption.IsUnknown() {
		res.Encryption = v.Encryption.ToCreate()
	}

	if !v.Name.IsUnknown() {
		res.Name = &v.Name
	}

	if !v.OwnerId.IsUnknown() {
		res.OwnerId = &v.OwnerId
	}

	if !v.Replication.IsUnknown() {
		res.Replication = v.Replication.ToCreate()
	}

	if !v.Versioning.IsUnknown() {
		res.Versioning = v.Versioning.ToCreate()
	}

	return res
}

func (v CloudProjectRegionStorageModel) ToUpdate() *CloudProjectRegionStorageWritableModel {
	res := &CloudProjectRegionStorageWritableModel{}

	if !v.Encryption.IsUnknown() {
		res.Encryption = v.Encryption.ToUpdate()
	}

	if !v.Replication.IsUnknown() {
		res.Replication = v.Replication.ToUpdate()
	}

	if !v.Versioning.IsUnknown() {
		res.Versioning = v.Versioning.ToUpdate()
	}

	return res
}

var _ basetypes.ObjectTypable = EncryptionType{}

type EncryptionType struct {
	basetypes.ObjectType
}

func (t EncryptionType) Equal(o attr.Type) bool {
	other, ok := o.(EncryptionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EncryptionType) String() string {
	return "EncryptionType"
}

func (t EncryptionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	sseAlgorithmAttribute, ok := attributes["sse_algorithm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sse_algorithm is missing from object`)

		return nil, diags
	}

	sseAlgorithmVal, ok := sseAlgorithmAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sse_algorithm expected to be ovhtypes.TfStringValue, was: %T`, sseAlgorithmAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EncryptionValue{
		SseAlgorithm: sseAlgorithmVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEncryptionValueNull() EncryptionValue {
	return EncryptionValue{
		state: attr.ValueStateNull,
	}
}

func NewEncryptionValueUnknown() EncryptionValue {
	return EncryptionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEncryptionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EncryptionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EncryptionValue Attribute Value",
				"While creating a EncryptionValue value, a missing attribute value was detected. "+
					"A EncryptionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EncryptionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EncryptionValue Attribute Type",
				"While creating a EncryptionValue value, an invalid attribute value was detected. "+
					"A EncryptionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EncryptionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EncryptionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EncryptionValue Attribute Value",
				"While creating a EncryptionValue value, an extra attribute value was detected. "+
					"A EncryptionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EncryptionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEncryptionValueUnknown(), diags
	}

	sseAlgorithmAttribute, ok := attributes["sse_algorithm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sse_algorithm is missing from object`)

		return NewEncryptionValueUnknown(), diags
	}

	sseAlgorithmVal, ok := sseAlgorithmAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sse_algorithm expected to be ovhtypes.TfStringValue, was: %T`, sseAlgorithmAttribute))
	}

	if diags.HasError() {
		return NewEncryptionValueUnknown(), diags
	}

	return EncryptionValue{
		SseAlgorithm: sseAlgorithmVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEncryptionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EncryptionValue {
	object, diags := NewEncryptionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEncryptionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EncryptionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEncryptionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEncryptionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEncryptionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEncryptionValueMust(EncryptionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EncryptionType) ValueType(ctx context.Context) attr.Value {
	return EncryptionValue{}
}

var _ basetypes.ObjectValuable = EncryptionValue{}

type EncryptionValue struct {
	SseAlgorithm ovhtypes.TfStringValue `tfsdk:"sse_algorithm" json:"sseAlgorithm"`
	state        attr.ValueState
}

type EncryptionWritableValue struct {
	*EncryptionValue `json:"-"`
	SseAlgorithm     *ovhtypes.TfStringValue `json:"sseAlgorithm,omitempty"`
}

func (v EncryptionValue) ToCreate() *EncryptionWritableValue {
	res := &EncryptionWritableValue{}

	if !v.SseAlgorithm.IsNull() {
		res.SseAlgorithm = &v.SseAlgorithm
	}

	return res
}

func (v EncryptionValue) ToUpdate() *EncryptionWritableValue {
	res := &EncryptionWritableValue{}

	if !v.SseAlgorithm.IsNull() {
		res.SseAlgorithm = &v.SseAlgorithm
	}

	return res
}

func (v *EncryptionValue) UnmarshalJSON(data []byte) error {
	type JsonEncryptionValue EncryptionValue

	var tmp JsonEncryptionValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.SseAlgorithm = tmp.SseAlgorithm

	v.state = attr.ValueStateKnown

	return nil
}

func (v *EncryptionValue) MergeWith(other *EncryptionValue) {

	if (v.SseAlgorithm.IsUnknown() || v.SseAlgorithm.IsNull()) && !other.SseAlgorithm.IsUnknown() {
		v.SseAlgorithm = other.SseAlgorithm
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v EncryptionValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"sseAlgorithm": v.SseAlgorithm,
	}
}
func (v EncryptionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["sse_algorithm"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.SseAlgorithm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sse_algorithm"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EncryptionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EncryptionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EncryptionValue) String() string {
	return "EncryptionValue"
}

func (v EncryptionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"sse_algorithm": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"sse_algorithm": v.SseAlgorithm,
		})

	return objVal, diags
}

func (v EncryptionValue) Equal(o attr.Value) bool {
	other, ok := o.(EncryptionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SseAlgorithm.Equal(other.SseAlgorithm) {
		return false
	}

	return true
}

func (v EncryptionValue) Type(ctx context.Context) attr.Type {
	return EncryptionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EncryptionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"sse_algorithm": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = ObjectsType{}

type ObjectsType struct {
	basetypes.ObjectType
}

func (t ObjectsType) Equal(o attr.Type) bool {
	other, ok := o.(ObjectsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ObjectsType) String() string {
	return "ObjectsType"
}

func (t ObjectsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	etagAttribute, ok := attributes["etag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`etag is missing from object`)

		return nil, diags
	}

	etagVal, ok := etagAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`etag expected to be ovhtypes.TfStringValue, was: %T`, etagAttribute))
	}

	isDeleteMarkerAttribute, ok := attributes["is_delete_marker"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_delete_marker is missing from object`)

		return nil, diags
	}

	isDeleteMarkerVal, ok := isDeleteMarkerAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_delete_marker expected to be ovhtypes.TfBoolValue, was: %T`, isDeleteMarkerAttribute))
	}

	isLatestAttribute, ok := attributes["is_latest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_latest is missing from object`)

		return nil, diags
	}

	isLatestVal, ok := isLatestAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_latest expected to be ovhtypes.TfBoolValue, was: %T`, isLatestAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be ovhtypes.TfStringValue, was: %T`, keyAttribute))
	}

	lastModifiedAttribute, ok := attributes["last_modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_modified is missing from object`)

		return nil, diags
	}

	lastModifiedVal, ok := lastModifiedAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_modified expected to be ovhtypes.TfStringValue, was: %T`, lastModifiedAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be ovhtypes.TfInt64Value, was: %T`, sizeAttribute))
	}

	storageClassAttribute, ok := attributes["storage_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class is missing from object`)

		return nil, diags
	}

	storageClassVal, ok := storageClassAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class expected to be ovhtypes.TfStringValue, was: %T`, storageClassAttribute))
	}

	versionIdAttribute, ok := attributes["version_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_id is missing from object`)

		return nil, diags
	}

	versionIdVal, ok := versionIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_id expected to be ovhtypes.TfStringValue, was: %T`, versionIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ObjectsValue{
		Etag:           etagVal,
		IsDeleteMarker: isDeleteMarkerVal,
		IsLatest:       isLatestVal,
		Key:            keyVal,
		LastModified:   lastModifiedVal,
		Size:           sizeVal,
		StorageClass:   storageClassVal,
		VersionId:      versionIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewObjectsValueNull() ObjectsValue {
	return ObjectsValue{
		state: attr.ValueStateNull,
	}
}

func NewObjectsValueUnknown() ObjectsValue {
	return ObjectsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewObjectsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ObjectsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ObjectsValue Attribute Value",
				"While creating a ObjectsValue value, a missing attribute value was detected. "+
					"A ObjectsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ObjectsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ObjectsValue Attribute Type",
				"While creating a ObjectsValue value, an invalid attribute value was detected. "+
					"A ObjectsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ObjectsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ObjectsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ObjectsValue Attribute Value",
				"While creating a ObjectsValue value, an extra attribute value was detected. "+
					"A ObjectsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ObjectsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewObjectsValueUnknown(), diags
	}

	etagAttribute, ok := attributes["etag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`etag is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	etagVal, ok := etagAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`etag expected to be ovhtypes.TfStringValue, was: %T`, etagAttribute))
	}

	isDeleteMarkerAttribute, ok := attributes["is_delete_marker"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_delete_marker is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	isDeleteMarkerVal, ok := isDeleteMarkerAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_delete_marker expected to be ovhtypes.TfBoolValue, was: %T`, isDeleteMarkerAttribute))
	}

	isLatestAttribute, ok := attributes["is_latest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_latest is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	isLatestVal, ok := isLatestAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_latest expected to be ovhtypes.TfBoolValue, was: %T`, isLatestAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be ovhtypes.TfStringValue, was: %T`, keyAttribute))
	}

	lastModifiedAttribute, ok := attributes["last_modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_modified is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	lastModifiedVal, ok := lastModifiedAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_modified expected to be ovhtypes.TfStringValue, was: %T`, lastModifiedAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be ovhtypes.TfInt64Value, was: %T`, sizeAttribute))
	}

	storageClassAttribute, ok := attributes["storage_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	storageClassVal, ok := storageClassAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class expected to be ovhtypes.TfStringValue, was: %T`, storageClassAttribute))
	}

	versionIdAttribute, ok := attributes["version_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_id is missing from object`)

		return NewObjectsValueUnknown(), diags
	}

	versionIdVal, ok := versionIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_id expected to be ovhtypes.TfStringValue, was: %T`, versionIdAttribute))
	}

	if diags.HasError() {
		return NewObjectsValueUnknown(), diags
	}

	return ObjectsValue{
		Etag:           etagVal,
		IsDeleteMarker: isDeleteMarkerVal,
		IsLatest:       isLatestVal,
		Key:            keyVal,
		LastModified:   lastModifiedVal,
		Size:           sizeVal,
		StorageClass:   storageClassVal,
		VersionId:      versionIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewObjectsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ObjectsValue {
	object, diags := NewObjectsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewObjectsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ObjectsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewObjectsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewObjectsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewObjectsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewObjectsValueMust(ObjectsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ObjectsType) ValueType(ctx context.Context) attr.Value {
	return ObjectsValue{}
}

var _ basetypes.ObjectValuable = ObjectsValue{}

type ObjectsValue struct {
	Etag           ovhtypes.TfStringValue `tfsdk:"etag" json:"etag"`
	IsDeleteMarker ovhtypes.TfBoolValue   `tfsdk:"is_delete_marker" json:"isDeleteMarker"`
	IsLatest       ovhtypes.TfBoolValue   `tfsdk:"is_latest" json:"isLatest"`
	Key            ovhtypes.TfStringValue `tfsdk:"key" json:"key"`
	LastModified   ovhtypes.TfStringValue `tfsdk:"last_modified" json:"lastModified"`
	Size           ovhtypes.TfInt64Value  `tfsdk:"size" json:"size"`
	StorageClass   ovhtypes.TfStringValue `tfsdk:"storage_class" json:"storageClass"`
	VersionId      ovhtypes.TfStringValue `tfsdk:"version_id" json:"versionId"`
	state          attr.ValueState
}

type ObjectsWritableValue struct {
	*ObjectsValue  `json:"-"`
	IsDeleteMarker *ovhtypes.TfBoolValue `json:"isDeleteMarker,omitempty"`
	IsLatest       *ovhtypes.TfBoolValue `json:"isLatest,omitempty"`
}

func (v ObjectsValue) ToCreate() *ObjectsWritableValue {
	res := &ObjectsWritableValue{}

	if !v.IsDeleteMarker.IsNull() {
		res.IsDeleteMarker = &v.IsDeleteMarker
	}

	if !v.IsLatest.IsNull() {
		res.IsLatest = &v.IsLatest
	}

	return res
}

func (v *ObjectsValue) UnmarshalJSON(data []byte) error {
	type JsonObjectsValue ObjectsValue

	var tmp JsonObjectsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Etag = tmp.Etag
	v.IsDeleteMarker = tmp.IsDeleteMarker
	v.IsLatest = tmp.IsLatest
	v.Key = tmp.Key
	v.LastModified = tmp.LastModified
	v.Size = tmp.Size
	v.StorageClass = tmp.StorageClass
	v.VersionId = tmp.VersionId

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ObjectsValue) MergeWith(other *ObjectsValue) {

	if (v.Etag.IsUnknown() || v.Etag.IsNull()) && !other.Etag.IsUnknown() {
		v.Etag = other.Etag
	}

	if (v.IsDeleteMarker.IsUnknown() || v.IsDeleteMarker.IsNull()) && !other.IsDeleteMarker.IsUnknown() {
		v.IsDeleteMarker = other.IsDeleteMarker
	}

	if (v.IsLatest.IsUnknown() || v.IsLatest.IsNull()) && !other.IsLatest.IsUnknown() {
		v.IsLatest = other.IsLatest
	}

	if (v.Key.IsUnknown() || v.Key.IsNull()) && !other.Key.IsUnknown() {
		v.Key = other.Key
	}

	if (v.LastModified.IsUnknown() || v.LastModified.IsNull()) && !other.LastModified.IsUnknown() {
		v.LastModified = other.LastModified
	}

	if (v.Size.IsUnknown() || v.Size.IsNull()) && !other.Size.IsUnknown() {
		v.Size = other.Size
	}

	if (v.StorageClass.IsUnknown() || v.StorageClass.IsNull()) && !other.StorageClass.IsUnknown() {
		v.StorageClass = other.StorageClass
	}

	if (v.VersionId.IsUnknown() || v.VersionId.IsNull()) && !other.VersionId.IsUnknown() {
		v.VersionId = other.VersionId
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ObjectsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"etag":           v.Etag,
		"isDeleteMarker": v.IsDeleteMarker,
		"isLatest":       v.IsLatest,
		"key":            v.Key,
		"lastModified":   v.LastModified,
		"size":           v.Size,
		"storageClass":   v.StorageClass,
		"versionId":      v.VersionId,
	}
}
func (v ObjectsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["etag"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_delete_marker"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_latest"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_modified"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage_class"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Etag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["etag"] = val

		val, err = v.IsDeleteMarker.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_delete_marker"] = val

		val, err = v.IsLatest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_latest"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.LastModified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_modified"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.StorageClass.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_class"] = val

		val, err = v.VersionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ObjectsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ObjectsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ObjectsValue) String() string {
	return "ObjectsValue"
}

func (v ObjectsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"etag":             ovhtypes.TfStringType{},
			"is_delete_marker": ovhtypes.TfBoolType{},
			"is_latest":        ovhtypes.TfBoolType{},
			"key":              ovhtypes.TfStringType{},
			"last_modified":    ovhtypes.TfStringType{},
			"size":             ovhtypes.TfInt64Type{},
			"storage_class":    ovhtypes.TfStringType{},
			"version_id":       ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"etag":             v.Etag,
			"is_delete_marker": v.IsDeleteMarker,
			"is_latest":        v.IsLatest,
			"key":              v.Key,
			"last_modified":    v.LastModified,
			"size":             v.Size,
			"storage_class":    v.StorageClass,
			"version_id":       v.VersionId,
		})

	return objVal, diags
}

func (v ObjectsValue) Equal(o attr.Value) bool {
	other, ok := o.(ObjectsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Etag.Equal(other.Etag) {
		return false
	}

	if !v.IsDeleteMarker.Equal(other.IsDeleteMarker) {
		return false
	}

	if !v.IsLatest.Equal(other.IsLatest) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.LastModified.Equal(other.LastModified) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.StorageClass.Equal(other.StorageClass) {
		return false
	}

	if !v.VersionId.Equal(other.VersionId) {
		return false
	}

	return true
}

func (v ObjectsValue) Type(ctx context.Context) attr.Type {
	return ObjectsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ObjectsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"etag":             ovhtypes.TfStringType{},
		"is_delete_marker": ovhtypes.TfBoolType{},
		"is_latest":        ovhtypes.TfBoolType{},
		"key":              ovhtypes.TfStringType{},
		"last_modified":    ovhtypes.TfStringType{},
		"size":             ovhtypes.TfInt64Type{},
		"storage_class":    ovhtypes.TfStringType{},
		"version_id":       ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = ReplicationType{}

type ReplicationType struct {
	basetypes.ObjectType
}

func (t ReplicationType) Equal(o attr.Type) bool {
	other, ok := o.(ReplicationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ReplicationType) String() string {
	return "ReplicationType"
}

func (t ReplicationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(ovhtypes.TfListNestedValue[ReplicationRulesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be ovhtypes.TfListNestedValue[ReplicationRulesValue], was: %T`, rulesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ReplicationValue{
		Rules: rulesVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewReplicationValueNull() ReplicationValue {
	return ReplicationValue{
		state: attr.ValueStateNull,
	}
}

func NewReplicationValueUnknown() ReplicationValue {
	return ReplicationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewReplicationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ReplicationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ReplicationValue Attribute Value",
				"While creating a ReplicationValue value, a missing attribute value was detected. "+
					"A ReplicationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ReplicationValue Attribute Type",
				"While creating a ReplicationValue value, an invalid attribute value was detected. "+
					"A ReplicationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ReplicationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ReplicationValue Attribute Value",
				"While creating a ReplicationValue value, an extra attribute value was detected. "+
					"A ReplicationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ReplicationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewReplicationValueUnknown(), diags
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewReplicationValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(ovhtypes.TfListNestedValue[ReplicationRulesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be ovhtypes.TfListNestedValue[ReplicationRulesValue], was: %T`, rulesAttribute))
	}

	if diags.HasError() {
		return NewReplicationValueUnknown(), diags
	}

	return ReplicationValue{
		Rules: rulesVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewReplicationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ReplicationValue {
	object, diags := NewReplicationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewReplicationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ReplicationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewReplicationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewReplicationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewReplicationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewReplicationValueMust(ReplicationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ReplicationType) ValueType(ctx context.Context) attr.Value {
	return ReplicationValue{}
}

var _ basetypes.ObjectValuable = ReplicationValue{}

type ReplicationValue struct {
	Rules ovhtypes.TfListNestedValue[ReplicationRulesValue] `tfsdk:"rules" json:"rules"`
	state attr.ValueState
}

type ReplicationWritableValue struct {
	*ReplicationValue `json:"-"`
	Rules             *ovhtypes.TfListNestedValue[ReplicationRulesValue] `json:"rules,omitempty"`
}

func (v ReplicationValue) ToCreate() *ReplicationWritableValue {
	res := &ReplicationWritableValue{}

	if !v.Rules.IsNull() {
		res.Rules = &v.Rules
	}

	return res
}

func (v ReplicationValue) ToUpdate() *ReplicationWritableValue {
	res := &ReplicationWritableValue{}

	if !v.Rules.IsNull() {
		res.Rules = &v.Rules
	}

	return res
}

func (v *ReplicationValue) UnmarshalJSON(data []byte) error {
	type JsonReplicationValue ReplicationValue

	var tmp JsonReplicationValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Rules = tmp.Rules

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ReplicationValue) MergeWith(other *ReplicationValue) {

	if (v.Rules.IsUnknown() || v.Rules.IsNull()) && !other.Rules.IsUnknown() {
		v.Rules = other.Rules
	} else if !other.Rules.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Rules.Elements()
		newElems := other.Rules.Elements()

		if len(elems) != len(newElems) {
			v.Rules = other.Rules
		} else {
			for idx, e := range elems {
				tmp := e.(ReplicationRulesValue)
				tmp2 := newElems[idx].(ReplicationRulesValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Rules = ovhtypes.TfListNestedValue[ReplicationRulesValue]{
				ListValue: basetypes.NewListValueMust(ReplicationRulesValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ReplicationValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"rules": v.Rules,
	}
}
func (v ReplicationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["rules"] = basetypes.ListType{
		ElemType: ReplicationRulesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ReplicationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ReplicationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ReplicationValue) String() string {
	return "ReplicationValue"
}

func (v ReplicationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"rules": ovhtypes.NewTfListNestedType[ReplicationRulesValue](ctx),
		},
		map[string]attr.Value{
			"rules": v.Rules,
		})

	return objVal, diags
}

func (v ReplicationValue) Equal(o attr.Value) bool {
	other, ok := o.(ReplicationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	return true
}

func (v ReplicationValue) Type(ctx context.Context) attr.Type {
	return ReplicationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ReplicationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"rules": ovhtypes.NewTfListNestedType[ReplicationRulesValue](ctx),
	}
}

var _ basetypes.ObjectTypable = ReplicationRulesType{}

type ReplicationRulesType struct {
	basetypes.ObjectType
}

func (t ReplicationRulesType) Equal(o attr.Type) bool {
	other, ok := o.(ReplicationRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ReplicationRulesType) String() string {
	return "ReplicationRulesType"
}

func (t ReplicationRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deleteMarkerReplicationAttribute, ok := attributes["delete_marker_replication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_marker_replication is missing from object`)

		return nil, diags
	}

	deleteMarkerReplicationVal, ok := deleteMarkerReplicationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_marker_replication expected to be ovhtypes.TfStringValue, was: %T`, deleteMarkerReplicationAttribute))
	}

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return nil, diags
	}

	destinationVal, ok := destinationAttribute.(ReplicationRulesDestinationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be ReplicationRulesDestinationValue, was: %T`, destinationAttribute))
	}

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return nil, diags
	}

	filterVal, ok := filterAttribute.(ReplicationRulesFilterValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be ReplicationRulesFilterValue, was: %T`, filterAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return nil, diags
	}

	priorityVal, ok := priorityAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be ovhtypes.TfInt64Value, was: %T`, priorityAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ReplicationRulesValue{
		DeleteMarkerReplication: deleteMarkerReplicationVal,
		Destination:             destinationVal,
		Filter:                  filterVal,
		Id:                      idVal,
		Priority:                priorityVal,
		Status:                  statusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesValueNull() ReplicationRulesValue {
	return ReplicationRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewReplicationRulesValueUnknown() ReplicationRulesValue {
	return ReplicationRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewReplicationRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ReplicationRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ReplicationRulesValue Attribute Value",
				"While creating a ReplicationRulesValue value, a missing attribute value was detected. "+
					"A ReplicationRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ReplicationRulesValue Attribute Type",
				"While creating a ReplicationRulesValue value, an invalid attribute value was detected. "+
					"A ReplicationRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ReplicationRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ReplicationRulesValue Attribute Value",
				"While creating a ReplicationRulesValue value, an extra attribute value was detected. "+
					"A ReplicationRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ReplicationRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewReplicationRulesValueUnknown(), diags
	}

	deleteMarkerReplicationAttribute, ok := attributes["delete_marker_replication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_marker_replication is missing from object`)

		return NewReplicationRulesValueUnknown(), diags
	}

	deleteMarkerReplicationVal, ok := deleteMarkerReplicationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_marker_replication expected to be ovhtypes.TfStringValue, was: %T`, deleteMarkerReplicationAttribute))
	}

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return NewReplicationRulesValueUnknown(), diags
	}

	destinationVal, ok := destinationAttribute.(ReplicationRulesDestinationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be ReplicationRulesDestinationValue, was: %T`, destinationAttribute))
	}

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return NewReplicationRulesValueUnknown(), diags
	}

	filterVal, ok := filterAttribute.(ReplicationRulesFilterValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be ReplicationRulesFilterValue, was: %T`, filterAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewReplicationRulesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return NewReplicationRulesValueUnknown(), diags
	}

	priorityVal, ok := priorityAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be ovhtypes.TfInt64Value, was: %T`, priorityAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewReplicationRulesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewReplicationRulesValueUnknown(), diags
	}

	return ReplicationRulesValue{
		DeleteMarkerReplication: deleteMarkerReplicationVal,
		Destination:             destinationVal,
		Filter:                  filterVal,
		Id:                      idVal,
		Priority:                priorityVal,
		Status:                  statusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ReplicationRulesValue {
	object, diags := NewReplicationRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewReplicationRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ReplicationRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewReplicationRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewReplicationRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewReplicationRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewReplicationRulesValueMust(ReplicationRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ReplicationRulesType) ValueType(ctx context.Context) attr.Value {
	return ReplicationRulesValue{}
}

var _ basetypes.ObjectValuable = ReplicationRulesValue{}

type ReplicationRulesValue struct {
	DeleteMarkerReplication ovhtypes.TfStringValue           `tfsdk:"delete_marker_replication" json:"deleteMarkerReplication"`
	Destination             ReplicationRulesDestinationValue `tfsdk:"destination" json:"destination"`
	Filter                  ReplicationRulesFilterValue      `tfsdk:"filter" json:"filter"`
	Id                      ovhtypes.TfStringValue           `tfsdk:"id" json:"id"`
	Priority                ovhtypes.TfInt64Value            `tfsdk:"priority" json:"priority"`
	Status                  ovhtypes.TfStringValue           `tfsdk:"status" json:"status"`
	state                   attr.ValueState
}

type ReplicationRulesWritableValue struct {
	*ReplicationRulesValue  `json:"-"`
	DeleteMarkerReplication *ovhtypes.TfStringValue           `json:"deleteMarkerReplication,omitempty"`
	Destination             *ReplicationRulesDestinationValue `json:"destination,omitempty"`
	Filter                  *ReplicationRulesFilterValue      `json:"filter,omitempty"`
	Id                      *ovhtypes.TfStringValue           `json:"id,omitempty"`
	Priority                *ovhtypes.TfInt64Value            `json:"priority,omitempty"`
	Status                  *ovhtypes.TfStringValue           `json:"status,omitempty"`
}

func (v ReplicationRulesValue) ToCreate() *ReplicationRulesWritableValue {
	res := &ReplicationRulesWritableValue{}

	if !v.Id.IsNull() {
		res.Id = &v.Id
	}

	if !v.Priority.IsNull() {
		res.Priority = &v.Priority
	}

	if !v.Status.IsNull() {
		res.Status = &v.Status
	}

	if !v.DeleteMarkerReplication.IsNull() {
		res.DeleteMarkerReplication = &v.DeleteMarkerReplication
	}

	if !v.Destination.IsNull() {
		res.Destination = &v.Destination
	}

	if !v.Filter.IsNull() {
		res.Filter = &v.Filter
	}

	return res
}

func (v ReplicationRulesValue) ToUpdate() *ReplicationRulesWritableValue {
	res := &ReplicationRulesWritableValue{}

	if !v.Id.IsNull() {
		res.Id = &v.Id
	}

	if !v.Priority.IsNull() {
		res.Priority = &v.Priority
	}

	if !v.Status.IsNull() {
		res.Status = &v.Status
	}

	if !v.DeleteMarkerReplication.IsNull() {
		res.DeleteMarkerReplication = &v.DeleteMarkerReplication
	}

	if !v.Destination.IsNull() {
		res.Destination = &v.Destination
	}

	if !v.Filter.IsNull() {
		res.Filter = &v.Filter
	}

	return res
}

func (v *ReplicationRulesValue) UnmarshalJSON(data []byte) error {
	type JsonReplicationRulesValue ReplicationRulesValue

	var tmp JsonReplicationRulesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DeleteMarkerReplication = tmp.DeleteMarkerReplication
	v.Destination = tmp.Destination
	v.Filter = tmp.Filter
	v.Id = tmp.Id
	v.Priority = tmp.Priority
	v.Status = tmp.Status

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ReplicationRulesValue) MergeWith(other *ReplicationRulesValue) {

	if (v.DeleteMarkerReplication.IsUnknown() || v.DeleteMarkerReplication.IsNull()) && !other.DeleteMarkerReplication.IsUnknown() {
		v.DeleteMarkerReplication = other.DeleteMarkerReplication
	}

	if v.Destination.IsUnknown() && !other.Destination.IsUnknown() {
		v.Destination = other.Destination
	} else if !other.Destination.IsUnknown() {
		v.Destination.MergeWith(&other.Destination)
	}

	if v.Filter.IsUnknown() && !other.Filter.IsUnknown() {
		v.Filter = other.Filter
	} else if !other.Filter.IsUnknown() {
		v.Filter.MergeWith(&other.Filter)
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Priority.IsUnknown() || v.Priority.IsNull()) && !other.Priority.IsUnknown() {
		v.Priority = other.Priority
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ReplicationRulesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"deleteMarkerReplication": v.DeleteMarkerReplication,
		"destination":             v.Destination,
		"filter":                  v.Filter,
		"id":                      v.Id,
		"priority":                v.Priority,
		"status":                  v.Status,
	}
}
func (v ReplicationRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["delete_marker_replication"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination"] = basetypes.ObjectType{
		AttrTypes: ReplicationRulesDestinationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["filter"] = basetypes.ObjectType{
		AttrTypes: ReplicationRulesFilterValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["priority"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DeleteMarkerReplication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["delete_marker_replication"] = val

		val, err = v.Destination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination"] = val

		val, err = v.Filter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filter"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Priority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["priority"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ReplicationRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ReplicationRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ReplicationRulesValue) String() string {
	return "ReplicationRulesValue"
}

func (v ReplicationRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"delete_marker_replication": ovhtypes.TfStringType{},
			"destination": ReplicationRulesDestinationType{
				basetypes.ObjectType{
					AttrTypes: ReplicationRulesDestinationValue{}.AttributeTypes(ctx),
				},
			},
			"filter": ReplicationRulesFilterType{
				basetypes.ObjectType{
					AttrTypes: ReplicationRulesFilterValue{}.AttributeTypes(ctx),
				},
			},
			"id":       ovhtypes.TfStringType{},
			"priority": ovhtypes.TfInt64Type{},
			"status":   ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"delete_marker_replication": v.DeleteMarkerReplication,
			"destination":               v.Destination,
			"filter":                    v.Filter,
			"id":                        v.Id,
			"priority":                  v.Priority,
			"status":                    v.Status,
		})

	return objVal, diags
}

func (v ReplicationRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(ReplicationRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeleteMarkerReplication.Equal(other.DeleteMarkerReplication) {
		return false
	}

	if !v.Destination.Equal(other.Destination) {
		return false
	}

	if !v.Filter.Equal(other.Filter) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Priority.Equal(other.Priority) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ReplicationRulesValue) Type(ctx context.Context) attr.Type {
	return ReplicationRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ReplicationRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"delete_marker_replication": ovhtypes.TfStringType{},
		"destination":               ReplicationRulesDestinationValue{}.Type(ctx),
		"filter":                    ReplicationRulesFilterValue{}.Type(ctx),
		"id":                        ovhtypes.TfStringType{},
		"priority":                  ovhtypes.TfInt64Type{},
		"status":                    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = ReplicationRulesDestinationType{}

type ReplicationRulesDestinationType struct {
	basetypes.ObjectType
}

func (t ReplicationRulesDestinationType) Equal(o attr.Type) bool {
	other, ok := o.(ReplicationRulesDestinationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ReplicationRulesDestinationType) String() string {
	return "ReplicationRulesDestinationType"
}

func (t ReplicationRulesDestinationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	storageClassAttribute, ok := attributes["storage_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class is missing from object`)

		return nil, diags
	}

	storageClassVal, ok := storageClassAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class expected to be ovhtypes.TfStringValue, was: %T`, storageClassAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ReplicationRulesDestinationValue{
		Name:         nameVal,
		Region:       regionVal,
		StorageClass: storageClassVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesDestinationValueNull() ReplicationRulesDestinationValue {
	return ReplicationRulesDestinationValue{
		state: attr.ValueStateNull,
	}
}

func NewReplicationRulesDestinationValueUnknown() ReplicationRulesDestinationValue {
	return ReplicationRulesDestinationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewReplicationRulesDestinationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ReplicationRulesDestinationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ReplicationRulesDestinationValue Attribute Value",
				"While creating a ReplicationRulesDestinationValue value, a missing attribute value was detected. "+
					"A ReplicationRulesDestinationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesDestinationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ReplicationRulesDestinationValue Attribute Type",
				"While creating a ReplicationRulesDestinationValue value, an invalid attribute value was detected. "+
					"A ReplicationRulesDestinationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesDestinationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ReplicationRulesDestinationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ReplicationRulesDestinationValue Attribute Value",
				"While creating a ReplicationRulesDestinationValue value, an extra attribute value was detected. "+
					"A ReplicationRulesDestinationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ReplicationRulesDestinationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewReplicationRulesDestinationValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewReplicationRulesDestinationValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewReplicationRulesDestinationValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	storageClassAttribute, ok := attributes["storage_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class is missing from object`)

		return NewReplicationRulesDestinationValueUnknown(), diags
	}

	storageClassVal, ok := storageClassAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class expected to be ovhtypes.TfStringValue, was: %T`, storageClassAttribute))
	}

	if diags.HasError() {
		return NewReplicationRulesDestinationValueUnknown(), diags
	}

	return ReplicationRulesDestinationValue{
		Name:         nameVal,
		Region:       regionVal,
		StorageClass: storageClassVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesDestinationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ReplicationRulesDestinationValue {
	object, diags := NewReplicationRulesDestinationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewReplicationRulesDestinationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ReplicationRulesDestinationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewReplicationRulesDestinationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewReplicationRulesDestinationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewReplicationRulesDestinationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewReplicationRulesDestinationValueMust(ReplicationRulesDestinationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ReplicationRulesDestinationType) ValueType(ctx context.Context) attr.Value {
	return ReplicationRulesDestinationValue{}
}

var _ basetypes.ObjectValuable = ReplicationRulesDestinationValue{}

type ReplicationRulesDestinationValue struct {
	Name         ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	Region       ovhtypes.TfStringValue `tfsdk:"region" json:"region"`
	StorageClass ovhtypes.TfStringValue `tfsdk:"storage_class" json:"storageClass"`
	state        attr.ValueState
}

type ReplicationRulesDestinationWritableValue struct {
	*ReplicationRulesDestinationValue `json:"-"`
	Name                              *ovhtypes.TfStringValue `json:"name,omitempty"`
	Region                            *ovhtypes.TfStringValue `json:"region,omitempty"`
	StorageClass                      *ovhtypes.TfStringValue `json:"storageClass,omitempty"`
}

func (v ReplicationRulesDestinationValue) ToCreate() *ReplicationRulesDestinationWritableValue {
	res := &ReplicationRulesDestinationWritableValue{}

	if !v.StorageClass.IsNull() {
		res.StorageClass = &v.StorageClass
	}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.Region.IsNull() {
		res.Region = &v.Region
	}

	return res
}

func (v ReplicationRulesDestinationValue) ToUpdate() *ReplicationRulesDestinationWritableValue {
	res := &ReplicationRulesDestinationWritableValue{}

	if !v.StorageClass.IsNull() {
		res.StorageClass = &v.StorageClass
	}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.Region.IsNull() {
		res.Region = &v.Region
	}

	return res
}

func (v *ReplicationRulesDestinationValue) UnmarshalJSON(data []byte) error {
	type JsonReplicationRulesDestinationValue ReplicationRulesDestinationValue

	var tmp JsonReplicationRulesDestinationValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name
	v.Region = tmp.Region
	v.StorageClass = tmp.StorageClass

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ReplicationRulesDestinationValue) MergeWith(other *ReplicationRulesDestinationValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.StorageClass.IsUnknown() || v.StorageClass.IsNull()) && !other.StorageClass.IsUnknown() {
		v.StorageClass = other.StorageClass
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ReplicationRulesDestinationValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name":         v.Name,
		"region":       v.Region,
		"storageClass": v.StorageClass,
	}
}
func (v ReplicationRulesDestinationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_class"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.StorageClass.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_class"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ReplicationRulesDestinationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ReplicationRulesDestinationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ReplicationRulesDestinationValue) String() string {
	return "ReplicationRulesDestinationValue"
}

func (v ReplicationRulesDestinationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name":          ovhtypes.TfStringType{},
			"region":        ovhtypes.TfStringType{},
			"storage_class": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name":          v.Name,
			"region":        v.Region,
			"storage_class": v.StorageClass,
		})

	return objVal, diags
}

func (v ReplicationRulesDestinationValue) Equal(o attr.Value) bool {
	other, ok := o.(ReplicationRulesDestinationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.StorageClass.Equal(other.StorageClass) {
		return false
	}

	return true
}

func (v ReplicationRulesDestinationValue) Type(ctx context.Context) attr.Type {
	return ReplicationRulesDestinationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ReplicationRulesDestinationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":          ovhtypes.TfStringType{},
		"region":        ovhtypes.TfStringType{},
		"storage_class": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = ReplicationRulesFilterType{}

type ReplicationRulesFilterType struct {
	basetypes.ObjectType
}

func (t ReplicationRulesFilterType) Equal(o attr.Type) bool {
	other, ok := o.(ReplicationRulesFilterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ReplicationRulesFilterType) String() string {
	return "ReplicationRulesFilterType"
}

func (t ReplicationRulesFilterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(ovhtypes.TfListNestedValue[ReplicationRulesFilterTagsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be ovhtypes.TfListNestedValue[ReplicationRulesFilterTagsValue], was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ReplicationRulesFilterValue{
		Prefix: prefixVal,
		Tags:   tagsVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesFilterValueNull() ReplicationRulesFilterValue {
	return ReplicationRulesFilterValue{
		state: attr.ValueStateNull,
	}
}

func NewReplicationRulesFilterValueUnknown() ReplicationRulesFilterValue {
	return ReplicationRulesFilterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewReplicationRulesFilterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ReplicationRulesFilterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ReplicationRulesFilterValue Attribute Value",
				"While creating a ReplicationRulesFilterValue value, a missing attribute value was detected. "+
					"A ReplicationRulesFilterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesFilterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ReplicationRulesFilterValue Attribute Type",
				"While creating a ReplicationRulesFilterValue value, an invalid attribute value was detected. "+
					"A ReplicationRulesFilterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesFilterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ReplicationRulesFilterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ReplicationRulesFilterValue Attribute Value",
				"While creating a ReplicationRulesFilterValue value, an extra attribute value was detected. "+
					"A ReplicationRulesFilterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ReplicationRulesFilterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewReplicationRulesFilterValueUnknown(), diags
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewReplicationRulesFilterValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewReplicationRulesFilterValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(ovhtypes.TfListNestedValue[ReplicationRulesFilterTagsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be ovhtypes.TfListNestedValue[ReplicationRulesFilterTagsValue], was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewReplicationRulesFilterValueUnknown(), diags
	}

	return ReplicationRulesFilterValue{
		Prefix: prefixVal,
		Tags:   tagsVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesFilterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ReplicationRulesFilterValue {
	object, diags := NewReplicationRulesFilterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewReplicationRulesFilterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ReplicationRulesFilterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewReplicationRulesFilterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewReplicationRulesFilterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewReplicationRulesFilterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewReplicationRulesFilterValueMust(ReplicationRulesFilterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ReplicationRulesFilterType) ValueType(ctx context.Context) attr.Value {
	return ReplicationRulesFilterValue{}
}

var _ basetypes.ObjectValuable = ReplicationRulesFilterValue{}

type ReplicationRulesFilterValue struct {
	Prefix ovhtypes.TfStringValue                                      `tfsdk:"prefix" json:"prefix"`
	Tags   ovhtypes.TfListNestedValue[ReplicationRulesFilterTagsValue] `tfsdk:"tags" json:"tags"`
	state  attr.ValueState
}

type ReplicationRulesFilterWritableValue struct {
	*ReplicationRulesFilterValue `json:"-"`
	Prefix                       *ovhtypes.TfStringValue                                      `json:"prefix,omitempty"`
	Tags                         *ovhtypes.TfListNestedValue[ReplicationRulesFilterTagsValue] `json:"tags,omitempty"`
}

func (v ReplicationRulesFilterValue) ToCreate() *ReplicationRulesFilterWritableValue {
	res := &ReplicationRulesFilterWritableValue{}

	if !v.Tags.IsNull() {
		res.Tags = &v.Tags
	}

	if !v.Prefix.IsNull() {
		res.Prefix = &v.Prefix
	}

	return res
}

func (v ReplicationRulesFilterValue) ToUpdate() *ReplicationRulesFilterWritableValue {
	res := &ReplicationRulesFilterWritableValue{}

	if !v.Tags.IsNull() {
		res.Tags = &v.Tags
	}

	if !v.Prefix.IsNull() {
		res.Prefix = &v.Prefix
	}

	return res
}

func (v *ReplicationRulesFilterValue) UnmarshalJSON(data []byte) error {
	type JsonReplicationRulesFilterValue ReplicationRulesFilterValue

	var tmp JsonReplicationRulesFilterValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Prefix = tmp.Prefix
	v.Tags = tmp.Tags

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ReplicationRulesFilterValue) MergeWith(other *ReplicationRulesFilterValue) {

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.Tags.IsUnknown() || v.Tags.IsNull()) && !other.Tags.IsUnknown() {
		v.Tags = other.Tags
	} else if !other.Tags.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Tags.Elements()
		newElems := other.Tags.Elements()

		if len(elems) != len(newElems) {
			v.Tags = other.Tags
		} else {
			for idx, e := range elems {
				tmp := e.(ReplicationRulesFilterTagsValue)
				tmp2 := newElems[idx].(ReplicationRulesFilterTagsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Tags = ovhtypes.TfListNestedValue[ReplicationRulesFilterTagsValue]{
				ListValue: basetypes.NewListValueMust(ReplicationRulesFilterTagsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ReplicationRulesFilterValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"prefix": v.Prefix,
		"tags":   v.Tags,
	}
}
func (v ReplicationRulesFilterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: ReplicationRulesFilterTagsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ReplicationRulesFilterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ReplicationRulesFilterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ReplicationRulesFilterValue) String() string {
	return "ReplicationRulesFilterValue"
}

func (v ReplicationRulesFilterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"prefix": ovhtypes.TfStringType{},
			"tags":   ovhtypes.NewTfListNestedType[ReplicationRulesFilterTagsValue](ctx),
		},
		map[string]attr.Value{
			"prefix": v.Prefix,
			"tags":   v.Tags,
		})

	return objVal, diags
}

func (v ReplicationRulesFilterValue) Equal(o attr.Value) bool {
	other, ok := o.(ReplicationRulesFilterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v ReplicationRulesFilterValue) Type(ctx context.Context) attr.Type {
	return ReplicationRulesFilterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ReplicationRulesFilterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix": ovhtypes.TfStringType{},
		"tags":   ovhtypes.NewTfListNestedType[ReplicationRulesFilterTagsValue](ctx),
	}
}

var _ basetypes.ObjectTypable = ReplicationRulesFilterTagsType{}

type ReplicationRulesFilterTagsType struct {
	basetypes.ObjectType
}

func (t ReplicationRulesFilterTagsType) Equal(o attr.Type) bool {
	other, ok := o.(ReplicationRulesFilterTagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ReplicationRulesFilterTagsType) String() string {
	return "ReplicationRulesFilterTagsType"
}

func (t ReplicationRulesFilterTagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be ovhtypes.TfStringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ReplicationRulesFilterTagsValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesFilterTagsValueNull() ReplicationRulesFilterTagsValue {
	return ReplicationRulesFilterTagsValue{
		state: attr.ValueStateNull,
	}
}

func NewReplicationRulesFilterTagsValueUnknown() ReplicationRulesFilterTagsValue {
	return ReplicationRulesFilterTagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewReplicationRulesFilterTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ReplicationRulesFilterTagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ReplicationRulesFilterTagsValue Attribute Value",
				"While creating a ReplicationRulesFilterTagsValue value, a missing attribute value was detected. "+
					"A ReplicationRulesFilterTagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesFilterTagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ReplicationRulesFilterTagsValue Attribute Type",
				"While creating a ReplicationRulesFilterTagsValue value, an invalid attribute value was detected. "+
					"A ReplicationRulesFilterTagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReplicationRulesFilterTagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ReplicationRulesFilterTagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ReplicationRulesFilterTagsValue Attribute Value",
				"While creating a ReplicationRulesFilterTagsValue value, an extra attribute value was detected. "+
					"A ReplicationRulesFilterTagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ReplicationRulesFilterTagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewReplicationRulesFilterTagsValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewReplicationRulesFilterTagsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be ovhtypes.TfStringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewReplicationRulesFilterTagsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewReplicationRulesFilterTagsValueUnknown(), diags
	}

	return ReplicationRulesFilterTagsValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewReplicationRulesFilterTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ReplicationRulesFilterTagsValue {
	object, diags := NewReplicationRulesFilterTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewReplicationRulesFilterTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ReplicationRulesFilterTagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewReplicationRulesFilterTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewReplicationRulesFilterTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewReplicationRulesFilterTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewReplicationRulesFilterTagsValueMust(ReplicationRulesFilterTagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ReplicationRulesFilterTagsType) ValueType(ctx context.Context) attr.Value {
	return ReplicationRulesFilterTagsValue{}
}

var _ basetypes.ObjectValuable = ReplicationRulesFilterTagsValue{}

type ReplicationRulesFilterTagsValue struct {
	Key   ovhtypes.TfStringValue `tfsdk:"key" json:"key"`
	Value ovhtypes.TfStringValue `tfsdk:"value" json:"value"`
	state attr.ValueState
}

type ReplicationRulesFilterTagsWritableValue struct {
	*ReplicationRulesFilterTagsValue `json:"-"`
	Key                              *ovhtypes.TfStringValue `json:"key,omitempty"`
	Value                            *ovhtypes.TfStringValue `json:"value,omitempty"`
}

func (v ReplicationRulesFilterTagsValue) ToCreate() *ReplicationRulesFilterTagsWritableValue {
	res := &ReplicationRulesFilterTagsWritableValue{}

	if !v.Key.IsNull() {
		res.Key = &v.Key
	}

	if !v.Value.IsNull() {
		res.Value = &v.Value
	}

	return res
}

func (v ReplicationRulesFilterTagsValue) ToUpdate() *ReplicationRulesFilterTagsWritableValue {
	res := &ReplicationRulesFilterTagsWritableValue{}

	if !v.Key.IsNull() {
		res.Key = &v.Key
	}

	if !v.Value.IsNull() {
		res.Value = &v.Value
	}

	return res
}

func (v *ReplicationRulesFilterTagsValue) UnmarshalJSON(data []byte) error {
	type JsonReplicationRulesFilterTagsValue ReplicationRulesFilterTagsValue

	var tmp JsonReplicationRulesFilterTagsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Key = tmp.Key
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ReplicationRulesFilterTagsValue) MergeWith(other *ReplicationRulesFilterTagsValue) {

	if (v.Key.IsUnknown() || v.Key.IsNull()) && !other.Key.IsUnknown() {
		v.Key = other.Key
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ReplicationRulesFilterTagsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"key":   v.Key,
		"value": v.Value,
	}
}
func (v ReplicationRulesFilterTagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ReplicationRulesFilterTagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ReplicationRulesFilterTagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ReplicationRulesFilterTagsValue) String() string {
	return "ReplicationRulesFilterTagsValue"
}

func (v ReplicationRulesFilterTagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"key":   ovhtypes.TfStringType{},
			"value": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"key":   v.Key,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ReplicationRulesFilterTagsValue) Equal(o attr.Value) bool {
	other, ok := o.(ReplicationRulesFilterTagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ReplicationRulesFilterTagsValue) Type(ctx context.Context) attr.Type {
	return ReplicationRulesFilterTagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ReplicationRulesFilterTagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key":   ovhtypes.TfStringType{},
		"value": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VersioningType{}

type VersioningType struct {
	basetypes.ObjectType
}

func (t VersioningType) Equal(o attr.Type) bool {
	other, ok := o.(VersioningType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VersioningType) String() string {
	return "VersioningType"
}

func (t VersioningType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VersioningValue{
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVersioningValueNull() VersioningValue {
	return VersioningValue{
		state: attr.ValueStateNull,
	}
}

func NewVersioningValueUnknown() VersioningValue {
	return VersioningValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVersioningValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VersioningValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VersioningValue Attribute Value",
				"While creating a VersioningValue value, a missing attribute value was detected. "+
					"A VersioningValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VersioningValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VersioningValue Attribute Type",
				"While creating a VersioningValue value, an invalid attribute value was detected. "+
					"A VersioningValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VersioningValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VersioningValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VersioningValue Attribute Value",
				"While creating a VersioningValue value, an extra attribute value was detected. "+
					"A VersioningValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VersioningValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVersioningValueUnknown(), diags
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewVersioningValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewVersioningValueUnknown(), diags
	}

	return VersioningValue{
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVersioningValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VersioningValue {
	object, diags := NewVersioningValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVersioningValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VersioningType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVersioningValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVersioningValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVersioningValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVersioningValueMust(VersioningValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VersioningType) ValueType(ctx context.Context) attr.Value {
	return VersioningValue{}
}

var _ basetypes.ObjectValuable = VersioningValue{}

type VersioningValue struct {
	Status ovhtypes.TfStringValue `tfsdk:"status" json:"status"`
	state  attr.ValueState
}

type VersioningWritableValue struct {
	*VersioningValue `json:"-"`
	Status           *ovhtypes.TfStringValue `json:"status,omitempty"`
}

func (v VersioningValue) ToCreate() *VersioningWritableValue {
	res := &VersioningWritableValue{}

	if !v.Status.IsNull() {
		res.Status = &v.Status
	}

	return res
}

func (v VersioningValue) ToUpdate() *VersioningWritableValue {
	res := &VersioningWritableValue{}

	if !v.Status.IsNull() {
		res.Status = &v.Status
	}

	return res
}

func (v *VersioningValue) UnmarshalJSON(data []byte) error {
	type JsonVersioningValue VersioningValue

	var tmp JsonVersioningValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Status = tmp.Status

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VersioningValue) MergeWith(other *VersioningValue) {

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VersioningValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"status": v.Status,
	}
}
func (v VersioningValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VersioningValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VersioningValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VersioningValue) String() string {
	return "VersioningValue"
}

func (v VersioningValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"status": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"status": v.Status,
		})

	return objVal, diags
}

func (v VersioningValue) Equal(o attr.Value) bool {
	other, ok := o.(VersioningValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v VersioningValue) Type(ctx context.Context) attr.Type {
	return VersioningType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VersioningValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"status": ovhtypes.TfStringType{},
	}
}
