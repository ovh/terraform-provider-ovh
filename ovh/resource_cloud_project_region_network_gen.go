// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"
)

func CloudProjectRegionNetworkResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Network id",
			MarkdownDescription: "Network id",
		},
		"name": schema.StringAttribute{
			CustomType: ovhtypes.TfStringType{},
			Required:   true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
			Description:         "Network name",
			MarkdownDescription: "Network name",
		},
		"region": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Network region",
			MarkdownDescription: "Network region",
		},
		"region_name": schema.StringAttribute{
			CustomType: ovhtypes.TfStringType{},
			Required:   true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
			Description:         "Region name",
			MarkdownDescription: "Region name",
		},
		"service_name": schema.StringAttribute{
			CustomType: ovhtypes.TfStringType{},
			Optional:   true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
			Description:         "Service name. If omitted, the `OVH_CLOUD_PROJECT_SERVICE` environment variable is used.",
			MarkdownDescription: "Service name. If omitted, the `OVH_CLOUD_PROJECT_SERVICE` environment variable is used.",
		},
		"subnet": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"allocation_pools": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"end": schema.StringAttribute{
								CustomType: ovhtypes.TfStringType{},
								Optional:   true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
								Description:         "Last IP for the pool (eg: 192.168.1.24)",
								MarkdownDescription: "Last IP for the pool (eg: 192.168.1.24)",
							},
							"start": schema.StringAttribute{
								CustomType: ovhtypes.TfStringType{},
								Optional:   true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
								Description:         "First IP for the pool (eg: 192.168.1.12)",
								MarkdownDescription: "First IP for the pool (eg: 192.168.1.12)",
							},
						},
						CustomType: SubnetAllocationPoolsType{
							ObjectType: types.ObjectType{
								AttrTypes: SubnetAllocationPoolsValue{}.AttributeTypes(ctx),
							},
						},
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplace(),
						},
					},
					CustomType: ovhtypes.NewTfListNestedType[SubnetAllocationPoolsValue](ctx),
					Optional:   true,
					PlanModifiers: []planmodifier.List{
						listplanmodifier.RequiresReplace(),
					},
					Description:         "List of ip pools allocated in subnet",
					MarkdownDescription: "List of ip pools allocated in subnet",
				},
				"cidr": schema.StringAttribute{
					CustomType: ovhtypes.TfStringType{},
					Required:   true,
					PlanModifiers: []planmodifier.String{
						stringplanmodifier.RequiresReplace(),
					},
					Description:         "Subnet range in CIDR notation",
					MarkdownDescription: "Subnet range in CIDR notation",
				},
				"dns_name_servers": schema.ListAttribute{
					CustomType: ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
					Optional:   true,
					PlanModifiers: []planmodifier.List{
						listplanmodifier.RequiresReplace(),
					},
					Description:         "DNS nameservers",
					MarkdownDescription: "DNS nameservers",
				},
				"enable_dhcp": schema.BoolAttribute{
					CustomType: ovhtypes.TfBoolType{},
					Required:   true,
					PlanModifiers: []planmodifier.Bool{
						boolplanmodifier.RequiresReplace(),
					},
					Description:         "Enable DHCP for the subnet",
					MarkdownDescription: "Enable DHCP for the subnet",
				},
				"enable_gateway_ip": schema.BoolAttribute{
					CustomType: ovhtypes.TfBoolType{},
					Required:   true,
					PlanModifiers: []planmodifier.Bool{
						boolplanmodifier.RequiresReplace(),
					},
					Description:         "Set a gateway ip for the subnet",
					MarkdownDescription: "Set a gateway ip for the subnet",
				},
				"gateway_ip": schema.StringAttribute{
					CustomType: ovhtypes.TfStringType{},
					Optional:   true,
					PlanModifiers: []planmodifier.String{
						stringplanmodifier.RequiresReplace(),
					},
					Description:         "Gateway IP",
					MarkdownDescription: "Gateway IP",
				},
				"host_routes": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"destination": schema.StringAttribute{
								CustomType: ovhtypes.TfStringType{},
								Optional:   true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
								Description:         "Host route destination (eg: 192.168.1.0/24)",
								MarkdownDescription: "Host route destination (eg: 192.168.1.0/24)",
							},
							"next_hop": schema.StringAttribute{
								CustomType: ovhtypes.TfStringType{},
								Optional:   true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
								Description:         "Host route next hop (eg: 192.168.1.254)",
								MarkdownDescription: "Host route next hop (eg: 192.168.1.254)",
							},
						},
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplace(),
						},
						CustomType: SubnetHostRoutesType{
							ObjectType: types.ObjectType{
								AttrTypes: SubnetHostRoutesValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType: ovhtypes.NewTfListNestedType[SubnetHostRoutesValue](ctx),
					Optional:   true,
					PlanModifiers: []planmodifier.List{
						listplanmodifier.RequiresReplace(),
					},
					Description:         "Host routes",
					MarkdownDescription: "Host routes",
				},
				"ip_version": schema.Int64Attribute{
					CustomType: ovhtypes.TfInt64Type{},
					Required:   true,
					PlanModifiers: []planmodifier.Int64{
						int64planmodifier.RequiresReplace(),
					},
					Description:         "IP version",
					MarkdownDescription: "IP version",
				},
				"name": schema.StringAttribute{
					CustomType: ovhtypes.TfStringType{},
					Optional:   true,
					PlanModifiers: []planmodifier.String{
						stringplanmodifier.RequiresReplace(),
					},
					Description:         "Subnet name",
					MarkdownDescription: "Subnet name",
				},
				"use_default_public_dnsresolver": schema.BoolAttribute{
					CustomType: ovhtypes.TfBoolType{},
					Optional:   true,
					PlanModifiers: []planmodifier.Bool{
						boolplanmodifier.RequiresReplace(),
					},
					Description:         "Use default DNS",
					MarkdownDescription: "Use default DNS",
				},
			},
			CustomType: SubnetType{
				ObjectType: types.ObjectType{
					AttrTypes: SubnetValue{}.AttributeTypes(ctx),
				},
			},
			Required: true,
			PlanModifiers: []planmodifier.Object{
				objectplanmodifier.RequiresReplace(),
			},
			Description:         "Parameters to create a subnet from another resource creation",
			MarkdownDescription: "Parameters to create a subnet from another resource creation",
		},
		"visibility": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Network visibility",
			MarkdownDescription: "Network visibility",
		},
		"vlan_id": schema.Int64Attribute{
			CustomType: ovhtypes.TfInt64Type{},
			Optional:   true,
			Computed:   true,
			PlanModifiers: []planmodifier.Int64{
				int64planmodifier.RequiresReplace(),
			},
			Description:         "VLAN id, between 1 and 4000",
			MarkdownDescription: "VLAN id, between 1 and 4000",
		},
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type CloudProjectRegionNetworkModel struct {
	Id          ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	Name        ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	Region      ovhtypes.TfStringValue `tfsdk:"region" json:"region"`
	RegionName  ovhtypes.TfStringValue `tfsdk:"region_name" json:"regionName"`
	ServiceName ovhtypes.TfStringValue `tfsdk:"service_name" json:"serviceName"`
	Subnet      SubnetValue            `tfsdk:"subnet" json:"subnet"`
	Visibility  ovhtypes.TfStringValue `tfsdk:"visibility" json:"visibility"`
	VlanId      ovhtypes.TfInt64Value  `tfsdk:"vlan_id" json:"vlanId"`
}

func (v *CloudProjectRegionNetworkModel) MergeWith(other *CloudProjectRegionNetworkModel) {
	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.RegionName.IsUnknown() || v.RegionName.IsNull()) && !other.RegionName.IsUnknown() {
		v.RegionName = other.RegionName
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

	if v.Subnet.IsUnknown() && !other.Subnet.IsUnknown() {
		v.Subnet = other.Subnet
	} else if !other.Subnet.IsUnknown() {
		v.Subnet.MergeWith(&other.Subnet)
	}

	if (v.Visibility.IsUnknown() || v.Visibility.IsNull()) && !other.Visibility.IsUnknown() {
		v.Visibility = other.Visibility
	}

	if (v.VlanId.IsUnknown() || v.VlanId.IsNull()) && !other.VlanId.IsUnknown() {
		v.VlanId = other.VlanId
	}
}

type CloudProjectRegionNetworkWritableModel struct {
	Name   *ovhtypes.TfStringValue `tfsdk:"name" json:"name,omitempty"`
	Subnet *SubnetWritableValue    `tfsdk:"subnet" json:"subnet,omitempty"`
	VlanId *ovhtypes.TfInt64Value  `tfsdk:"vlan_id" json:"vlanId,omitempty"`
}

func (v CloudProjectRegionNetworkModel) ToCreate() *CloudProjectRegionNetworkWritableModel {
	res := &CloudProjectRegionNetworkWritableModel{}

	if !v.Name.IsUnknown() {
		res.Name = &v.Name
	}

	if !v.Subnet.IsUnknown() {
		res.Subnet = v.Subnet.ToCreate()
	}

	if !v.VlanId.IsUnknown() && !v.VlanId.IsNull() {
		res.VlanId = &v.VlanId
	}

	return res
}

var _ basetypes.ObjectTypable = SubnetType{}

type SubnetType struct {
	basetypes.ObjectType
}

func (t SubnetType) Equal(o attr.Type) bool {
	other, ok := o.(SubnetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubnetType) String() string {
	return "SubnetType"
}

func (t SubnetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allocationPoolsAttribute, ok := attributes["allocation_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allocation_pools is missing from object`)

		return nil, diags
	}

	allocationPoolsVal, ok := allocationPoolsAttribute.(ovhtypes.TfListNestedValue[SubnetAllocationPoolsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allocation_pools expected to be ovhtypes.TfListNestedValue[SubnetAllocationPoolsValue], was: %T`, allocationPoolsAttribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	dnsNameServersAttribute, ok := attributes["dns_name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_name_servers is missing from object`)

		return nil, diags
	}

	dnsNameServersVal, ok := dnsNameServersAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_name_servers expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, dnsNameServersAttribute))
	}

	enableDhcpAttribute, ok := attributes["enable_dhcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_dhcp is missing from object`)

		return nil, diags
	}

	enableDhcpVal, ok := enableDhcpAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_dhcp expected to be ovhtypes.TfBoolValue, was: %T`, enableDhcpAttribute))
	}

	enableGatewayIpAttribute, ok := attributes["enable_gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_gateway_ip is missing from object`)

		return nil, diags
	}

	enableGatewayIpVal, ok := enableGatewayIpAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_gateway_ip expected to be ovhtypes.TfBoolValue, was: %T`, enableGatewayIpAttribute))
	}

	gatewayIpAttribute, ok := attributes["gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ip is missing from object`)

		return nil, diags
	}

	gatewayIpVal, ok := gatewayIpAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ip expected to be ovhtypes.TfStringValue, was: %T`, gatewayIpAttribute))
	}

	hostRoutesAttribute, ok := attributes["host_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_routes is missing from object`)

		return nil, diags
	}

	hostRoutesVal, ok := hostRoutesAttribute.(ovhtypes.TfListNestedValue[SubnetHostRoutesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_routes expected to be ovhtypes.TfListNestedValue[SubnetHostRoutesValue], was: %T`, hostRoutesAttribute))
	}

	ipVersionAttribute, ok := attributes["ip_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_version is missing from object`)

		return nil, diags
	}

	ipVersionVal, ok := ipVersionAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_version expected to be ovhtypes.TfInt64Value, was: %T`, ipVersionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	useDefaultPublicDnsresolverAttribute, ok := attributes["use_default_public_dnsresolver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_default_public_dnsresolver is missing from object`)

		return nil, diags
	}

	useDefaultPublicDnsresolverVal, ok := useDefaultPublicDnsresolverAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_default_public_dnsresolver expected to be ovhtypes.TfBoolValue, was: %T`, useDefaultPublicDnsresolverAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubnetValue{
		AllocationPools:             allocationPoolsVal,
		Cidr:                        cidrVal,
		DnsNameServers:              dnsNameServersVal,
		EnableDhcp:                  enableDhcpVal,
		EnableGatewayIp:             enableGatewayIpVal,
		GatewayIp:                   gatewayIpVal,
		HostRoutes:                  hostRoutesVal,
		IpVersion:                   ipVersionVal,
		Name:                        nameVal,
		UseDefaultPublicDnsresolver: useDefaultPublicDnsresolverVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSubnetValueNull() SubnetValue {
	return SubnetValue{
		state: attr.ValueStateNull,
	}
}

func NewSubnetValueUnknown() SubnetValue {
	return SubnetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubnetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubnetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubnetValue Attribute Value",
				"While creating a SubnetValue value, a missing attribute value was detected. "+
					"A SubnetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubnetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubnetValue Attribute Type",
				"While creating a SubnetValue value, an invalid attribute value was detected. "+
					"A SubnetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubnetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubnetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubnetValue Attribute Value",
				"While creating a SubnetValue value, an extra attribute value was detected. "+
					"A SubnetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubnetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubnetValueUnknown(), diags
	}

	allocationPoolsAttribute, ok := attributes["allocation_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allocation_pools is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	allocationPoolsVal, ok := allocationPoolsAttribute.(ovhtypes.TfListNestedValue[SubnetAllocationPoolsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allocation_pools expected to be ovhtypes.TfListNestedValue[SubnetAllocationPoolsValue], was: %T`, allocationPoolsAttribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be ovhtypes.TfStringValue, was: %T`, cidrAttribute))
	}

	dnsNameServersAttribute, ok := attributes["dns_name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_name_servers is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	dnsNameServersVal, ok := dnsNameServersAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_name_servers expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, dnsNameServersAttribute))
	}

	enableDhcpAttribute, ok := attributes["enable_dhcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_dhcp is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	enableDhcpVal, ok := enableDhcpAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_dhcp expected to be ovhtypes.TfBoolValue, was: %T`, enableDhcpAttribute))
	}

	enableGatewayIpAttribute, ok := attributes["enable_gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_gateway_ip is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	enableGatewayIpVal, ok := enableGatewayIpAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_gateway_ip expected to be ovhtypes.TfBoolValue, was: %T`, enableGatewayIpAttribute))
	}

	gatewayIpAttribute, ok := attributes["gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ip is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	gatewayIpVal, ok := gatewayIpAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ip expected to be ovhtypes.TfStringValue, was: %T`, gatewayIpAttribute))
	}

	hostRoutesAttribute, ok := attributes["host_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_routes is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	hostRoutesVal, ok := hostRoutesAttribute.(ovhtypes.TfListNestedValue[SubnetHostRoutesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_routes expected to be ovhtypes.TfListNestedValue[SubnetHostRoutesValue], was: %T`, hostRoutesAttribute))
	}

	ipVersionAttribute, ok := attributes["ip_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_version is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	ipVersionVal, ok := ipVersionAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_version expected to be ovhtypes.TfInt64Value, was: %T`, ipVersionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	useDefaultPublicDnsresolverAttribute, ok := attributes["use_default_public_dnsresolver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_default_public_dnsresolver is missing from object`)

		return NewSubnetValueUnknown(), diags
	}

	useDefaultPublicDnsresolverVal, ok := useDefaultPublicDnsresolverAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_default_public_dnsresolver expected to be ovhtypes.TfBoolValue, was: %T`, useDefaultPublicDnsresolverAttribute))
	}

	if diags.HasError() {
		return NewSubnetValueUnknown(), diags
	}

	return SubnetValue{
		AllocationPools:             allocationPoolsVal,
		Cidr:                        cidrVal,
		DnsNameServers:              dnsNameServersVal,
		EnableDhcp:                  enableDhcpVal,
		EnableGatewayIp:             enableGatewayIpVal,
		GatewayIp:                   gatewayIpVal,
		HostRoutes:                  hostRoutesVal,
		IpVersion:                   ipVersionVal,
		Name:                        nameVal,
		UseDefaultPublicDnsresolver: useDefaultPublicDnsresolverVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSubnetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubnetValue {
	object, diags := NewSubnetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubnetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubnetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubnetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubnetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubnetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubnetValueMust(SubnetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubnetType) ValueType(ctx context.Context) attr.Value {
	return SubnetValue{}
}

var _ basetypes.ObjectValuable = SubnetValue{}

type SubnetValue struct {
	AllocationPools             ovhtypes.TfListNestedValue[SubnetAllocationPoolsValue] `tfsdk:"allocation_pools" json:"allocationPools"`
	Cidr                        ovhtypes.TfStringValue                                 `tfsdk:"cidr" json:"cidr"`
	DnsNameServers              ovhtypes.TfListNestedValue[ovhtypes.TfStringValue]     `tfsdk:"dns_name_servers" json:"dnsNameServers"`
	EnableDhcp                  ovhtypes.TfBoolValue                                   `tfsdk:"enable_dhcp" json:"enableDhcp"`
	EnableGatewayIp             ovhtypes.TfBoolValue                                   `tfsdk:"enable_gateway_ip" json:"enableGatewayIp"`
	GatewayIp                   ovhtypes.TfStringValue                                 `tfsdk:"gateway_ip" json:"gatewayIp"`
	HostRoutes                  ovhtypes.TfListNestedValue[SubnetHostRoutesValue]      `tfsdk:"host_routes" json:"hostRoutes"`
	IpVersion                   ovhtypes.TfInt64Value                                  `tfsdk:"ip_version" json:"ipVersion"`
	Name                        ovhtypes.TfStringValue                                 `tfsdk:"name" json:"name"`
	UseDefaultPublicDnsresolver ovhtypes.TfBoolValue                                   `tfsdk:"use_default_public_dnsresolver" json:"useDefaultPublicDnsresolver"`
	state                       attr.ValueState
}

type SubnetWritableValue struct {
	*SubnetValue                `json:"-"`
	AllocationPools             *ovhtypes.TfListNestedValue[SubnetAllocationPoolsValue] `json:"allocationPools,omitempty"`
	Cidr                        *ovhtypes.TfStringValue                                 `json:"cidr,omitempty"`
	DnsNameServers              *ovhtypes.TfListNestedValue[ovhtypes.TfStringValue]     `json:"dnsNameServers,omitempty"`
	EnableDhcp                  *ovhtypes.TfBoolValue                                   `json:"enableDhcp,omitempty"`
	EnableGatewayIp             *ovhtypes.TfBoolValue                                   `json:"enableGatewayIp,omitempty"`
	GatewayIp                   *ovhtypes.TfStringValue                                 `json:"gatewayIp,omitempty"`
	HostRoutes                  *ovhtypes.TfListNestedValue[SubnetHostRoutesValue]      `json:"hostRoutes,omitempty"`
	IpVersion                   *ovhtypes.TfInt64Value                                  `json:"ipVersion,omitempty"`
	Name                        *ovhtypes.TfStringValue                                 `json:"name,omitempty"`
	UseDefaultPublicDnsresolver *ovhtypes.TfBoolValue                                   `json:"useDefaultPublicDnsresolver,omitempty"`
}

func (v SubnetValue) ToCreate() *SubnetWritableValue {
	res := &SubnetWritableValue{}

	if !v.Name.IsUnknown() && !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.UseDefaultPublicDnsresolver.IsUnknown() && !v.UseDefaultPublicDnsresolver.IsNull() {
		res.UseDefaultPublicDnsresolver = &v.UseDefaultPublicDnsresolver
	}

	if !v.IpVersion.IsUnknown() && !v.IpVersion.IsNull() {
		res.IpVersion = &v.IpVersion
	}

	if !v.AllocationPools.IsUnknown() && !v.AllocationPools.IsNull() {
		res.AllocationPools = &v.AllocationPools
	}

	if !v.DnsNameServers.IsUnknown() && !v.DnsNameServers.IsNull() {
		res.DnsNameServers = &v.DnsNameServers
	}

	if !v.HostRoutes.IsUnknown() && !v.HostRoutes.IsNull() {
		res.HostRoutes = &v.HostRoutes
	}

	if !v.EnableDhcp.IsUnknown() && !v.EnableDhcp.IsNull() {
		res.EnableDhcp = &v.EnableDhcp
	}

	if !v.EnableGatewayIp.IsUnknown() && !v.EnableGatewayIp.IsNull() {
		res.EnableGatewayIp = &v.EnableGatewayIp
	}

	if !v.GatewayIp.IsUnknown() && !v.GatewayIp.IsNull() {
		res.GatewayIp = &v.GatewayIp
	}

	if !v.Cidr.IsUnknown() && !v.Cidr.IsNull() {
		res.Cidr = &v.Cidr
	}

	return res
}

func (v *SubnetValue) UnmarshalJSON(data []byte) error {
	type JsonSubnetValue SubnetValue

	var tmp JsonSubnetValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.AllocationPools = tmp.AllocationPools
	v.Cidr = tmp.Cidr
	v.DnsNameServers = tmp.DnsNameServers
	v.EnableDhcp = tmp.EnableDhcp
	v.EnableGatewayIp = tmp.EnableGatewayIp
	v.GatewayIp = tmp.GatewayIp
	v.HostRoutes = tmp.HostRoutes
	v.IpVersion = tmp.IpVersion
	v.Name = tmp.Name
	v.UseDefaultPublicDnsresolver = tmp.UseDefaultPublicDnsresolver

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SubnetValue) MergeWith(other *SubnetValue) {
	if (v.AllocationPools.IsUnknown() || v.AllocationPools.IsNull()) && !other.AllocationPools.IsUnknown() {
		v.AllocationPools = other.AllocationPools
	} else if !other.AllocationPools.IsUnknown() && !other.AllocationPools.IsNull() {
		newSlice := make([]attr.Value, 0)
		elems := v.AllocationPools.Elements()
		newElems := other.AllocationPools.Elements()

		if len(elems) != len(newElems) {
			v.AllocationPools = other.AllocationPools
		} else {
			for idx, e := range elems {
				tmp := e.(SubnetAllocationPoolsValue)
				tmp2 := newElems[idx].(SubnetAllocationPoolsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.AllocationPools = ovhtypes.TfListNestedValue[SubnetAllocationPoolsValue]{
				ListValue: basetypes.NewListValueMust(SubnetAllocationPoolsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Cidr.IsUnknown() || v.Cidr.IsNull()) && !other.Cidr.IsUnknown() {
		v.Cidr = other.Cidr
	}

	if (v.DnsNameServers.IsUnknown() || v.DnsNameServers.IsNull()) && !other.DnsNameServers.IsUnknown() {
		v.DnsNameServers = other.DnsNameServers
	}

	if (v.EnableDhcp.IsUnknown() || v.EnableDhcp.IsNull()) && !other.EnableDhcp.IsUnknown() {
		v.EnableDhcp = other.EnableDhcp
	}

	if (v.EnableGatewayIp.IsUnknown() || v.EnableGatewayIp.IsNull()) && !other.EnableGatewayIp.IsUnknown() {
		v.EnableGatewayIp = other.EnableGatewayIp
	}

	if (v.GatewayIp.IsUnknown() || v.GatewayIp.IsNull()) && !other.GatewayIp.IsUnknown() {
		v.GatewayIp = other.GatewayIp
	}

	if (v.HostRoutes.IsUnknown() || v.HostRoutes.IsNull()) && !other.HostRoutes.IsUnknown() {
		v.HostRoutes = other.HostRoutes
	} else if !other.HostRoutes.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.HostRoutes.Elements()
		newElems := other.HostRoutes.Elements()

		if len(elems) != len(newElems) {
			v.HostRoutes = other.HostRoutes
		} else {
			for idx, e := range elems {
				tmp := e.(SubnetHostRoutesValue)
				tmp2 := newElems[idx].(SubnetHostRoutesValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.HostRoutes = ovhtypes.TfListNestedValue[SubnetHostRoutesValue]{
				ListValue: basetypes.NewListValueMust(SubnetHostRoutesValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.IpVersion.IsUnknown() || v.IpVersion.IsNull()) && !other.IpVersion.IsUnknown() {
		v.IpVersion = other.IpVersion
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.UseDefaultPublicDnsresolver.IsUnknown() || v.UseDefaultPublicDnsresolver.IsNull()) && !other.UseDefaultPublicDnsresolver.IsUnknown() {
		v.UseDefaultPublicDnsresolver = other.UseDefaultPublicDnsresolver
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SubnetValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"allocationPools":             v.AllocationPools,
		"cidr":                        v.Cidr,
		"dnsNameServers":              v.DnsNameServers,
		"enableDhcp":                  v.EnableDhcp,
		"enableGatewayIp":             v.EnableGatewayIp,
		"gatewayIp":                   v.GatewayIp,
		"hostRoutes":                  v.HostRoutes,
		"ipVersion":                   v.IpVersion,
		"name":                        v.Name,
		"useDefaultPublicDnsresolver": v.UseDefaultPublicDnsresolver,
	}
}
func (v SubnetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["allocation_pools"] = basetypes.ListType{
		ElemType: SubnetAllocationPoolsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dns_name_servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enable_dhcp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_gateway_ip"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gateway_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host_routes"] = basetypes.ListType{
		ElemType: SubnetHostRoutesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_version"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_default_public_dnsresolver"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AllocationPools.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allocation_pools"] = val

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.DnsNameServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_name_servers"] = val

		val, err = v.EnableDhcp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_dhcp"] = val

		val, err = v.EnableGatewayIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_gateway_ip"] = val

		val, err = v.GatewayIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway_ip"] = val

		val, err = v.HostRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host_routes"] = val

		val, err = v.IpVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_version"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.UseDefaultPublicDnsresolver.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_default_public_dnsresolver"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubnetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubnetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubnetValue) String() string {
	return "SubnetValue"
}

func (v SubnetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"allocation_pools":               ovhtypes.NewTfListNestedType[SubnetAllocationPoolsValue](ctx),
			"cidr":                           ovhtypes.TfStringType{},
			"dns_name_servers":               ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
			"enable_dhcp":                    ovhtypes.TfBoolType{},
			"enable_gateway_ip":              ovhtypes.TfBoolType{},
			"gateway_ip":                     ovhtypes.TfStringType{},
			"host_routes":                    ovhtypes.NewTfListNestedType[SubnetHostRoutesValue](ctx),
			"ip_version":                     ovhtypes.TfInt64Type{},
			"name":                           ovhtypes.TfStringType{},
			"use_default_public_dnsresolver": ovhtypes.TfBoolType{},
		},
		map[string]attr.Value{
			"allocation_pools":               v.AllocationPools,
			"cidr":                           v.Cidr,
			"dns_name_servers":               v.DnsNameServers,
			"enable_dhcp":                    v.EnableDhcp,
			"enable_gateway_ip":              v.EnableGatewayIp,
			"gateway_ip":                     v.GatewayIp,
			"host_routes":                    v.HostRoutes,
			"ip_version":                     v.IpVersion,
			"name":                           v.Name,
			"use_default_public_dnsresolver": v.UseDefaultPublicDnsresolver,
		})

	return objVal, diags
}

func (v SubnetValue) Equal(o attr.Value) bool {
	other, ok := o.(SubnetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllocationPools.Equal(other.AllocationPools) {
		return false
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.DnsNameServers.Equal(other.DnsNameServers) {
		return false
	}

	if !v.EnableDhcp.Equal(other.EnableDhcp) {
		return false
	}

	if !v.EnableGatewayIp.Equal(other.EnableGatewayIp) {
		return false
	}

	if !v.GatewayIp.Equal(other.GatewayIp) {
		return false
	}

	if !v.HostRoutes.Equal(other.HostRoutes) {
		return false
	}

	if !v.IpVersion.Equal(other.IpVersion) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.UseDefaultPublicDnsresolver.Equal(other.UseDefaultPublicDnsresolver) {
		return false
	}

	return true
}

func (v SubnetValue) Type(ctx context.Context) attr.Type {
	return SubnetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubnetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allocation_pools":               ovhtypes.NewTfListNestedType[SubnetAllocationPoolsValue](ctx),
		"cidr":                           ovhtypes.TfStringType{},
		"dns_name_servers":               ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		"enable_dhcp":                    ovhtypes.TfBoolType{},
		"enable_gateway_ip":              ovhtypes.TfBoolType{},
		"gateway_ip":                     ovhtypes.TfStringType{},
		"host_routes":                    ovhtypes.NewTfListNestedType[SubnetHostRoutesValue](ctx),
		"ip_version":                     ovhtypes.TfInt64Type{},
		"name":                           ovhtypes.TfStringType{},
		"use_default_public_dnsresolver": ovhtypes.TfBoolType{},
	}
}

var _ basetypes.ObjectTypable = SubnetAllocationPoolsType{}

type SubnetAllocationPoolsType struct {
	basetypes.ObjectType
}

func (t SubnetAllocationPoolsType) Equal(o attr.Type) bool {
	other, ok := o.(SubnetAllocationPoolsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubnetAllocationPoolsType) String() string {
	return "SubnetAllocationPoolsType"
}

func (t SubnetAllocationPoolsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return nil, diags
	}

	endVal, ok := endAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be ovhtypes.TfStringValue, was: %T`, endAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be ovhtypes.TfStringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubnetAllocationPoolsValue{
		End:   endVal,
		Start: startVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSubnetAllocationPoolsValueNull() SubnetAllocationPoolsValue {
	return SubnetAllocationPoolsValue{
		state: attr.ValueStateNull,
	}
}

func NewSubnetAllocationPoolsValueUnknown() SubnetAllocationPoolsValue {
	return SubnetAllocationPoolsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubnetAllocationPoolsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubnetAllocationPoolsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubnetAllocationPoolsValue Attribute Value",
				"While creating a SubnetAllocationPoolsValue value, a missing attribute value was detected. "+
					"A SubnetAllocationPoolsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubnetAllocationPoolsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubnetAllocationPoolsValue Attribute Type",
				"While creating a SubnetAllocationPoolsValue value, an invalid attribute value was detected. "+
					"A SubnetAllocationPoolsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubnetAllocationPoolsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubnetAllocationPoolsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubnetAllocationPoolsValue Attribute Value",
				"While creating a SubnetAllocationPoolsValue value, an extra attribute value was detected. "+
					"A SubnetAllocationPoolsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubnetAllocationPoolsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubnetAllocationPoolsValueUnknown(), diags
	}

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return NewSubnetAllocationPoolsValueUnknown(), diags
	}

	endVal, ok := endAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be ovhtypes.TfStringValue, was: %T`, endAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewSubnetAllocationPoolsValueUnknown(), diags
	}

	startVal, ok := startAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be ovhtypes.TfStringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewSubnetAllocationPoolsValueUnknown(), diags
	}

	return SubnetAllocationPoolsValue{
		End:   endVal,
		Start: startVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSubnetAllocationPoolsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubnetAllocationPoolsValue {
	object, diags := NewSubnetAllocationPoolsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubnetAllocationPoolsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubnetAllocationPoolsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubnetAllocationPoolsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubnetAllocationPoolsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubnetAllocationPoolsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubnetAllocationPoolsValueMust(SubnetAllocationPoolsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubnetAllocationPoolsType) ValueType(ctx context.Context) attr.Value {
	return SubnetAllocationPoolsValue{}
}

var _ basetypes.ObjectValuable = SubnetAllocationPoolsValue{}

type SubnetAllocationPoolsValue struct {
	End   ovhtypes.TfStringValue `tfsdk:"end" json:"end"`
	Start ovhtypes.TfStringValue `tfsdk:"start" json:"start"`
	state attr.ValueState
}

type SubnetAllocationPoolsWritableValue struct {
	*SubnetAllocationPoolsValue `json:"-"`
	End                         *ovhtypes.TfStringValue `json:"end,omitempty"`
	Start                       *ovhtypes.TfStringValue `json:"start,omitempty"`
}

func (v SubnetAllocationPoolsValue) ToCreate() *SubnetAllocationPoolsWritableValue {
	res := &SubnetAllocationPoolsWritableValue{}

	if !v.End.IsNull() {
		res.End = &v.End
	}

	if !v.Start.IsNull() {
		res.Start = &v.Start
	}

	return res
}

func (v SubnetAllocationPoolsValue) ToUpdate() *SubnetAllocationPoolsWritableValue {
	res := &SubnetAllocationPoolsWritableValue{}

	if !v.End.IsNull() {
		res.End = &v.End
	}

	if !v.Start.IsNull() {
		res.Start = &v.Start
	}

	return res
}

func (v *SubnetAllocationPoolsValue) UnmarshalJSON(data []byte) error {
	type JsonSubnetAllocationPoolsValue SubnetAllocationPoolsValue

	var tmp JsonSubnetAllocationPoolsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.End = tmp.End
	v.Start = tmp.Start

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SubnetAllocationPoolsValue) MergeWith(other *SubnetAllocationPoolsValue) {

	if (v.End.IsUnknown() || v.End.IsNull()) && !other.End.IsUnknown() {
		v.End = other.End
	}

	if (v.Start.IsUnknown() || v.Start.IsNull()) && !other.Start.IsUnknown() {
		v.Start = other.Start
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SubnetAllocationPoolsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"end":   v.End,
		"start": v.Start,
	}
}
func (v SubnetAllocationPoolsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.End.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubnetAllocationPoolsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubnetAllocationPoolsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubnetAllocationPoolsValue) String() string {
	return "SubnetAllocationPoolsValue"
}

func (v SubnetAllocationPoolsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"end":   ovhtypes.TfStringType{},
			"start": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"end":   v.End,
			"start": v.Start,
		})

	return objVal, diags
}

func (v SubnetAllocationPoolsValue) Equal(o attr.Value) bool {
	other, ok := o.(SubnetAllocationPoolsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.End.Equal(other.End) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v SubnetAllocationPoolsValue) Type(ctx context.Context) attr.Type {
	return SubnetAllocationPoolsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubnetAllocationPoolsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"end":   ovhtypes.TfStringType{},
		"start": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SubnetHostRoutesType{}

type SubnetHostRoutesType struct {
	basetypes.ObjectType
}

func (t SubnetHostRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(SubnetHostRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubnetHostRoutesType) String() string {
	return "SubnetHostRoutesType"
}

func (t SubnetHostRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return nil, diags
	}

	destinationVal, ok := destinationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be ovhtypes.TfStringValue, was: %T`, destinationAttribute))
	}

	nextHopAttribute, ok := attributes["next_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop is missing from object`)

		return nil, diags
	}

	nextHopVal, ok := nextHopAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop expected to be ovhtypes.TfStringValue, was: %T`, nextHopAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubnetHostRoutesValue{
		Destination: destinationVal,
		NextHop:     nextHopVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSubnetHostRoutesValueNull() SubnetHostRoutesValue {
	return SubnetHostRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewSubnetHostRoutesValueUnknown() SubnetHostRoutesValue {
	return SubnetHostRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubnetHostRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubnetHostRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubnetHostRoutesValue Attribute Value",
				"While creating a SubnetHostRoutesValue value, a missing attribute value was detected. "+
					"A SubnetHostRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubnetHostRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubnetHostRoutesValue Attribute Type",
				"While creating a SubnetHostRoutesValue value, an invalid attribute value was detected. "+
					"A SubnetHostRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubnetHostRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubnetHostRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubnetHostRoutesValue Attribute Value",
				"While creating a SubnetHostRoutesValue value, an extra attribute value was detected. "+
					"A SubnetHostRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubnetHostRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubnetHostRoutesValueUnknown(), diags
	}

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return NewSubnetHostRoutesValueUnknown(), diags
	}

	destinationVal, ok := destinationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be ovhtypes.TfStringValue, was: %T`, destinationAttribute))
	}

	nextHopAttribute, ok := attributes["next_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop is missing from object`)

		return NewSubnetHostRoutesValueUnknown(), diags
	}

	nextHopVal, ok := nextHopAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop expected to be ovhtypes.TfStringValue, was: %T`, nextHopAttribute))
	}

	if diags.HasError() {
		return NewSubnetHostRoutesValueUnknown(), diags
	}

	return SubnetHostRoutesValue{
		Destination: destinationVal,
		NextHop:     nextHopVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSubnetHostRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubnetHostRoutesValue {
	object, diags := NewSubnetHostRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubnetHostRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubnetHostRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubnetHostRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubnetHostRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubnetHostRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubnetHostRoutesValueMust(SubnetHostRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubnetHostRoutesType) ValueType(ctx context.Context) attr.Value {
	return SubnetHostRoutesValue{}
}

var _ basetypes.ObjectValuable = SubnetHostRoutesValue{}

type SubnetHostRoutesValue struct {
	Destination ovhtypes.TfStringValue `tfsdk:"destination" json:"destination"`
	NextHop     ovhtypes.TfStringValue `tfsdk:"next_hop" json:"nextHop"`
	state       attr.ValueState
}

type SubnetHostRoutesWritableValue struct {
	*SubnetHostRoutesValue `json:"-"`
	Destination            *ovhtypes.TfStringValue `json:"destination,omitempty"`
	NextHop                *ovhtypes.TfStringValue `json:"nextHop,omitempty"`
}

func (v SubnetHostRoutesValue) ToCreate() *SubnetHostRoutesWritableValue {
	res := &SubnetHostRoutesWritableValue{}

	if !v.Destination.IsNull() {
		res.Destination = &v.Destination
	}

	if !v.NextHop.IsNull() {
		res.NextHop = &v.NextHop
	}

	return res
}

func (v SubnetHostRoutesValue) ToUpdate() *SubnetHostRoutesWritableValue {
	res := &SubnetHostRoutesWritableValue{}

	if !v.Destination.IsNull() {
		res.Destination = &v.Destination
	}

	if !v.NextHop.IsNull() {
		res.NextHop = &v.NextHop
	}

	return res
}

func (v *SubnetHostRoutesValue) UnmarshalJSON(data []byte) error {
	type JsonSubnetHostRoutesValue SubnetHostRoutesValue

	var tmp JsonSubnetHostRoutesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Destination = tmp.Destination
	v.NextHop = tmp.NextHop

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SubnetHostRoutesValue) MergeWith(other *SubnetHostRoutesValue) {

	if (v.Destination.IsUnknown() || v.Destination.IsNull()) && !other.Destination.IsUnknown() {
		v.Destination = other.Destination
	}

	if (v.NextHop.IsUnknown() || v.NextHop.IsNull()) && !other.NextHop.IsUnknown() {
		v.NextHop = other.NextHop
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SubnetHostRoutesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"destination": v.Destination,
		"nextHop":     v.NextHop,
	}
}
func (v SubnetHostRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["destination"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["next_hop"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Destination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination"] = val

		val, err = v.NextHop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_hop"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubnetHostRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubnetHostRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubnetHostRoutesValue) String() string {
	return "SubnetHostRoutesValue"
}

func (v SubnetHostRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"destination": ovhtypes.TfStringType{},
			"next_hop":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"destination": v.Destination,
			"next_hop":    v.NextHop,
		})

	return objVal, diags
}

func (v SubnetHostRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(SubnetHostRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Destination.Equal(other.Destination) {
		return false
	}

	if !v.NextHop.Equal(other.NextHop) {
		return false
	}

	return true
}

func (v SubnetHostRoutesValue) Type(ctx context.Context) attr.Type {
	return SubnetHostRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubnetHostRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"destination": ovhtypes.TfStringType{},
		"next_hop":    ovhtypes.TfStringType{},
	}
}
