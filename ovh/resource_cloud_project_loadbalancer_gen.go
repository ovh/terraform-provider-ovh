// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
)

func CloudProjectLoadbalancerResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"created_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "The UTC date and timestamp when the resource was created",
			MarkdownDescription: "The UTC date and timestamp when the resource was created",
		},
		"description": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Description:         "Description of the loadbalancer",
			MarkdownDescription: "Description of the loadbalancer",
		},
		"flavor_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Loadbalancer flavor id",
			MarkdownDescription: "Loadbalancer flavor id",
		},
		"floating_ip": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "ID of the resource",
					MarkdownDescription: "ID of the resource",
				},
				"ip": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "IP Address of the resource",
					MarkdownDescription: "IP Address of the resource",
				},
			},
			CustomType: FloatingIpType{
				ObjectType: types.ObjectType{
					AttrTypes: FloatingIpValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Information about floating IP",
			MarkdownDescription: "Information about floating IP",
		},
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "ID of the resource",
			MarkdownDescription: "ID of the resource",
		},
		"listeners": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"allowed_cidrs": schema.ListAttribute{
						CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
						Optional:            true,
						Description:         "The allowed CIDRs",
						MarkdownDescription: "The allowed CIDRs",
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplace(),
						},
					},
					"description": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Optional:            true,
						Description:         "The description of the listener",
						MarkdownDescription: "The description of the listener",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Optional:            true,
						Description:         "Name of the listener",
						MarkdownDescription: "Name of the listener",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"pool": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"algorithm": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Description:         "Pool algorithm to split traffic between members",
								MarkdownDescription: "Pool algorithm to split traffic between members",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"leastConnections",
										"roundRobin",
										"sourceIP",
									),
								},
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
							},
							"health_monitor": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"delay": schema.Int64Attribute{
										CustomType:          ovhtypes.TfInt64Type{},
										Optional:            true,
										Description:         "Duration between sending probes to members, in seconds",
										MarkdownDescription: "Duration between sending probes to members, in seconds",
										PlanModifiers: []planmodifier.Int64{
											int64planmodifier.RequiresReplace(),
										},
									},
									"http_configuration": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"domain_name": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Optional:            true,
												Computed:            true,
												Description:         "Domain name, which be injected into the HTTP Host Header to the backend server for HTTP health check",
												MarkdownDescription: "Domain name, which be injected into the HTTP Host Header to the backend server for HTTP health check",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
											},
											"expected_codes": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Optional:            true,
												Computed:            true,
												Description:         "Status codes expected in response from the member to declare it healthy; The list of HTTP status codes expected in response from the member to declare it healthy. Specify one of the following values: * A single value, such as 200; * A list, such as 200, 202; * A range, such as 200-204",
												MarkdownDescription: "Status codes expected in response from the member to declare it healthy; The list of HTTP status codes expected in response from the member to declare it healthy. Specify one of the following values: * A single value, such as 200; * A list, such as 200, 202; * A range, such as 200-204",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
											},
											"http_method": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Optional:            true,
												Description:         "HTTP method that the health monitor uses for requests",
												MarkdownDescription: "HTTP method that the health monitor uses for requests",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CONNECT",
														"DELETE",
														"GET",
														"HEAD",
														"OPTIONS",
														"PATCH",
														"POST",
														"PUT",
														"TRACE",
													),
												},
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
											},
											"http_version": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Optional:            true,
												Computed:            true,
												Description:         "HTTP version that the health monitor uses for requests",
												MarkdownDescription: "HTTP version that the health monitor uses for requests",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"1.0",
														"1.1",
													),
												},
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
											},
											"url_path": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Optional:            true,
												Computed:            true,
												Description:         "HTTP URL path of the request sent by the monitor to test the health of a backend member",
												MarkdownDescription: "HTTP URL path of the request sent by the monitor to test the health of a backend member",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
											},
										},
										CustomType: ListenersPoolHealthMonitorHttpConfigurationType{
											ObjectType: types.ObjectType{
												AttrTypes: ListenersPoolHealthMonitorHttpConfigurationValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Monitor HTTP configuration",
										MarkdownDescription: "Monitor HTTP configuration",
									},
									"max_retries": schema.Int64Attribute{
										CustomType:          ovhtypes.TfInt64Type{},
										Optional:            true,
										Description:         "Number of successful checks before changing the operating status of the member to ONLINE",
										MarkdownDescription: "Number of successful checks before changing the operating status of the member to ONLINE",
										PlanModifiers: []planmodifier.Int64{
											int64planmodifier.RequiresReplace(),
										},
									},
									"max_retries_down": schema.Int64Attribute{
										CustomType:          ovhtypes.TfInt64Type{},
										Optional:            true,
										Computed:            true,
										Description:         "Number of allowed check failures before changing the operating status of the member to ERROR",
										MarkdownDescription: "Number of allowed check failures before changing the operating status of the member to ERROR",
										PlanModifiers: []planmodifier.Int64{
											int64planmodifier.RequiresReplace(),
										},
									},
									"monitor_type": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Description:         "Type of the monitor",
										MarkdownDescription: "Type of the monitor",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"http",
												"https",
												"ping",
												"sctp",
												"tcp",
												"tls-hello",
												"udp-connect",
											),
										},
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
									"name": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Description:         "The name of the resource",
										MarkdownDescription: "The name of the resource",
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
									"operating_status": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "The operating status of the resource",
										MarkdownDescription: "The operating status of the resource",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"degraded",
												"draining",
												"error",
												"noMonitor",
												"offline",
												"online",
											),
										},
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
									"provisioning_status": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "The provisioning status of the resource",
										MarkdownDescription: "The provisioning status of the resource",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"active",
												"creating",
												"deleted",
												"deleting",
												"error",
												"updating",
											),
										},
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
									"timeout": schema.Int64Attribute{
										CustomType:          ovhtypes.TfInt64Type{},
										Optional:            true,
										Description:         "Maximum time, in seconds, that a monitor waits to connect before it times out. This value must be less than the delay value",
										MarkdownDescription: "Maximum time, in seconds, that a monitor waits to connect before it times out. This value must be less than the delay value",
										PlanModifiers: []planmodifier.Int64{
											int64planmodifier.RequiresReplace(),
										},
									},
								},
								CustomType: ListenersPoolHealthMonitorType{
									ObjectType: types.ObjectType{
										AttrTypes: ListenersPoolHealthMonitorValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Pool health monitor",
								MarkdownDescription: "Pool health monitor",
							},
							"members": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"address": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Optional:            true,
											Description:         "IP address of the resource",
											MarkdownDescription: "IP address of the resource",
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplace(),
											},
										},
										"name": schema.StringAttribute{
											CustomType:          ovhtypes.TfStringType{},
											Optional:            true,
											Computed:            true,
											Description:         "Name of the member",
											MarkdownDescription: "Name of the member",
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplace(),
											},
										},
										"protocol_port": schema.Int64Attribute{
											CustomType:          ovhtypes.TfInt64Type{},
											Optional:            true,
											Description:         "Protocol port number for the resource",
											MarkdownDescription: "Protocol port number for the resource",
											PlanModifiers: []planmodifier.Int64{
												int64planmodifier.RequiresReplace(),
											},
										},
										"weight": schema.Int64Attribute{
											CustomType:          ovhtypes.TfInt64Type{},
											Optional:            true,
											Computed:            true,
											Description:         "Weight of a member determines the portion of requests or connections it services compared to the other members of the pool. Between 1 and 256.",
											MarkdownDescription: "Weight of a member determines the portion of requests or connections it services compared to the other members of the pool. Between 1 and 256.",
											PlanModifiers: []planmodifier.Int64{
												int64planmodifier.RequiresReplace(),
											},
										},
									},
									CustomType: ListenersPoolMembersType{
										ObjectType: types.ObjectType{
											AttrTypes: ListenersPoolMembersValue{}.AttributeTypes(ctx),
										},
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplace(),
									},
								},
								CustomType:          ovhtypes.NewTfListNestedType[ListenersPoolMembersValue](ctx),
								Optional:            true,
								Computed:            true,
								Description:         "Pool members",
								MarkdownDescription: "Pool members",
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplace(),
								},
							},
							"name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Name of the pool",
								MarkdownDescription: "Name of the pool",
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
							},
							"protocol": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Description:         "Protocol for the pool",
								MarkdownDescription: "Protocol for the pool",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"http",
										"https",
										"proxy",
										"proxyV2",
										"sctp",
										"tcp",
										"udp",
									),
								},
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
							},
							"session_persistence": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"cookie_name": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Cookie name, only applicable to session persistence through cookie",
										MarkdownDescription: "Cookie name, only applicable to session persistence through cookie",
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
									"type": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Type of session persistence",
										MarkdownDescription: "Type of session persistence",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"appCookie",
												"disabled",
												"httpCookie",
												"sourceIP",
											),
										},
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
								},
								CustomType: ListenersPoolSessionPersistenceType{
									ObjectType: types.ObjectType{
										AttrTypes: ListenersPoolSessionPersistenceValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Pool session persistence",
								MarkdownDescription: "Pool session persistence",
							},
						},
						CustomType: ListenersPoolType{
							ObjectType: types.ObjectType{
								AttrTypes: ListenersPoolValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Listener pool",
						MarkdownDescription: "Listener pool",
					},
					"port": schema.Int64Attribute{
						CustomType:          ovhtypes.TfInt64Type{},
						Required:            true,
						Description:         "Listener port",
						MarkdownDescription: "Listener port",
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplace(),
						},
					},
					"protocol": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Required:            true,
						Description:         "Protocol for the listener",
						MarkdownDescription: "Protocol for the listener",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"http",
								"https",
								"prometheus",
								"sctp",
								"tcp",
								"terminatedHTTPS",
								"udp",
							),
						},
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"secret_id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Optional:            true,
						Description:         "Secret ID to get certificate for SSL listener creation",
						MarkdownDescription: "Secret ID to get certificate for SSL listener creation",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"timeout_client_data": schema.Int64Attribute{
						CustomType:          ovhtypes.TfInt64Type{},
						Optional:            true,
						Description:         "Timeout client data of the listener",
						MarkdownDescription: "Timeout client data of the listener",
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplace(),
						},
					},
					"timeout_member_data": schema.Int64Attribute{
						CustomType:          ovhtypes.TfInt64Type{},
						Optional:            true,
						Description:         "Timeout member data of the listener",
						MarkdownDescription: "Timeout member data of the listener",
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplace(),
						},
					},
					"tls_versions": schema.ListAttribute{
						CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
						Optional:            true,
						Description:         "TLS versions of the listener",
						MarkdownDescription: "TLS versions of the listener",
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplace(),
						},
					},
				},
				CustomType: ListenersType{
					ObjectType: types.ObjectType{
						AttrTypes: ListenersValue{}.AttributeTypes(ctx),
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[ListenersValue](ctx),
			Optional:            true,
			Description:         "Listeners to create with the loadbalancer",
			MarkdownDescription: "Listeners to create with the loadbalancer",
		},
		"name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Name of the resource",
			MarkdownDescription: "Name of the resource",
		},
		"network": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"private": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"floating_ip": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Optional:            true,
									Description:         "ID of the floatingIp",
									MarkdownDescription: "ID of the floatingIp",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
							},
							CustomType: NetworkPrivateFloatingIpType{
								ObjectType: types.ObjectType{
									AttrTypes: NetworkPrivateFloatingIpValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Floating IP to associate",
							MarkdownDescription: "Floating IP to associate",
						},
						"floating_ip_create": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Optional:            true,
									Description:         "Description for the floatingIp",
									MarkdownDescription: "Description for the floatingIp",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
							},
							CustomType: NetworkPrivateFloatingIpCreateType{
								ObjectType: types.ObjectType{
									AttrTypes: NetworkPrivateFloatingIpCreateValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Floating IP to create",
							MarkdownDescription: "Floating IP to create",
						},
						"gateway": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Optional:            true,
									Description:         "ID of the gateway",
									MarkdownDescription: "ID of the gateway",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
							},
							CustomType: NetworkPrivateGatewayType{
								ObjectType: types.ObjectType{
									AttrTypes: NetworkPrivateGatewayValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Gateway to associate",
							MarkdownDescription: "Gateway to associate",
						},
						"gateway_create": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"model": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Optional:            true,
									Description:         "Model of the gateway",
									MarkdownDescription: "Model of the gateway",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"2xl",
											"3xl",
											"l",
											"m",
											"s",
											"xl",
										),
									},
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
								"name": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Optional:            true,
									Description:         "Name of the gateway",
									MarkdownDescription: "Name of the gateway",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
							},
							CustomType: NetworkPrivateGatewayCreateType{
								ObjectType: types.ObjectType{
									AttrTypes: NetworkPrivateGatewayCreateValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Gateway to create",
							MarkdownDescription: "Gateway to create",
						},
						"network": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Required:            true,
									Description:         "Private network ID",
									MarkdownDescription: "Private network ID",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
								"subnet_id": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Required:            true,
									Description:         "Subnet ID",
									MarkdownDescription: "Subnet ID",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
							},
							CustomType: NetworkPrivateNetworkType{
								ObjectType: types.ObjectType{
									AttrTypes: NetworkPrivateNetworkValue{}.AttributeTypes(ctx),
								},
							},
							Required:            true,
							Description:         "Network to associate",
							MarkdownDescription: "Network to associate",
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplace(),
							},
						},
					},
					CustomType: NetworkPrivateType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworkPrivateValue{}.AttributeTypes(ctx),
						},
					},
					Required:            true,
					Description:         "Information to private network",
					MarkdownDescription: "Information to private network",
					PlanModifiers: []planmodifier.Object{
						objectplanmodifier.RequiresReplace(),
					},
				},
			},
			CustomType: NetworkType{
				ObjectType: types.ObjectType{
					AttrTypes: NetworkValue{}.AttributeTypes(ctx),
				},
			},
			Required:            true,
			Description:         "Network information to create the loadbalancer",
			MarkdownDescription: "Network information to create the loadbalancer",
			PlanModifiers: []planmodifier.Object{
				objectplanmodifier.RequiresReplace(),
			},
		},
		"operating_status": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Operating status of the resource",
			MarkdownDescription: "Operating status of the resource",
		},
		"provisioning_status": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Provisioning status of the resource",
			MarkdownDescription: "Provisioning status of the resource",
		},
		"region": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Region of the resource",
			MarkdownDescription: "Region of the resource",
		},
		"region_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Region name",
			MarkdownDescription: "Region name",
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"service_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Service name",
			MarkdownDescription: "Service name",
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"updated_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "UTC date and timestamp when the resource was created",
			MarkdownDescription: "UTC date and timestamp when the resource was created",
		},
		"vip_address": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "IP address of the Virtual IP",
			MarkdownDescription: "IP address of the Virtual IP",
		},
		"vip_network_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Openstack ID of the network for the Virtual IP",
			MarkdownDescription: "Openstack ID of the network for the Virtual IP",
		},
		"vip_subnet_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "ID of the subnet for the Virtual IP",
			MarkdownDescription: "ID of the subnet for the Virtual IP",
		},
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type CloudProjectRegionLoadbalancerModel struct {
	CreatedAt          ovhtypes.TfStringValue                     `tfsdk:"created_at" json:"createdAt"`
	Description        ovhtypes.TfStringValue                     `tfsdk:"description" json:"description"`
	FlavorId           ovhtypes.TfStringValue                     `tfsdk:"flavor_id" json:"flavorId"`
	FloatingIp         FloatingIpValue                            `tfsdk:"floating_ip" json:"floatingIp"`
	Id                 ovhtypes.TfStringValue                     `tfsdk:"id" json:"id"`
	Listeners          ovhtypes.TfListNestedValue[ListenersValue] `tfsdk:"listeners" json:"listeners"`
	Name               ovhtypes.TfStringValue                     `tfsdk:"name" json:"name"`
	Network            NetworkValue                               `tfsdk:"network" json:"network"`
	OperatingStatus    ovhtypes.TfStringValue                     `tfsdk:"operating_status" json:"operatingStatus"`
	ProvisioningStatus ovhtypes.TfStringValue                     `tfsdk:"provisioning_status" json:"provisioningStatus"`
	Region             ovhtypes.TfStringValue                     `tfsdk:"region" json:"region"`
	RegionName         ovhtypes.TfStringValue                     `tfsdk:"region_name" json:"regionName"`
	ServiceName        ovhtypes.TfStringValue                     `tfsdk:"service_name" json:"serviceName"`
	UpdatedAt          ovhtypes.TfStringValue                     `tfsdk:"updated_at" json:"updatedAt"`
	VipAddress         ovhtypes.TfStringValue                     `tfsdk:"vip_address" json:"vipAddress"`
	VipNetworkId       ovhtypes.TfStringValue                     `tfsdk:"vip_network_id" json:"vipNetworkId"`
	VipSubnetId        ovhtypes.TfStringValue                     `tfsdk:"vip_subnet_id" json:"vipSubnetId"`
}

func (v *CloudProjectRegionLoadbalancerModel) MergeWith(other *CloudProjectRegionLoadbalancerModel) {
	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.FlavorId.IsUnknown() || v.FlavorId.IsNull()) && !other.FlavorId.IsUnknown() {
		v.FlavorId = other.FlavorId
	}

	if v.FloatingIp.IsUnknown() && !other.FloatingIp.IsUnknown() {
		v.FloatingIp = other.FloatingIp
	} else if !other.FloatingIp.IsUnknown() {
		v.FloatingIp.MergeWith(&other.FloatingIp)
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Listeners.IsUnknown() || v.Listeners.IsNull()) && !other.Listeners.IsUnknown() {
		v.Listeners = other.Listeners
	} else if !other.Listeners.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Listeners.Elements()
		newElems := other.Listeners.Elements()

		if len(elems) != len(newElems) {
			v.Listeners = other.Listeners
		} else {
			for idx, e := range elems {
				tmp := e.(ListenersValue)
				tmp2 := newElems[idx].(ListenersValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Listeners = ovhtypes.TfListNestedValue[ListenersValue]{
				ListValue: basetypes.NewListValueMust(ListenersValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if v.Network.IsUnknown() && !other.Network.IsUnknown() {
		v.Network = other.Network
	} else if !other.Network.IsUnknown() {
		v.Network.MergeWith(&other.Network)
	}

	if (v.OperatingStatus.IsUnknown() || v.OperatingStatus.IsNull()) && !other.OperatingStatus.IsUnknown() {
		v.OperatingStatus = other.OperatingStatus
	}

	if (v.ProvisioningStatus.IsUnknown() || v.ProvisioningStatus.IsNull()) && !other.ProvisioningStatus.IsUnknown() {
		v.ProvisioningStatus = other.ProvisioningStatus
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.RegionName.IsUnknown() || v.RegionName.IsNull()) && !other.RegionName.IsUnknown() {
		v.RegionName = other.RegionName
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

	if (v.VipAddress.IsUnknown() || v.VipAddress.IsNull()) && !other.VipAddress.IsUnknown() {
		v.VipAddress = other.VipAddress
	}

	if (v.VipNetworkId.IsUnknown() || v.VipNetworkId.IsNull()) && !other.VipNetworkId.IsUnknown() {
		v.VipNetworkId = other.VipNetworkId
	}

	if (v.VipSubnetId.IsUnknown() || v.VipSubnetId.IsNull()) && !other.VipSubnetId.IsUnknown() {
		v.VipSubnetId = other.VipSubnetId
	}

}

type CloudProjectRegionLoadbalancerWritableModel struct {
	Description *ovhtypes.TfStringValue   `tfsdk:"description" json:"description,omitempty"`
	FlavorId    *ovhtypes.TfStringValue   `tfsdk:"flavor_id" json:"flavorId,omitempty"`
	Listeners   []*ListenersWritableValue `tfsdk:"listeners" json:"listeners,omitempty"`
	Name        *ovhtypes.TfStringValue   `tfsdk:"name" json:"name,omitempty"`
	Network     *NetworkWritableValue     `tfsdk:"network" json:"network,omitempty"`
}

func (v CloudProjectRegionLoadbalancerModel) ToCreate() *CloudProjectRegionLoadbalancerWritableModel {
	res := &CloudProjectRegionLoadbalancerWritableModel{}

	if !v.FlavorId.IsUnknown() {
		res.FlavorId = &v.FlavorId
	}

	if !v.Listeners.IsUnknown() && !v.Listeners.IsNull() {
		for _, elem := range v.Listeners.Elements() {
			res.Listeners = append(res.Listeners, elem.(ListenersValue).ToCreate())
		}
	}

	if !v.Name.IsUnknown() {
		res.Name = &v.Name
	}

	if !v.Network.IsUnknown() {
		res.Network = v.Network.ToCreate()
	}

	return res
}

func (v CloudProjectRegionLoadbalancerModel) ToUpdate() *CloudProjectRegionLoadbalancerWritableModel {
	res := &CloudProjectRegionLoadbalancerWritableModel{}

	if !v.Description.IsUnknown() && !v.Description.IsNull() {
		res.Description = &v.Description
	}

	if !v.FlavorId.IsUnknown() {
		res.FlavorId = &v.FlavorId
	}

	if !v.Name.IsUnknown() && !v.Name.IsNull() {
		res.Name = &v.Name
	}

	return res
}

var _ basetypes.ObjectTypable = ListenersType{}

type ListenersType struct {
	basetypes.ObjectType
}

func (t ListenersType) Equal(o attr.Type) bool {
	other, ok := o.(ListenersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenersType) String() string {
	return "ListenersType"
}

func (t ListenersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedCidrsAttribute, ok := attributes["allowed_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_cidrs is missing from object`)

		return nil, diags
	}

	allowedCidrsVal, ok := allowedCidrsAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_cidrs expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, allowedCidrsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	poolAttribute, ok := attributes["pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool is missing from object`)

		return nil, diags
	}

	poolVal, ok := poolAttribute.(ListenersPoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool expected to be ListenersPoolValue, was: %T`, poolAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be ovhtypes.TfInt64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be ovhtypes.TfStringValue, was: %T`, protocolAttribute))
	}

	secretIdAttribute, ok := attributes["secret_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_id is missing from object`)

		return nil, diags
	}

	secretIdVal, ok := secretIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_id expected to be ovhtypes.TfStringValue, was: %T`, secretIdAttribute))
	}

	timeoutClientDataAttribute, ok := attributes["timeout_client_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_client_data is missing from object`)

		return nil, diags
	}

	timeoutClientDataVal, ok := timeoutClientDataAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_client_data expected to be ovhtypes.TfInt64Value, was: %T`, timeoutClientDataAttribute))
	}

	timeoutMemberDataAttribute, ok := attributes["timeout_member_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_member_data is missing from object`)

		return nil, diags
	}

	timeoutMemberDataVal, ok := timeoutMemberDataAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_member_data expected to be ovhtypes.TfInt64Value, was: %T`, timeoutMemberDataAttribute))
	}

	tlsVersionsAttribute, ok := attributes["tls_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls_versions is missing from object`)

		return nil, diags
	}

	tlsVersionsVal, ok := tlsVersionsAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls_versions expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, tlsVersionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	state := attr.ValueStateKnown
	if in.IsNull() {
		state = attr.ValueStateNull
	} else if in.IsUnknown() {
		state = attr.ValueStateUnknown
	}

	return ListenersValue{
		AllowedCidrs:      allowedCidrsVal,
		Description:       descriptionVal,
		Name:              nameVal,
		Pool:              poolVal,
		Port:              portVal,
		Protocol:          protocolVal,
		SecretId:          secretIdVal,
		TimeoutClientData: timeoutClientDataVal,
		TimeoutMemberData: timeoutMemberDataVal,
		TlsVersions:       tlsVersionsVal,
		state:             state,
	}, diags
}

func NewListenersValueNull() ListenersValue {
	return ListenersValue{
		state: attr.ValueStateNull,
	}
}

func NewListenersValueUnknown() ListenersValue {
	return ListenersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenersValue Attribute Value",
				"While creating a ListenersValue value, a missing attribute value was detected. "+
					"A ListenersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenersValue Attribute Type",
				"While creating a ListenersValue value, an invalid attribute value was detected. "+
					"A ListenersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenersValue Attribute Value",
				"While creating a ListenersValue value, an extra attribute value was detected. "+
					"A ListenersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenersValueUnknown(), diags
	}

	allowedCidrsAttribute, ok := attributes["allowed_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_cidrs is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	allowedCidrsVal, ok := allowedCidrsAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_cidrs expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, allowedCidrsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	poolAttribute, ok := attributes["pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	poolVal, ok := poolAttribute.(ListenersPoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool expected to be ListenersPoolValue, was: %T`, poolAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be ovhtypes.TfInt64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be ovhtypes.TfStringValue, was: %T`, protocolAttribute))
	}

	secretIdAttribute, ok := attributes["secret_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_id is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	secretIdVal, ok := secretIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_id expected to be ovhtypes.TfStringValue, was: %T`, secretIdAttribute))
	}

	timeoutClientDataAttribute, ok := attributes["timeout_client_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_client_data is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	timeoutClientDataVal, ok := timeoutClientDataAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_client_data expected to be ovhtypes.TfInt64Value, was: %T`, timeoutClientDataAttribute))
	}

	timeoutMemberDataAttribute, ok := attributes["timeout_member_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_member_data is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	timeoutMemberDataVal, ok := timeoutMemberDataAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_member_data expected to be ovhtypes.TfInt64Value, was: %T`, timeoutMemberDataAttribute))
	}

	tlsVersionsAttribute, ok := attributes["tls_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls_versions is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	tlsVersionsVal, ok := tlsVersionsAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls_versions expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, tlsVersionsAttribute))
	}

	if diags.HasError() {
		return NewListenersValueUnknown(), diags
	}

	return ListenersValue{
		AllowedCidrs:      allowedCidrsVal,
		Description:       descriptionVal,
		Name:              nameVal,
		Pool:              poolVal,
		Port:              portVal,
		Protocol:          protocolVal,
		SecretId:          secretIdVal,
		TimeoutClientData: timeoutClientDataVal,
		TimeoutMemberData: timeoutMemberDataVal,
		TlsVersions:       tlsVersionsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewListenersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenersValue {
	object, diags := NewListenersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)
		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenersValueMust(ListenersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenersType) ValueType(ctx context.Context) attr.Value {
	return ListenersValue{}
}

var _ basetypes.ObjectValuable = ListenersValue{}

type ListenersValue struct {
	AllowedCidrs      ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"allowed_cidrs" json:"allowedCidrs"`
	Description       ovhtypes.TfStringValue                             `tfsdk:"description" json:"description"`
	Name              ovhtypes.TfStringValue                             `tfsdk:"name" json:"name"`
	Pool              ListenersPoolValue                                 `tfsdk:"pool" json:"pool"`
	Port              ovhtypes.TfInt64Value                              `tfsdk:"port" json:"port"`
	Protocol          ovhtypes.TfStringValue                             `tfsdk:"protocol" json:"protocol"`
	SecretId          ovhtypes.TfStringValue                             `tfsdk:"secret_id" json:"secretId"`
	TimeoutClientData ovhtypes.TfInt64Value                              `tfsdk:"timeout_client_data" json:"timeoutClientData"`
	TimeoutMemberData ovhtypes.TfInt64Value                              `tfsdk:"timeout_member_data" json:"timeoutMemberData"`
	TlsVersions       ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"tls_versions" json:"tlsVersions"`
	state             attr.ValueState
}

type ListenersWritableValue struct {
	AllowedCidrs      *ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `json:"allowedCidrs,omitempty"`
	Description       *ovhtypes.TfStringValue                             `json:"description,omitempty"`
	Name              *ovhtypes.TfStringValue                             `json:"name,omitempty"`
	Pool              *ListenersPoolValue                                 `json:"pool,omitempty"`
	Port              *ovhtypes.TfInt64Value                              `json:"port,omitempty"`
	Protocol          *ovhtypes.TfStringValue                             `json:"protocol,omitempty"`
	SecretId          *ovhtypes.TfStringValue                             `json:"secretId,omitempty"`
	TimeoutClientData *ovhtypes.TfInt64Value                              `json:"timeoutClientData,omitempty"`
	TimeoutMemberData *ovhtypes.TfInt64Value                              `json:"timeoutMemberData,omitempty"`
	TlsVersions       *ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `json:"tlsVersions,omitempty"`
	state             attr.ValueState
}

func (v ListenersValue) ToCreate() *ListenersWritableValue {
	res := &ListenersWritableValue{}

	if !v.Protocol.IsUnknown() && !v.Protocol.IsNull() {
		res.Protocol = &v.Protocol
	}

	if !v.TimeoutMemberData.IsUnknown() && !v.TimeoutMemberData.IsNull() {
		res.TimeoutMemberData = &v.TimeoutMemberData
	}

	if !v.Port.IsUnknown() && !v.Port.IsNull() {
		res.Port = &v.Port
	}

	if !v.AllowedCidrs.IsUnknown() && !v.AllowedCidrs.IsNull() {
		res.AllowedCidrs = &v.AllowedCidrs
	}

	if !v.Pool.IsUnknown() && !v.Pool.IsNull() {
		res.Pool = &v.Pool
	}

	if !v.TimeoutClientData.IsUnknown() && !v.TimeoutClientData.IsNull() {
		res.TimeoutClientData = &v.TimeoutClientData
	}

	if !v.Description.IsUnknown() && !v.Description.IsNull() {
		res.Description = &v.Description
	}

	if !v.Name.IsUnknown() && !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.SecretId.IsUnknown() && !v.SecretId.IsNull() {
		res.SecretId = &v.SecretId
	}

	if !v.TlsVersions.IsUnknown() && !v.TlsVersions.IsNull() {
		res.TlsVersions = &v.TlsVersions
	}

	return res
}

func (v *ListenersValue) UnmarshalJSON(data []byte) error {
	type JsonListenersValue ListenersValue

	var tmp JsonListenersValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.AllowedCidrs = tmp.AllowedCidrs
	v.Description = tmp.Description
	v.Name = tmp.Name
	v.Pool = tmp.Pool
	v.Port = tmp.Port
	v.Protocol = tmp.Protocol
	v.SecretId = tmp.SecretId
	v.TimeoutClientData = tmp.TimeoutClientData
	v.TimeoutMemberData = tmp.TimeoutMemberData
	v.TlsVersions = tmp.TlsVersions

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ListenersValue) MergeWith(other *ListenersValue) {

	if (v.AllowedCidrs.IsUnknown() || v.AllowedCidrs.IsNull()) && !other.AllowedCidrs.IsUnknown() {
		v.AllowedCidrs = other.AllowedCidrs
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if v.Pool.IsUnknown() && !other.Pool.IsUnknown() {
		v.Pool = other.Pool
	} else if !other.Pool.IsUnknown() {
		v.Pool.MergeWith(&other.Pool)
	}

	if (v.Port.IsUnknown() || v.Port.IsNull()) && !other.Port.IsUnknown() {
		v.Port = other.Port
	}

	if (v.Protocol.IsUnknown() || v.Protocol.IsNull()) && !other.Protocol.IsUnknown() {
		v.Protocol = other.Protocol
	}

	if (v.SecretId.IsUnknown() || v.SecretId.IsNull()) && !other.SecretId.IsUnknown() {
		v.SecretId = other.SecretId
	}

	if (v.TimeoutClientData.IsUnknown() || v.TimeoutClientData.IsNull()) && !other.TimeoutClientData.IsUnknown() {
		v.TimeoutClientData = other.TimeoutClientData
	}

	if (v.TimeoutMemberData.IsUnknown() || v.TimeoutMemberData.IsNull()) && !other.TimeoutMemberData.IsUnknown() {
		v.TimeoutMemberData = other.TimeoutMemberData
	}

	if (v.TlsVersions.IsUnknown() || v.TlsVersions.IsNull()) && !other.TlsVersions.IsUnknown() {
		v.TlsVersions = other.TlsVersions
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ListenersValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"allowedCidrs":      v.AllowedCidrs,
		"description":       v.Description,
		"name":              v.Name,
		"pool":              v.Pool,
		"port":              v.Port,
		"protocol":          v.Protocol,
		"secretId":          v.SecretId,
		"timeoutClientData": v.TimeoutClientData,
		"timeoutMemberData": v.TimeoutMemberData,
		"tlsVersions":       v.TlsVersions,
	}
}

func (v ListenersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["allowed_cidrs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pool"] = basetypes.ObjectType{
		AttrTypes: ListenersPoolValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout_client_data"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timeout_member_data"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tls_versions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AllowedCidrs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_cidrs"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Pool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pool"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.SecretId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret_id"] = val

		val, err = v.TimeoutClientData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout_client_data"] = val

		val, err = v.TimeoutMemberData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout_member_data"] = val

		val, err = v.TlsVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tls_versions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenersValue) String() string {
	return "ListenersValue"
}

func (v ListenersWritableValue) String() string {
	return "ListenersWritableValue"
}

func (v ListenersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"allowed_cidrs": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
			"description":   ovhtypes.TfStringType{},
			"name":          ovhtypes.TfStringType{},
			"pool": ListenersPoolType{
				basetypes.ObjectType{
					AttrTypes: ListenersPoolValue{}.AttributeTypes(ctx),
				},
			},
			"port":                ovhtypes.TfInt64Type{},
			"protocol":            ovhtypes.TfStringType{},
			"secret_id":           ovhtypes.TfStringType{},
			"timeout_client_data": ovhtypes.TfInt64Type{},
			"timeout_member_data": ovhtypes.TfInt64Type{},
			"tls_versions":        ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		},
		map[string]attr.Value{
			"allowed_cidrs":       v.AllowedCidrs,
			"description":         v.Description,
			"name":                v.Name,
			"pool":                v.Pool,
			"port":                v.Port,
			"protocol":            v.Protocol,
			"secret_id":           v.SecretId,
			"timeout_client_data": v.TimeoutClientData,
			"timeout_member_data": v.TimeoutMemberData,
			"tls_versions":        v.TlsVersions,
		})

	return objVal, diags
}

func (v ListenersValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedCidrs.Equal(other.AllowedCidrs) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Pool.Equal(other.Pool) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.SecretId.Equal(other.SecretId) {
		return false
	}

	if !v.TimeoutClientData.Equal(other.TimeoutClientData) {
		return false
	}

	if !v.TimeoutMemberData.Equal(other.TimeoutMemberData) {
		return false
	}

	if !v.TlsVersions.Equal(other.TlsVersions) {
		return false
	}

	return true
}

func (v ListenersValue) Type(ctx context.Context) attr.Type {
	return ListenersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_cidrs":       ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		"description":         ovhtypes.TfStringType{},
		"name":                ovhtypes.TfStringType{},
		"pool":                ListenersPoolValue{}.Type(ctx),
		"port":                ovhtypes.TfInt64Type{},
		"protocol":            ovhtypes.TfStringType{},
		"secret_id":           ovhtypes.TfStringType{},
		"timeout_client_data": ovhtypes.TfInt64Type{},
		"timeout_member_data": ovhtypes.TfInt64Type{},
		"tls_versions":        ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
	}
}

var _ basetypes.ObjectTypable = ListenersPoolType{}

type ListenersPoolType struct {
	basetypes.ObjectType
}

func (t ListenersPoolType) Equal(o attr.Type) bool {
	other, ok := o.(ListenersPoolType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenersPoolType) String() string {
	return "ListenersPoolType"
}

func (t ListenersPoolType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	algorithmAttribute, ok := attributes["algorithm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`algorithm is missing from object`)

		return nil, diags
	}

	algorithmVal, ok := algorithmAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`algorithm expected to be ovhtypes.TfStringValue, was: %T`, algorithmAttribute))
	}

	healthMonitorAttribute, ok := attributes["health_monitor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_monitor is missing from object`)

		return nil, diags
	}

	healthMonitorVal, ok := healthMonitorAttribute.(ListenersPoolHealthMonitorValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_monitor expected to be ListenersPoolHealthMonitorValue, was: %T`, healthMonitorAttribute))
	}

	membersAttribute, ok := attributes["members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members is missing from object`)

		return nil, diags
	}

	membersVal, ok := membersAttribute.(ovhtypes.TfListNestedValue[ListenersPoolMembersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members expected to be ovhtypes.TfListNestedValue[ListenersPoolMembersValue], was: %T`, membersAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be ovhtypes.TfStringValue, was: %T`, protocolAttribute))
	}

	sessionPersistenceAttribute, ok := attributes["session_persistence"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`session_persistence is missing from object`)

		return nil, diags
	}

	sessionPersistenceVal, ok := sessionPersistenceAttribute.(ListenersPoolSessionPersistenceValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`session_persistence expected to be ListenersPoolSessionPersistenceValue, was: %T`, sessionPersistenceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	state := attr.ValueStateKnown
	if in.IsNull() {
		state = attr.ValueStateNull
	} else if in.IsUnknown() {
		state = attr.ValueStateUnknown
	}

	return ListenersPoolValue{
		Algorithm:          algorithmVal,
		HealthMonitor:      healthMonitorVal,
		Members:            membersVal,
		Name:               nameVal,
		Protocol:           protocolVal,
		SessionPersistence: sessionPersistenceVal,
		state:              state,
	}, diags
}

func NewListenersPoolValueNull() ListenersPoolValue {
	return ListenersPoolValue{
		state: attr.ValueStateNull,
	}
}

func NewListenersPoolValueUnknown() ListenersPoolValue {
	return ListenersPoolValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenersPoolValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenersPoolValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenersPoolValue Attribute Value",
				"While creating a ListenersPoolValue value, a missing attribute value was detected. "+
					"A ListenersPoolValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenersPoolValue Attribute Type",
				"While creating a ListenersPoolValue value, an invalid attribute value was detected. "+
					"A ListenersPoolValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenersPoolValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenersPoolValue Attribute Value",
				"While creating a ListenersPoolValue value, an extra attribute value was detected. "+
					"A ListenersPoolValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenersPoolValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenersPoolValueUnknown(), diags
	}

	algorithmAttribute, ok := attributes["algorithm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`algorithm is missing from object`)

		return NewListenersPoolValueUnknown(), diags
	}

	algorithmVal, ok := algorithmAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`algorithm expected to be ovhtypes.TfStringValue, was: %T`, algorithmAttribute))
	}

	healthMonitorAttribute, ok := attributes["health_monitor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_monitor is missing from object`)

		return NewListenersPoolValueUnknown(), diags
	}

	healthMonitorVal, ok := healthMonitorAttribute.(ListenersPoolHealthMonitorValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_monitor expected to be ListenersPoolHealthMonitorValue, was: %T`, healthMonitorAttribute))
	}

	membersAttribute, ok := attributes["members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members is missing from object`)

		return NewListenersPoolValueUnknown(), diags
	}

	membersVal, ok := membersAttribute.(ovhtypes.TfListNestedValue[ListenersPoolMembersValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members expected to be ovhtypes.TfListNestedValue[ListenersPoolMembersValue], was: %T`, membersAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewListenersPoolValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewListenersPoolValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be ovhtypes.TfStringValue, was: %T`, protocolAttribute))
	}

	sessionPersistenceAttribute, ok := attributes["session_persistence"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`session_persistence is missing from object`)

		return NewListenersPoolValueUnknown(), diags
	}

	sessionPersistenceVal, ok := sessionPersistenceAttribute.(ListenersPoolSessionPersistenceValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`session_persistence expected to be ListenersPoolSessionPersistenceValue, was: %T`, sessionPersistenceAttribute))
	}

	if diags.HasError() {
		return NewListenersPoolValueUnknown(), diags
	}

	return ListenersPoolValue{
		Algorithm:          algorithmVal,
		HealthMonitor:      healthMonitorVal,
		Members:            membersVal,
		Name:               nameVal,
		Protocol:           protocolVal,
		SessionPersistence: sessionPersistenceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenersPoolValue {
	object, diags := NewListenersPoolValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenersPoolValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenersPoolType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenersPoolValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenersPoolValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenersPoolValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenersPoolValueMust(ListenersPoolValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenersPoolType) ValueType(ctx context.Context) attr.Value {
	return ListenersPoolValue{}
}

var _ basetypes.ObjectValuable = ListenersPoolValue{}

type ListenersPoolValue struct {
	Algorithm          ovhtypes.TfStringValue                                `tfsdk:"algorithm" json:"algorithm"`
	HealthMonitor      ListenersPoolHealthMonitorValue                       `tfsdk:"health_monitor" json:"healthMonitor"`
	Members            ovhtypes.TfListNestedValue[ListenersPoolMembersValue] `tfsdk:"members" json:"members"`
	Name               ovhtypes.TfStringValue                                `tfsdk:"name" json:"name"`
	Protocol           ovhtypes.TfStringValue                                `tfsdk:"protocol" json:"protocol"`
	SessionPersistence ListenersPoolSessionPersistenceValue                  `tfsdk:"session_persistence" json:"sessionPersistence"`
	state              attr.ValueState
}

type ListenersPoolWritableValue struct {
	*ListenersPoolValue `json:"-"`
	Algorithm           *ovhtypes.TfStringValue                                `json:"algorithm,omitempty"`
	HealthMonitor       *ListenersPoolHealthMonitorValue                       `json:"healthMonitor,omitempty"`
	Members             *ovhtypes.TfListNestedValue[ListenersPoolMembersValue] `json:"members,omitempty"`
	Name                *ovhtypes.TfStringValue                                `json:"name,omitempty"`
	Protocol            *ovhtypes.TfStringValue                                `json:"protocol,omitempty"`
	SessionPersistence  *ListenersPoolSessionPersistenceValue                  `json:"sessionPersistence,omitempty"`
}

func (v ListenersPoolValue) ToCreate() *ListenersPoolWritableValue {
	res := &ListenersPoolWritableValue{}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.Protocol.IsNull() {
		res.Protocol = &v.Protocol
	}

	if !v.SessionPersistence.IsNull() {
		res.SessionPersistence = &v.SessionPersistence
	}

	if !v.Algorithm.IsNull() {
		res.Algorithm = &v.Algorithm
	}

	if !v.HealthMonitor.IsNull() {
		res.HealthMonitor = &v.HealthMonitor
	}

	if !v.Members.IsNull() {
		res.Members = &v.Members
	}

	return res
}

func (v *ListenersPoolValue) UnmarshalJSON(data []byte) error {
	type JsonListenersPoolValue ListenersPoolValue

	var tmp JsonListenersPoolValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Algorithm = tmp.Algorithm
	v.HealthMonitor = tmp.HealthMonitor
	v.Members = tmp.Members
	v.Name = tmp.Name
	v.Protocol = tmp.Protocol
	v.SessionPersistence = tmp.SessionPersistence

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ListenersPoolValue) MergeWith(other *ListenersPoolValue) {

	if (v.Algorithm.IsUnknown() || v.Algorithm.IsNull()) && !other.Algorithm.IsUnknown() {
		v.Algorithm = other.Algorithm
	}

	if v.HealthMonitor.IsUnknown() && !other.HealthMonitor.IsUnknown() {
		v.HealthMonitor = other.HealthMonitor
	} else if !other.HealthMonitor.IsUnknown() {
		v.HealthMonitor.MergeWith(&other.HealthMonitor)
	}

	if (v.Members.IsUnknown() || v.Members.IsNull()) && !other.Members.IsUnknown() {
		v.Members = other.Members
	} else if !other.Members.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Members.Elements()
		newElems := other.Members.Elements()

		if len(elems) != len(newElems) {
			v.Members = other.Members
		} else {
			for idx, e := range elems {
				tmp := e.(ListenersPoolMembersValue)
				tmp2 := newElems[idx].(ListenersPoolMembersValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Members = ovhtypes.TfListNestedValue[ListenersPoolMembersValue]{
				ListValue: basetypes.NewListValueMust(ListenersPoolMembersValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Protocol.IsUnknown() || v.Protocol.IsNull()) && !other.Protocol.IsUnknown() {
		v.Protocol = other.Protocol
	}

	if v.SessionPersistence.IsUnknown() && !other.SessionPersistence.IsUnknown() {
		v.SessionPersistence = other.SessionPersistence
	} else if !other.SessionPersistence.IsUnknown() {
		v.SessionPersistence.MergeWith(&other.SessionPersistence)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ListenersPoolValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"algorithm":          v.Algorithm,
		"healthMonitor":      v.HealthMonitor,
		"members":            v.Members,
		"name":               v.Name,
		"protocol":           v.Protocol,
		"sessionPersistence": v.SessionPersistence,
	}
}
func (v ListenersPoolValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["algorithm"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_monitor"] = basetypes.ObjectType{
		AttrTypes: ListenersPoolHealthMonitorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["members"] = basetypes.ListType{
		ElemType: ListenersPoolMembersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["session_persistence"] = basetypes.ObjectType{
		AttrTypes: ListenersPoolSessionPersistenceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Algorithm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["algorithm"] = val

		val, err = v.HealthMonitor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_monitor"] = val

		val, err = v.Members.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["members"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.SessionPersistence.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["session_persistence"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenersPoolValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenersPoolValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenersPoolValue) String() string {
	return "ListenersPoolValue"
}

func (v ListenersPoolValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"algorithm": ovhtypes.TfStringType{},
			"health_monitor": ListenersPoolHealthMonitorType{
				basetypes.ObjectType{
					AttrTypes: ListenersPoolHealthMonitorValue{}.AttributeTypes(ctx),
				},
			},
			"members":  ovhtypes.NewTfListNestedType[ListenersPoolMembersValue](ctx),
			"name":     ovhtypes.TfStringType{},
			"protocol": ovhtypes.TfStringType{},
			"session_persistence": ListenersPoolSessionPersistenceType{
				basetypes.ObjectType{
					AttrTypes: ListenersPoolSessionPersistenceValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"algorithm":           v.Algorithm,
			"health_monitor":      v.HealthMonitor,
			"members":             v.Members,
			"name":                v.Name,
			"protocol":            v.Protocol,
			"session_persistence": v.SessionPersistence,
		})

	return objVal, diags
}

func (v ListenersPoolValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenersPoolValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Algorithm.Equal(other.Algorithm) {
		return false
	}

	if !v.HealthMonitor.Equal(other.HealthMonitor) {
		return false
	}

	if !v.Members.Equal(other.Members) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.SessionPersistence.Equal(other.SessionPersistence) {
		return false
	}

	return true
}

func (v ListenersPoolValue) Type(ctx context.Context) attr.Type {
	return ListenersPoolType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenersPoolValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"algorithm":           ovhtypes.TfStringType{},
		"health_monitor":      ListenersPoolHealthMonitorValue{}.Type(ctx),
		"members":             ovhtypes.NewTfListNestedType[ListenersPoolMembersValue](ctx),
		"name":                ovhtypes.TfStringType{},
		"protocol":            ovhtypes.TfStringType{},
		"session_persistence": ListenersPoolSessionPersistenceValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = ListenersPoolHealthMonitorType{}

type ListenersPoolHealthMonitorType struct {
	basetypes.ObjectType
}

func (t ListenersPoolHealthMonitorType) Equal(o attr.Type) bool {
	other, ok := o.(ListenersPoolHealthMonitorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenersPoolHealthMonitorType) String() string {
	return "ListenersPoolHealthMonitorType"
}

func (t ListenersPoolHealthMonitorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	delayAttribute, ok := attributes["delay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delay is missing from object`)

		return nil, diags
	}

	delayVal, ok := delayAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delay expected to be ovhtypes.TfInt64Value, was: %T`, delayAttribute))
	}

	httpConfigurationAttribute, ok := attributes["http_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_configuration is missing from object`)

		return nil, diags
	}

	httpConfigurationVal, ok := httpConfigurationAttribute.(ListenersPoolHealthMonitorHttpConfigurationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_configuration expected to be ListenersPoolHealthMonitorHttpConfigurationValue, was: %T`, httpConfigurationAttribute))
	}

	maxRetriesAttribute, ok := attributes["max_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries is missing from object`)

		return nil, diags
	}

	maxRetriesVal, ok := maxRetriesAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries expected to be ovhtypes.TfInt64Value, was: %T`, maxRetriesAttribute))
	}

	maxRetriesDownAttribute, ok := attributes["max_retries_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries_down is missing from object`)

		return nil, diags
	}

	maxRetriesDownVal, ok := maxRetriesDownAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries_down expected to be ovhtypes.TfInt64Value, was: %T`, maxRetriesDownAttribute))
	}

	monitorTypeAttribute, ok := attributes["monitor_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_type is missing from object`)

		return nil, diags
	}

	monitorTypeVal, ok := monitorTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_type expected to be ovhtypes.TfStringValue, was: %T`, monitorTypeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	operatingStatusAttribute, ok := attributes["operating_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_status is missing from object`)

		return nil, diags
	}

	operatingStatusVal, ok := operatingStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_status expected to be ovhtypes.TfStringValue, was: %T`, operatingStatusAttribute))
	}

	provisioningStatusAttribute, ok := attributes["provisioning_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provisioning_status is missing from object`)

		return nil, diags
	}

	provisioningStatusVal, ok := provisioningStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provisioning_status expected to be ovhtypes.TfStringValue, was: %T`, provisioningStatusAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be ovhtypes.TfInt64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListenersPoolHealthMonitorValue{
		Delay:              delayVal,
		HttpConfiguration:  httpConfigurationVal,
		MaxRetries:         maxRetriesVal,
		MaxRetriesDown:     maxRetriesDownVal,
		MonitorType:        monitorTypeVal,
		Name:               nameVal,
		OperatingStatus:    operatingStatusVal,
		ProvisioningStatus: provisioningStatusVal,
		Timeout:            timeoutVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolHealthMonitorValueNull() ListenersPoolHealthMonitorValue {
	return ListenersPoolHealthMonitorValue{
		state: attr.ValueStateNull,
	}
}

func NewListenersPoolHealthMonitorValueUnknown() ListenersPoolHealthMonitorValue {
	return ListenersPoolHealthMonitorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenersPoolHealthMonitorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenersPoolHealthMonitorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenersPoolHealthMonitorValue Attribute Value",
				"While creating a ListenersPoolHealthMonitorValue value, a missing attribute value was detected. "+
					"A ListenersPoolHealthMonitorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolHealthMonitorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenersPoolHealthMonitorValue Attribute Type",
				"While creating a ListenersPoolHealthMonitorValue value, an invalid attribute value was detected. "+
					"A ListenersPoolHealthMonitorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolHealthMonitorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenersPoolHealthMonitorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenersPoolHealthMonitorValue Attribute Value",
				"While creating a ListenersPoolHealthMonitorValue value, an extra attribute value was detected. "+
					"A ListenersPoolHealthMonitorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenersPoolHealthMonitorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	delayAttribute, ok := attributes["delay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delay is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	delayVal, ok := delayAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delay expected to be ovhtypes.TfInt64Value, was: %T`, delayAttribute))
	}

	httpConfigurationAttribute, ok := attributes["http_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_configuration is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	httpConfigurationVal, ok := httpConfigurationAttribute.(ListenersPoolHealthMonitorHttpConfigurationValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_configuration expected to be ListenersPoolHealthMonitorHttpConfigurationValue, was: %T`, httpConfigurationAttribute))
	}

	maxRetriesAttribute, ok := attributes["max_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	maxRetriesVal, ok := maxRetriesAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries expected to be ovhtypes.TfInt64Value, was: %T`, maxRetriesAttribute))
	}

	maxRetriesDownAttribute, ok := attributes["max_retries_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries_down is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	maxRetriesDownVal, ok := maxRetriesDownAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries_down expected to be ovhtypes.TfInt64Value, was: %T`, maxRetriesDownAttribute))
	}

	monitorTypeAttribute, ok := attributes["monitor_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitor_type is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	monitorTypeVal, ok := monitorTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitor_type expected to be ovhtypes.TfStringValue, was: %T`, monitorTypeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	operatingStatusAttribute, ok := attributes["operating_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_status is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	operatingStatusVal, ok := operatingStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_status expected to be ovhtypes.TfStringValue, was: %T`, operatingStatusAttribute))
	}

	provisioningStatusAttribute, ok := attributes["provisioning_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provisioning_status is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	provisioningStatusVal, ok := provisioningStatusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provisioning_status expected to be ovhtypes.TfStringValue, was: %T`, provisioningStatusAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be ovhtypes.TfInt64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewListenersPoolHealthMonitorValueUnknown(), diags
	}

	return ListenersPoolHealthMonitorValue{
		Delay:              delayVal,
		HttpConfiguration:  httpConfigurationVal,
		MaxRetries:         maxRetriesVal,
		MaxRetriesDown:     maxRetriesDownVal,
		MonitorType:        monitorTypeVal,
		Name:               nameVal,
		OperatingStatus:    operatingStatusVal,
		ProvisioningStatus: provisioningStatusVal,
		Timeout:            timeoutVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolHealthMonitorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenersPoolHealthMonitorValue {
	object, diags := NewListenersPoolHealthMonitorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenersPoolHealthMonitorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenersPoolHealthMonitorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenersPoolHealthMonitorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenersPoolHealthMonitorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenersPoolHealthMonitorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenersPoolHealthMonitorValueMust(ListenersPoolHealthMonitorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenersPoolHealthMonitorType) ValueType(ctx context.Context) attr.Value {
	return ListenersPoolHealthMonitorValue{}
}

var _ basetypes.ObjectValuable = ListenersPoolHealthMonitorValue{}

type ListenersPoolHealthMonitorValue struct {
	Delay              ovhtypes.TfInt64Value                            `tfsdk:"delay" json:"delay"`
	HttpConfiguration  ListenersPoolHealthMonitorHttpConfigurationValue `tfsdk:"http_configuration" json:"httpConfiguration"`
	MaxRetries         ovhtypes.TfInt64Value                            `tfsdk:"max_retries" json:"maxRetries"`
	MaxRetriesDown     ovhtypes.TfInt64Value                            `tfsdk:"max_retries_down" json:"maxRetriesDown"`
	MonitorType        ovhtypes.TfStringValue                           `tfsdk:"monitor_type" json:"monitorType"`
	Name               ovhtypes.TfStringValue                           `tfsdk:"name" json:"name"`
	OperatingStatus    ovhtypes.TfStringValue                           `tfsdk:"operating_status" json:"operatingStatus"`
	ProvisioningStatus ovhtypes.TfStringValue                           `tfsdk:"provisioning_status" json:"provisioningStatus"`
	Timeout            ovhtypes.TfInt64Value                            `tfsdk:"timeout" json:"timeout"`
	state              attr.ValueState
}

type ListenersPoolHealthMonitorWritableValue struct {
	*ListenersPoolHealthMonitorValue `json:"-"`
	Delay                            *ovhtypes.TfInt64Value                            `json:"delay,omitempty"`
	HttpConfiguration                *ListenersPoolHealthMonitorHttpConfigurationValue `json:"httpConfiguration,omitempty"`
	MaxRetries                       *ovhtypes.TfInt64Value                            `json:"maxRetries,omitempty"`
	MaxRetriesDown                   *ovhtypes.TfInt64Value                            `json:"maxRetriesDown,omitempty"`
	MonitorType                      *ovhtypes.TfStringValue                           `json:"monitorType,omitempty"`
	Name                             *ovhtypes.TfStringValue                           `json:"name,omitempty"`
	Timeout                          *ovhtypes.TfInt64Value                            `json:"timeout,omitempty"`
}

func (v ListenersPoolHealthMonitorValue) ToCreate() *ListenersPoolHealthMonitorWritableValue {
	res := &ListenersPoolHealthMonitorWritableValue{}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.Timeout.IsNull() {
		res.Timeout = &v.Timeout
	}

	if !v.Delay.IsNull() {
		res.Delay = &v.Delay
	}

	if !v.HttpConfiguration.IsNull() {
		res.HttpConfiguration = &v.HttpConfiguration
	}

	if !v.MaxRetries.IsNull() {
		res.MaxRetries = &v.MaxRetries
	}

	if !v.MaxRetriesDown.IsNull() {
		res.MaxRetriesDown = &v.MaxRetriesDown
	}

	if !v.MonitorType.IsNull() {
		res.MonitorType = &v.MonitorType
	}

	return res
}

func (v *ListenersPoolHealthMonitorValue) UnmarshalJSON(data []byte) error {
	type JsonListenersPoolHealthMonitorValue ListenersPoolHealthMonitorValue

	var tmp JsonListenersPoolHealthMonitorValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Delay = tmp.Delay
	v.HttpConfiguration = tmp.HttpConfiguration
	v.MaxRetries = tmp.MaxRetries
	v.MaxRetriesDown = tmp.MaxRetriesDown
	v.MonitorType = tmp.MonitorType
	v.Name = tmp.Name
	v.OperatingStatus = tmp.OperatingStatus
	v.ProvisioningStatus = tmp.ProvisioningStatus
	v.Timeout = tmp.Timeout

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ListenersPoolHealthMonitorValue) MergeWith(other *ListenersPoolHealthMonitorValue) {

	if (v.Delay.IsUnknown() || v.Delay.IsNull()) && !other.Delay.IsUnknown() {
		v.Delay = other.Delay
	}

	if v.HttpConfiguration.IsUnknown() && !other.HttpConfiguration.IsUnknown() {
		v.HttpConfiguration = other.HttpConfiguration
	} else if !other.HttpConfiguration.IsUnknown() {
		v.HttpConfiguration.MergeWith(&other.HttpConfiguration)
	}

	if (v.MaxRetries.IsUnknown() || v.MaxRetries.IsNull()) && !other.MaxRetries.IsUnknown() {
		v.MaxRetries = other.MaxRetries
	}

	if (v.MaxRetriesDown.IsUnknown() || v.MaxRetriesDown.IsNull()) && !other.MaxRetriesDown.IsUnknown() {
		v.MaxRetriesDown = other.MaxRetriesDown
	}

	if (v.MonitorType.IsUnknown() || v.MonitorType.IsNull()) && !other.MonitorType.IsUnknown() {
		v.MonitorType = other.MonitorType
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.OperatingStatus.IsUnknown() || v.OperatingStatus.IsNull()) && !other.OperatingStatus.IsUnknown() {
		v.OperatingStatus = other.OperatingStatus
	}

	if (v.ProvisioningStatus.IsUnknown() || v.ProvisioningStatus.IsNull()) && !other.ProvisioningStatus.IsUnknown() {
		v.ProvisioningStatus = other.ProvisioningStatus
	}

	if (v.Timeout.IsUnknown() || v.Timeout.IsNull()) && !other.Timeout.IsUnknown() {
		v.Timeout = other.Timeout
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ListenersPoolHealthMonitorValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"delay":              v.Delay,
		"httpConfiguration":  v.HttpConfiguration,
		"maxRetries":         v.MaxRetries,
		"maxRetriesDown":     v.MaxRetriesDown,
		"monitorType":        v.MonitorType,
		"name":               v.Name,
		"operatingStatus":    v.OperatingStatus,
		"provisioningStatus": v.ProvisioningStatus,
		"timeout":            v.Timeout,
	}
}
func (v ListenersPoolHealthMonitorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["delay"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["http_configuration"] = basetypes.ObjectType{
		AttrTypes: ListenersPoolHealthMonitorHttpConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["max_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_retries_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monitor_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provisioning_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Delay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["delay"] = val

		val, err = v.HttpConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["http_configuration"] = val

		val, err = v.MaxRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_retries"] = val

		val, err = v.MaxRetriesDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_retries_down"] = val

		val, err = v.MonitorType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitor_type"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OperatingStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_status"] = val

		val, err = v.ProvisioningStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provisioning_status"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenersPoolHealthMonitorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenersPoolHealthMonitorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenersPoolHealthMonitorValue) String() string {
	return "ListenersPoolHealthMonitorValue"
}

func (v ListenersPoolHealthMonitorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"delay": ovhtypes.TfInt64Type{},
			"http_configuration": ListenersPoolHealthMonitorHttpConfigurationType{
				basetypes.ObjectType{
					AttrTypes: ListenersPoolHealthMonitorHttpConfigurationValue{}.AttributeTypes(ctx),
				},
			},
			"max_retries":         ovhtypes.TfInt64Type{},
			"max_retries_down":    ovhtypes.TfInt64Type{},
			"monitor_type":        ovhtypes.TfStringType{},
			"name":                ovhtypes.TfStringType{},
			"operating_status":    ovhtypes.TfStringType{},
			"provisioning_status": ovhtypes.TfStringType{},
			"timeout":             ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"delay":               v.Delay,
			"http_configuration":  v.HttpConfiguration,
			"max_retries":         v.MaxRetries,
			"max_retries_down":    v.MaxRetriesDown,
			"monitor_type":        v.MonitorType,
			"name":                v.Name,
			"operating_status":    v.OperatingStatus,
			"provisioning_status": v.ProvisioningStatus,
			"timeout":             v.Timeout,
		})

	return objVal, diags
}

func (v ListenersPoolHealthMonitorValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenersPoolHealthMonitorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Delay.Equal(other.Delay) {
		return false
	}

	if !v.HttpConfiguration.Equal(other.HttpConfiguration) {
		return false
	}

	if !v.MaxRetries.Equal(other.MaxRetries) {
		return false
	}

	if !v.MaxRetriesDown.Equal(other.MaxRetriesDown) {
		return false
	}

	if !v.MonitorType.Equal(other.MonitorType) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OperatingStatus.Equal(other.OperatingStatus) {
		return false
	}

	if !v.ProvisioningStatus.Equal(other.ProvisioningStatus) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v ListenersPoolHealthMonitorValue) Type(ctx context.Context) attr.Type {
	return ListenersPoolHealthMonitorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenersPoolHealthMonitorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"delay":               ovhtypes.TfInt64Type{},
		"http_configuration":  ListenersPoolHealthMonitorHttpConfigurationValue{}.Type(ctx),
		"max_retries":         ovhtypes.TfInt64Type{},
		"max_retries_down":    ovhtypes.TfInt64Type{},
		"monitor_type":        ovhtypes.TfStringType{},
		"name":                ovhtypes.TfStringType{},
		"operating_status":    ovhtypes.TfStringType{},
		"provisioning_status": ovhtypes.TfStringType{},
		"timeout":             ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = ListenersPoolHealthMonitorHttpConfigurationType{}

type ListenersPoolHealthMonitorHttpConfigurationType struct {
	basetypes.ObjectType
}

func (t ListenersPoolHealthMonitorHttpConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(ListenersPoolHealthMonitorHttpConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenersPoolHealthMonitorHttpConfigurationType) String() string {
	return "ListenersPoolHealthMonitorHttpConfigurationType"
}

func (t ListenersPoolHealthMonitorHttpConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return nil, diags
	}

	domainNameVal, ok := domainNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be ovhtypes.TfStringValue, was: %T`, domainNameAttribute))
	}

	expectedCodesAttribute, ok := attributes["expected_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expected_codes is missing from object`)

		return nil, diags
	}

	expectedCodesVal, ok := expectedCodesAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expected_codes expected to be ovhtypes.TfStringValue, was: %T`, expectedCodesAttribute))
	}

	httpMethodAttribute, ok := attributes["http_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_method is missing from object`)

		return nil, diags
	}

	httpMethodVal, ok := httpMethodAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_method expected to be ovhtypes.TfStringValue, was: %T`, httpMethodAttribute))
	}

	httpVersionAttribute, ok := attributes["http_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_version is missing from object`)

		return nil, diags
	}

	httpVersionVal, ok := httpVersionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_version expected to be ovhtypes.TfStringValue, was: %T`, httpVersionAttribute))
	}

	urlPathAttribute, ok := attributes["url_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url_path is missing from object`)

		return nil, diags
	}

	urlPathVal, ok := urlPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url_path expected to be ovhtypes.TfStringValue, was: %T`, urlPathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListenersPoolHealthMonitorHttpConfigurationValue{
		DomainName:    domainNameVal,
		ExpectedCodes: expectedCodesVal,
		HttpMethod:    httpMethodVal,
		HttpVersion:   httpVersionVal,
		UrlPath:       urlPathVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolHealthMonitorHttpConfigurationValueNull() ListenersPoolHealthMonitorHttpConfigurationValue {
	return ListenersPoolHealthMonitorHttpConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewListenersPoolHealthMonitorHttpConfigurationValueUnknown() ListenersPoolHealthMonitorHttpConfigurationValue {
	return ListenersPoolHealthMonitorHttpConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenersPoolHealthMonitorHttpConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenersPoolHealthMonitorHttpConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenersPoolHealthMonitorHttpConfigurationValue Attribute Value",
				"While creating a ListenersPoolHealthMonitorHttpConfigurationValue value, a missing attribute value was detected. "+
					"A ListenersPoolHealthMonitorHttpConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolHealthMonitorHttpConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenersPoolHealthMonitorHttpConfigurationValue Attribute Type",
				"While creating a ListenersPoolHealthMonitorHttpConfigurationValue value, an invalid attribute value was detected. "+
					"A ListenersPoolHealthMonitorHttpConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolHealthMonitorHttpConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenersPoolHealthMonitorHttpConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenersPoolHealthMonitorHttpConfigurationValue Attribute Value",
				"While creating a ListenersPoolHealthMonitorHttpConfigurationValue value, an extra attribute value was detected. "+
					"A ListenersPoolHealthMonitorHttpConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenersPoolHealthMonitorHttpConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), diags
	}

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), diags
	}

	domainNameVal, ok := domainNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be ovhtypes.TfStringValue, was: %T`, domainNameAttribute))
	}

	expectedCodesAttribute, ok := attributes["expected_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expected_codes is missing from object`)

		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), diags
	}

	expectedCodesVal, ok := expectedCodesAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expected_codes expected to be ovhtypes.TfStringValue, was: %T`, expectedCodesAttribute))
	}

	httpMethodAttribute, ok := attributes["http_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_method is missing from object`)

		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), diags
	}

	httpMethodVal, ok := httpMethodAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_method expected to be ovhtypes.TfStringValue, was: %T`, httpMethodAttribute))
	}

	httpVersionAttribute, ok := attributes["http_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_version is missing from object`)

		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), diags
	}

	httpVersionVal, ok := httpVersionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_version expected to be ovhtypes.TfStringValue, was: %T`, httpVersionAttribute))
	}

	urlPathAttribute, ok := attributes["url_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url_path is missing from object`)

		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), diags
	}

	urlPathVal, ok := urlPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url_path expected to be ovhtypes.TfStringValue, was: %T`, urlPathAttribute))
	}

	if diags.HasError() {
		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), diags
	}

	return ListenersPoolHealthMonitorHttpConfigurationValue{
		DomainName:    domainNameVal,
		ExpectedCodes: expectedCodesVal,
		HttpMethod:    httpMethodVal,
		HttpVersion:   httpVersionVal,
		UrlPath:       urlPathVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolHealthMonitorHttpConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenersPoolHealthMonitorHttpConfigurationValue {
	object, diags := NewListenersPoolHealthMonitorHttpConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenersPoolHealthMonitorHttpConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenersPoolHealthMonitorHttpConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenersPoolHealthMonitorHttpConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenersPoolHealthMonitorHttpConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenersPoolHealthMonitorHttpConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenersPoolHealthMonitorHttpConfigurationValueMust(ListenersPoolHealthMonitorHttpConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenersPoolHealthMonitorHttpConfigurationType) ValueType(ctx context.Context) attr.Value {
	return ListenersPoolHealthMonitorHttpConfigurationValue{}
}

var _ basetypes.ObjectValuable = ListenersPoolHealthMonitorHttpConfigurationValue{}

type ListenersPoolHealthMonitorHttpConfigurationValue struct {
	DomainName    ovhtypes.TfStringValue `tfsdk:"domain_name" json:"domainName"`
	ExpectedCodes ovhtypes.TfStringValue `tfsdk:"expected_codes" json:"expectedCodes"`
	HttpMethod    ovhtypes.TfStringValue `tfsdk:"http_method" json:"httpMethod"`
	HttpVersion   ovhtypes.TfStringValue `tfsdk:"http_version" json:"httpVersion"`
	UrlPath       ovhtypes.TfStringValue `tfsdk:"url_path" json:"urlPath"`
	state         attr.ValueState
}

type ListenersPoolHealthMonitorHttpConfigurationWritableValue struct {
	*ListenersPoolHealthMonitorHttpConfigurationValue `json:"-"`
	DomainName                                        *ovhtypes.TfStringValue `json:"domainName,omitempty"`
	ExpectedCodes                                     *ovhtypes.TfStringValue `json:"expectedCodes,omitempty"`
	HttpMethod                                        *ovhtypes.TfStringValue `json:"httpMethod,omitempty"`
	HttpVersion                                       *ovhtypes.TfStringValue `json:"httpVersion,omitempty"`
	UrlPath                                           *ovhtypes.TfStringValue `json:"urlPath,omitempty"`
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) ToCreate() *ListenersPoolHealthMonitorHttpConfigurationWritableValue {
	res := &ListenersPoolHealthMonitorHttpConfigurationWritableValue{}

	if !v.DomainName.IsNull() {
		res.DomainName = &v.DomainName
	}

	if !v.ExpectedCodes.IsNull() {
		res.ExpectedCodes = &v.ExpectedCodes
	}

	if !v.HttpMethod.IsNull() {
		res.HttpMethod = &v.HttpMethod
	}

	if !v.HttpVersion.IsNull() {
		res.HttpVersion = &v.HttpVersion
	}

	if !v.UrlPath.IsNull() {
		res.UrlPath = &v.UrlPath
	}

	return res
}

func (v *ListenersPoolHealthMonitorHttpConfigurationValue) UnmarshalJSON(data []byte) error {
	type JsonListenersPoolHealthMonitorHttpConfigurationValue ListenersPoolHealthMonitorHttpConfigurationValue

	var tmp JsonListenersPoolHealthMonitorHttpConfigurationValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DomainName = tmp.DomainName
	v.ExpectedCodes = tmp.ExpectedCodes
	v.HttpMethod = tmp.HttpMethod
	v.HttpVersion = tmp.HttpVersion
	v.UrlPath = tmp.UrlPath

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ListenersPoolHealthMonitorHttpConfigurationValue) MergeWith(other *ListenersPoolHealthMonitorHttpConfigurationValue) {

	if (v.DomainName.IsUnknown() || v.DomainName.IsNull()) && !other.DomainName.IsUnknown() {
		v.DomainName = other.DomainName
	}

	if (v.ExpectedCodes.IsUnknown() || v.ExpectedCodes.IsNull()) && !other.ExpectedCodes.IsUnknown() {
		v.ExpectedCodes = other.ExpectedCodes
	}

	if (v.HttpMethod.IsUnknown() || v.HttpMethod.IsNull()) && !other.HttpMethod.IsUnknown() {
		v.HttpMethod = other.HttpMethod
	}

	if (v.HttpVersion.IsUnknown() || v.HttpVersion.IsNull()) && !other.HttpVersion.IsUnknown() {
		v.HttpVersion = other.HttpVersion
	}

	if (v.UrlPath.IsUnknown() || v.UrlPath.IsNull()) && !other.UrlPath.IsUnknown() {
		v.UrlPath = other.UrlPath
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"domainName":    v.DomainName,
		"expectedCodes": v.ExpectedCodes,
		"httpMethod":    v.HttpMethod,
		"httpVersion":   v.HttpVersion,
		"urlPath":       v.UrlPath,
	}
}
func (v ListenersPoolHealthMonitorHttpConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["domain_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["expected_codes"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["http_method"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["http_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url_path"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DomainName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain_name"] = val

		val, err = v.ExpectedCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expected_codes"] = val

		val, err = v.HttpMethod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["http_method"] = val

		val, err = v.HttpVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["http_version"] = val

		val, err = v.UrlPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) String() string {
	return "ListenersPoolHealthMonitorHttpConfigurationValue"
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"domain_name":    ovhtypes.TfStringType{},
			"expected_codes": ovhtypes.TfStringType{},
			"http_method":    ovhtypes.TfStringType{},
			"http_version":   ovhtypes.TfStringType{},
			"url_path":       ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"domain_name":    v.DomainName,
			"expected_codes": v.ExpectedCodes,
			"http_method":    v.HttpMethod,
			"http_version":   v.HttpVersion,
			"url_path":       v.UrlPath,
		})

	return objVal, diags
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenersPoolHealthMonitorHttpConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DomainName.Equal(other.DomainName) {
		return false
	}

	if !v.ExpectedCodes.Equal(other.ExpectedCodes) {
		return false
	}

	if !v.HttpMethod.Equal(other.HttpMethod) {
		return false
	}

	if !v.HttpVersion.Equal(other.HttpVersion) {
		return false
	}

	if !v.UrlPath.Equal(other.UrlPath) {
		return false
	}

	return true
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) Type(ctx context.Context) attr.Type {
	return ListenersPoolHealthMonitorHttpConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenersPoolHealthMonitorHttpConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"domain_name":    ovhtypes.TfStringType{},
		"expected_codes": ovhtypes.TfStringType{},
		"http_method":    ovhtypes.TfStringType{},
		"http_version":   ovhtypes.TfStringType{},
		"url_path":       ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = ListenersPoolMembersType{}

type ListenersPoolMembersType struct {
	basetypes.ObjectType
}

func (t ListenersPoolMembersType) Equal(o attr.Type) bool {
	other, ok := o.(ListenersPoolMembersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenersPoolMembersType) String() string {
	return "ListenersPoolMembersType"
}

func (t ListenersPoolMembersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be ovhtypes.TfStringValue, was: %T`, addressAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protocolPortAttribute, ok := attributes["protocol_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_port is missing from object`)

		return nil, diags
	}

	protocolPortVal, ok := protocolPortAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_port expected to be ovhtypes.TfInt64Value, was: %T`, protocolPortAttribute))
	}

	weightAttribute, ok := attributes["weight"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weight is missing from object`)

		return nil, diags
	}

	weightVal, ok := weightAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weight expected to be ovhtypes.TfInt64Value, was: %T`, weightAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListenersPoolMembersValue{
		Address:      addressVal,
		Name:         nameVal,
		ProtocolPort: protocolPortVal,
		Weight:       weightVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolMembersValueNull() ListenersPoolMembersValue {
	return ListenersPoolMembersValue{
		state: attr.ValueStateNull,
	}
}

func NewListenersPoolMembersValueUnknown() ListenersPoolMembersValue {
	return ListenersPoolMembersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenersPoolMembersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenersPoolMembersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenersPoolMembersValue Attribute Value",
				"While creating a ListenersPoolMembersValue value, a missing attribute value was detected. "+
					"A ListenersPoolMembersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolMembersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenersPoolMembersValue Attribute Type",
				"While creating a ListenersPoolMembersValue value, an invalid attribute value was detected. "+
					"A ListenersPoolMembersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolMembersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenersPoolMembersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenersPoolMembersValue Attribute Value",
				"While creating a ListenersPoolMembersValue value, an extra attribute value was detected. "+
					"A ListenersPoolMembersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenersPoolMembersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenersPoolMembersValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewListenersPoolMembersValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be ovhtypes.TfStringValue, was: %T`, addressAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewListenersPoolMembersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	protocolPortAttribute, ok := attributes["protocol_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_port is missing from object`)

		return NewListenersPoolMembersValueUnknown(), diags
	}

	protocolPortVal, ok := protocolPortAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_port expected to be ovhtypes.TfInt64Value, was: %T`, protocolPortAttribute))
	}

	weightAttribute, ok := attributes["weight"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weight is missing from object`)

		return NewListenersPoolMembersValueUnknown(), diags
	}

	weightVal, ok := weightAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weight expected to be ovhtypes.TfInt64Value, was: %T`, weightAttribute))
	}

	if diags.HasError() {
		return NewListenersPoolMembersValueUnknown(), diags
	}

	return ListenersPoolMembersValue{
		Address:      addressVal,
		Name:         nameVal,
		ProtocolPort: protocolPortVal,
		Weight:       weightVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolMembersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenersPoolMembersValue {
	object, diags := NewListenersPoolMembersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenersPoolMembersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenersPoolMembersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenersPoolMembersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenersPoolMembersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenersPoolMembersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenersPoolMembersValueMust(ListenersPoolMembersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenersPoolMembersType) ValueType(ctx context.Context) attr.Value {
	return ListenersPoolMembersValue{}
}

var _ basetypes.ObjectValuable = ListenersPoolMembersValue{}

type ListenersPoolMembersValue struct {
	Address      ovhtypes.TfStringValue `tfsdk:"address" json:"address"`
	Name         ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	ProtocolPort ovhtypes.TfInt64Value  `tfsdk:"protocol_port" json:"protocolPort"`
	Weight       ovhtypes.TfInt64Value  `tfsdk:"weight" json:"weight"`
	state        attr.ValueState
}

type ListenersPoolMembersWritableValue struct {
	*ListenersPoolMembersValue `json:"-"`
	Address                    *ovhtypes.TfStringValue `json:"address,omitempty"`
	Name                       *ovhtypes.TfStringValue `json:"name,omitempty"`
	ProtocolPort               *ovhtypes.TfInt64Value  `json:"protocolPort,omitempty"`
	Weight                     *ovhtypes.TfInt64Value  `json:"weight,omitempty"`
}

func (v ListenersPoolMembersValue) ToCreate() *ListenersPoolMembersWritableValue {
	res := &ListenersPoolMembersWritableValue{}

	if !v.Address.IsNull() {
		res.Address = &v.Address
	}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.ProtocolPort.IsNull() {
		res.ProtocolPort = &v.ProtocolPort
	}

	if !v.Weight.IsNull() {
		res.Weight = &v.Weight
	}

	return res
}

func (v *ListenersPoolMembersValue) UnmarshalJSON(data []byte) error {
	type JsonListenersPoolMembersValue ListenersPoolMembersValue

	var tmp JsonListenersPoolMembersValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Address = tmp.Address
	v.Name = tmp.Name
	v.ProtocolPort = tmp.ProtocolPort
	v.Weight = tmp.Weight

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ListenersPoolMembersValue) MergeWith(other *ListenersPoolMembersValue) {

	if (v.Address.IsUnknown() || v.Address.IsNull()) && !other.Address.IsUnknown() {
		v.Address = other.Address
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.ProtocolPort.IsUnknown() || v.ProtocolPort.IsNull()) && !other.ProtocolPort.IsUnknown() {
		v.ProtocolPort = other.ProtocolPort
	}

	if (v.Weight.IsUnknown() || v.Weight.IsNull()) && !other.Weight.IsUnknown() {
		v.Weight = other.Weight
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ListenersPoolMembersValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"address":      v.Address,
		"name":         v.Name,
		"protocolPort": v.ProtocolPort,
		"weight":       v.Weight,
	}
}
func (v ListenersPoolMembersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["weight"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ProtocolPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol_port"] = val

		val, err = v.Weight.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weight"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenersPoolMembersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenersPoolMembersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenersPoolMembersValue) String() string {
	return "ListenersPoolMembersValue"
}

func (v ListenersPoolMembersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"address":       ovhtypes.TfStringType{},
			"name":          ovhtypes.TfStringType{},
			"protocol_port": ovhtypes.TfInt64Type{},
			"weight":        ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"address":       v.Address,
			"name":          v.Name,
			"protocol_port": v.ProtocolPort,
			"weight":        v.Weight,
		})

	return objVal, diags
}

func (v ListenersPoolMembersValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenersPoolMembersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ProtocolPort.Equal(other.ProtocolPort) {
		return false
	}

	if !v.Weight.Equal(other.Weight) {
		return false
	}

	return true
}

func (v ListenersPoolMembersValue) Type(ctx context.Context) attr.Type {
	return ListenersPoolMembersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenersPoolMembersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":       ovhtypes.TfStringType{},
		"name":          ovhtypes.TfStringType{},
		"protocol_port": ovhtypes.TfInt64Type{},
		"weight":        ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = ListenersPoolSessionPersistenceType{}

type ListenersPoolSessionPersistenceType struct {
	basetypes.ObjectType
}

func (t ListenersPoolSessionPersistenceType) Equal(o attr.Type) bool {
	other, ok := o.(ListenersPoolSessionPersistenceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenersPoolSessionPersistenceType) String() string {
	return "ListenersPoolSessionPersistenceType"
}

func (t ListenersPoolSessionPersistenceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cookieNameAttribute, ok := attributes["cookie_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cookie_name is missing from object`)

		return nil, diags
	}

	cookieNameVal, ok := cookieNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cookie_name expected to be ovhtypes.TfStringValue, was: %T`, cookieNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListenersPoolSessionPersistenceValue{
		CookieName:                          cookieNameVal,
		ListenersPoolSessionPersistenceType: typeVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolSessionPersistenceValueNull() ListenersPoolSessionPersistenceValue {
	return ListenersPoolSessionPersistenceValue{
		state: attr.ValueStateNull,
	}
}

func NewListenersPoolSessionPersistenceValueUnknown() ListenersPoolSessionPersistenceValue {
	return ListenersPoolSessionPersistenceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenersPoolSessionPersistenceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenersPoolSessionPersistenceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenersPoolSessionPersistenceValue Attribute Value",
				"While creating a ListenersPoolSessionPersistenceValue value, a missing attribute value was detected. "+
					"A ListenersPoolSessionPersistenceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolSessionPersistenceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenersPoolSessionPersistenceValue Attribute Type",
				"While creating a ListenersPoolSessionPersistenceValue value, an invalid attribute value was detected. "+
					"A ListenersPoolSessionPersistenceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersPoolSessionPersistenceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenersPoolSessionPersistenceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenersPoolSessionPersistenceValue Attribute Value",
				"While creating a ListenersPoolSessionPersistenceValue value, an extra attribute value was detected. "+
					"A ListenersPoolSessionPersistenceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenersPoolSessionPersistenceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenersPoolSessionPersistenceValueUnknown(), diags
	}

	cookieNameAttribute, ok := attributes["cookie_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cookie_name is missing from object`)

		return NewListenersPoolSessionPersistenceValueUnknown(), diags
	}

	cookieNameVal, ok := cookieNameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cookie_name expected to be ovhtypes.TfStringValue, was: %T`, cookieNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewListenersPoolSessionPersistenceValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewListenersPoolSessionPersistenceValueUnknown(), diags
	}

	return ListenersPoolSessionPersistenceValue{
		CookieName:                          cookieNameVal,
		ListenersPoolSessionPersistenceType: typeVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewListenersPoolSessionPersistenceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenersPoolSessionPersistenceValue {
	object, diags := NewListenersPoolSessionPersistenceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenersPoolSessionPersistenceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenersPoolSessionPersistenceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenersPoolSessionPersistenceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenersPoolSessionPersistenceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenersPoolSessionPersistenceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenersPoolSessionPersistenceValueMust(ListenersPoolSessionPersistenceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenersPoolSessionPersistenceType) ValueType(ctx context.Context) attr.Value {
	return ListenersPoolSessionPersistenceValue{}
}

var _ basetypes.ObjectValuable = ListenersPoolSessionPersistenceValue{}

type ListenersPoolSessionPersistenceValue struct {
	CookieName                          ovhtypes.TfStringValue `tfsdk:"cookie_name" json:"cookieName"`
	ListenersPoolSessionPersistenceType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state                               attr.ValueState
}

type ListenersPoolSessionPersistenceWritableValue struct {
	*ListenersPoolSessionPersistenceValue `json:"-"`
	CookieName                            *ovhtypes.TfStringValue `json:"cookieName,omitempty"`
	ListenersPoolSessionPersistenceType   *ovhtypes.TfStringValue `json:"type,omitempty"`
}

func (v ListenersPoolSessionPersistenceValue) ToCreate() *ListenersPoolSessionPersistenceWritableValue {
	res := &ListenersPoolSessionPersistenceWritableValue{}

	if !v.CookieName.IsNull() {
		res.CookieName = &v.CookieName
	}

	if !v.ListenersPoolSessionPersistenceType.IsNull() {
		res.ListenersPoolSessionPersistenceType = &v.ListenersPoolSessionPersistenceType
	}

	return res
}

func (v *ListenersPoolSessionPersistenceValue) UnmarshalJSON(data []byte) error {
	type JsonListenersPoolSessionPersistenceValue ListenersPoolSessionPersistenceValue

	var tmp JsonListenersPoolSessionPersistenceValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CookieName = tmp.CookieName
	v.ListenersPoolSessionPersistenceType = tmp.ListenersPoolSessionPersistenceType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ListenersPoolSessionPersistenceValue) MergeWith(other *ListenersPoolSessionPersistenceValue) {

	if (v.CookieName.IsUnknown() || v.CookieName.IsNull()) && !other.CookieName.IsUnknown() {
		v.CookieName = other.CookieName
	}

	if (v.ListenersPoolSessionPersistenceType.IsUnknown() || v.ListenersPoolSessionPersistenceType.IsNull()) && !other.ListenersPoolSessionPersistenceType.IsUnknown() {
		v.ListenersPoolSessionPersistenceType = other.ListenersPoolSessionPersistenceType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ListenersPoolSessionPersistenceValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cookieName": v.CookieName,
		"type":       v.ListenersPoolSessionPersistenceType,
	}
}
func (v ListenersPoolSessionPersistenceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cookie_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CookieName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cookie_name"] = val

		val, err = v.ListenersPoolSessionPersistenceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenersPoolSessionPersistenceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenersPoolSessionPersistenceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenersPoolSessionPersistenceValue) String() string {
	return "ListenersPoolSessionPersistenceValue"
}

func (v ListenersPoolSessionPersistenceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cookie_name": ovhtypes.TfStringType{},
			"type":        ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cookie_name": v.CookieName,
			"type":        v.ListenersPoolSessionPersistenceType,
		})

	return objVal, diags
}

func (v ListenersPoolSessionPersistenceValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenersPoolSessionPersistenceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CookieName.Equal(other.CookieName) {
		return false
	}

	if !v.ListenersPoolSessionPersistenceType.Equal(other.ListenersPoolSessionPersistenceType) {
		return false
	}

	return true
}

func (v ListenersPoolSessionPersistenceValue) Type(ctx context.Context) attr.Type {
	return ListenersPoolSessionPersistenceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenersPoolSessionPersistenceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cookie_name": ovhtypes.TfStringType{},
		"type":        ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkType{}

type NetworkType struct {
	basetypes.ObjectType
}

func (t NetworkType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkType) String() string {
	return "NetworkType"
}

func (t NetworkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	privateAttribute, ok := attributes["private"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private is missing from object`)

		return nil, diags
	}

	privateVal, ok := privateAttribute.(NetworkPrivateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private expected to be NetworkPrivateValue, was: %T`, privateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkValue{
		Private: privateVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNetworkValueNull() NetworkValue {
	return NetworkValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkValueUnknown() NetworkValue {
	return NetworkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkValue Attribute Value",
				"While creating a NetworkValue value, a missing attribute value was detected. "+
					"A NetworkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkValue Attribute Type",
				"While creating a NetworkValue value, an invalid attribute value was detected. "+
					"A NetworkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkValue Attribute Value",
				"While creating a NetworkValue value, an extra attribute value was detected. "+
					"A NetworkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkValueUnknown(), diags
	}

	privateAttribute, ok := attributes["private"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private is missing from object`)

		return NewNetworkValueUnknown(), diags
	}

	privateVal, ok := privateAttribute.(NetworkPrivateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private expected to be NetworkPrivateValue, was: %T`, privateAttribute))
	}

	if diags.HasError() {
		return NewNetworkValueUnknown(), diags
	}

	return NetworkValue{
		Private: privateVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNetworkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkValue {
	object, diags := NewNetworkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkValueMust(NetworkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkType) ValueType(ctx context.Context) attr.Value {
	return NetworkValue{}
}

var _ basetypes.ObjectValuable = NetworkValue{}

type NetworkValue struct {
	Private NetworkPrivateValue `tfsdk:"private" json:"private"`
	state   attr.ValueState
}

type NetworkWritableValue struct {
	*NetworkValue `json:"-"`
	Private       *NetworkPrivateWritableValue `json:"private,omitempty"`
}

func (v NetworkValue) ToCreate() *NetworkWritableValue {
	res := &NetworkWritableValue{}

	if !v.Private.IsNull() {
		res.Private = v.Private.ToCreate()
	}

	return res
}

func (v *NetworkValue) UnmarshalJSON(data []byte) error {
	type JsonNetworkValue NetworkValue

	var tmp JsonNetworkValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Private = tmp.Private

	v.state = attr.ValueStateKnown

	return nil
}

func (v *NetworkValue) MergeWith(other *NetworkValue) {

	if v.Private.IsUnknown() && !other.Private.IsUnknown() {
		v.Private = other.Private
	} else if !other.Private.IsUnknown() {
		v.Private.MergeWith(&other.Private)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v NetworkValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"private": v.Private,
	}
}

func (v NetworkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["private"] = basetypes.ObjectType{
		AttrTypes: NetworkPrivateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Private.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkValue) String() string {
	return "NetworkValue"
}

func (v NetworkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"private": NetworkPrivateType{
				basetypes.ObjectType{
					AttrTypes: NetworkPrivateValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"private": v.Private,
		})

	return objVal, diags
}

func (v NetworkValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Private.Equal(other.Private) {
		return false
	}

	return true
}

func (v NetworkValue) Type(ctx context.Context) attr.Type {
	return NetworkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"private": NetworkPrivateValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = NetworkPrivateType{}

type NetworkPrivateType struct {
	basetypes.ObjectType
}

func (t NetworkPrivateType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkPrivateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkPrivateType) String() string {
	return "NetworkPrivateType"
}

func (t NetworkPrivateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	floatingIpAttribute, ok := attributes["floating_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip is missing from object`)

		return nil, diags
	}

	floatingIpVal, ok := floatingIpAttribute.(NetworkPrivateFloatingIpValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip expected to be NetworkPrivateFloatingIpValue, was: %T`, floatingIpAttribute))
	}

	floatingIpCreateAttribute, ok := attributes["floating_ip_create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_create is missing from object`)

		return nil, diags
	}

	floatingIpCreateVal, ok := floatingIpCreateAttribute.(NetworkPrivateFloatingIpCreateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_create expected to be NetworkPrivateFloatingIpCreateValue, was: %T`, floatingIpCreateAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(NetworkPrivateGatewayValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be NetworkPrivateGatewayValue, was: %T`, gatewayAttribute))
	}

	gatewayCreateAttribute, ok := attributes["gateway_create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_create is missing from object`)

		return nil, diags
	}

	gatewayCreateVal, ok := gatewayCreateAttribute.(NetworkPrivateGatewayCreateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_create expected to be NetworkPrivateGatewayCreateValue, was: %T`, gatewayCreateAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(NetworkPrivateNetworkValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be NetworkPrivateNetworkValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkPrivateValue{
		FloatingIp:       floatingIpVal,
		FloatingIpCreate: floatingIpCreateVal,
		Gateway:          gatewayVal,
		GatewayCreate:    gatewayCreateVal,
		Network:          networkVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateValueNull() NetworkPrivateValue {
	return NetworkPrivateValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkPrivateValueUnknown() NetworkPrivateValue {
	return NetworkPrivateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkPrivateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkPrivateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkPrivateValue Attribute Value",
				"While creating a NetworkPrivateValue value, a missing attribute value was detected. "+
					"A NetworkPrivateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkPrivateValue Attribute Type",
				"While creating a NetworkPrivateValue value, an invalid attribute value was detected. "+
					"A NetworkPrivateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkPrivateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkPrivateValue Attribute Value",
				"While creating a NetworkPrivateValue value, an extra attribute value was detected. "+
					"A NetworkPrivateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkPrivateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkPrivateValueUnknown(), diags
	}

	floatingIpAttribute, ok := attributes["floating_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip is missing from object`)

		return NewNetworkPrivateValueUnknown(), diags
	}

	floatingIpVal, ok := floatingIpAttribute.(NetworkPrivateFloatingIpValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip expected to be NetworkPrivateFloatingIpValue, was: %T`, floatingIpAttribute))
	}

	floatingIpCreateAttribute, ok := attributes["floating_ip_create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_create is missing from object`)

		return NewNetworkPrivateValueUnknown(), diags
	}

	floatingIpCreateVal, ok := floatingIpCreateAttribute.(NetworkPrivateFloatingIpCreateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_create expected to be NetworkPrivateFloatingIpCreateValue, was: %T`, floatingIpCreateAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewNetworkPrivateValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(NetworkPrivateGatewayValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be NetworkPrivateGatewayValue, was: %T`, gatewayAttribute))
	}

	gatewayCreateAttribute, ok := attributes["gateway_create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_create is missing from object`)

		return NewNetworkPrivateValueUnknown(), diags
	}

	gatewayCreateVal, ok := gatewayCreateAttribute.(NetworkPrivateGatewayCreateValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_create expected to be NetworkPrivateGatewayCreateValue, was: %T`, gatewayCreateAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewNetworkPrivateValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(NetworkPrivateNetworkValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be NetworkPrivateNetworkValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return NewNetworkPrivateValueUnknown(), diags
	}

	return NetworkPrivateValue{
		FloatingIp:       floatingIpVal,
		FloatingIpCreate: floatingIpCreateVal,
		Gateway:          gatewayVal,
		GatewayCreate:    gatewayCreateVal,
		Network:          networkVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkPrivateValue {
	object, diags := NewNetworkPrivateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkPrivateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkPrivateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkPrivateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkPrivateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkPrivateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkPrivateValueMust(NetworkPrivateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkPrivateType) ValueType(ctx context.Context) attr.Value {
	return NetworkPrivateValue{}
}

var _ basetypes.ObjectValuable = NetworkPrivateValue{}

type NetworkPrivateValue struct {
	FloatingIp       NetworkPrivateFloatingIpValue       `tfsdk:"floating_ip" json:"floatingIp"`
	FloatingIpCreate NetworkPrivateFloatingIpCreateValue `tfsdk:"floating_ip_create" json:"floatingIpCreate"`
	Gateway          NetworkPrivateGatewayValue          `tfsdk:"gateway" json:"gateway"`
	GatewayCreate    NetworkPrivateGatewayCreateValue    `tfsdk:"gateway_create" json:"gatewayCreate"`
	Network          NetworkPrivateNetworkValue          `tfsdk:"network" json:"network"`
	state            attr.ValueState
}

type NetworkPrivateWritableValue struct {
	*NetworkPrivateValue `json:"-"`
	FloatingIp           *NetworkPrivateFloatingIpValue       `json:"floatingIp,omitempty"`
	FloatingIpCreate     *NetworkPrivateFloatingIpCreateValue `json:"floatingIpCreate,omitempty"`
	Gateway              *NetworkPrivateGatewayValue          `json:"gateway,omitempty"`
	GatewayCreate        *NetworkPrivateGatewayCreateValue    `json:"gatewayCreate,omitempty"`
	Network              *NetworkPrivateNetworkValue          `json:"network,omitempty"`
}

func (v NetworkPrivateValue) ToCreate() *NetworkPrivateWritableValue {
	res := &NetworkPrivateWritableValue{}

	if !v.FloatingIpCreate.IsNull() && !v.FloatingIpCreate.IsUnknown() {
		res.FloatingIpCreate = &v.FloatingIpCreate
	}

	if !v.Gateway.IsNull() && !v.Gateway.IsUnknown() {
		res.Gateway = &v.Gateway
	}

	if !v.GatewayCreate.IsNull() && !v.GatewayCreate.IsUnknown() {
		res.GatewayCreate = &v.GatewayCreate
	}

	if !v.Network.IsNull() && !v.Network.IsUnknown() {
		res.Network = &v.Network
	}

	if !v.FloatingIp.IsNull() && !v.FloatingIp.IsUnknown() {
		res.FloatingIp = &v.FloatingIp
	}

	return res
}

func (v *NetworkPrivateValue) UnmarshalJSON(data []byte) error {
	type JsonNetworkPrivateValue NetworkPrivateValue

	var tmp JsonNetworkPrivateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.FloatingIp = tmp.FloatingIp
	v.FloatingIpCreate = tmp.FloatingIpCreate
	v.Gateway = tmp.Gateway
	v.GatewayCreate = tmp.GatewayCreate
	v.Network = tmp.Network

	v.state = attr.ValueStateKnown

	return nil
}

func (v *NetworkPrivateValue) MergeWith(other *NetworkPrivateValue) {

	if v.FloatingIp.IsUnknown() && !other.FloatingIp.IsUnknown() {
		v.FloatingIp = other.FloatingIp
	} else if !other.FloatingIp.IsUnknown() {
		v.FloatingIp.MergeWith(&other.FloatingIp)
	}

	if v.FloatingIpCreate.IsUnknown() && !other.FloatingIpCreate.IsUnknown() {
		v.FloatingIpCreate = other.FloatingIpCreate
	} else if !other.FloatingIpCreate.IsUnknown() {
		v.FloatingIpCreate.MergeWith(&other.FloatingIpCreate)
	}

	if v.Gateway.IsUnknown() && !other.Gateway.IsUnknown() {
		v.Gateway = other.Gateway
	} else if !other.Gateway.IsUnknown() {
		v.Gateway.MergeWith(&other.Gateway)
	}

	if v.GatewayCreate.IsUnknown() && !other.GatewayCreate.IsUnknown() {
		v.GatewayCreate = other.GatewayCreate
	} else if !other.GatewayCreate.IsUnknown() {
		v.GatewayCreate.MergeWith(&other.GatewayCreate)
	}

	if v.Network.IsUnknown() && !other.Network.IsUnknown() {
		v.Network = other.Network
	} else if !other.Network.IsUnknown() {
		v.Network.MergeWith(&other.Network)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v NetworkPrivateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"floatingIp":       v.FloatingIp,
		"floatingIpCreate": v.FloatingIpCreate,
		"gateway":          v.Gateway,
		"gatewayCreate":    v.GatewayCreate,
		"network":          v.Network,
	}
}

func (v NetworkPrivateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["floating_ip"] = basetypes.ObjectType{
		AttrTypes: NetworkPrivateFloatingIpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["floating_ip_create"] = basetypes.ObjectType{
		AttrTypes: NetworkPrivateFloatingIpCreateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.ObjectType{
		AttrTypes: NetworkPrivateGatewayValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["gateway_create"] = basetypes.ObjectType{
		AttrTypes: NetworkPrivateGatewayCreateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.ObjectType{
		AttrTypes: NetworkPrivateNetworkValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.FloatingIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["floating_ip"] = val

		val, err = v.FloatingIpCreate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["floating_ip_create"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.GatewayCreate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway_create"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkPrivateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkPrivateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkPrivateValue) String() string {
	return "NetworkPrivateValue"
}

func (v NetworkPrivateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"floating_ip": NetworkPrivateFloatingIpType{
				basetypes.ObjectType{
					AttrTypes: NetworkPrivateFloatingIpValue{}.AttributeTypes(ctx),
				},
			},
			"floating_ip_create": NetworkPrivateFloatingIpCreateType{
				basetypes.ObjectType{
					AttrTypes: NetworkPrivateFloatingIpCreateValue{}.AttributeTypes(ctx),
				},
			},
			"gateway": NetworkPrivateGatewayType{
				basetypes.ObjectType{
					AttrTypes: NetworkPrivateGatewayValue{}.AttributeTypes(ctx),
				},
			},
			"gateway_create": NetworkPrivateGatewayCreateType{
				basetypes.ObjectType{
					AttrTypes: NetworkPrivateGatewayCreateValue{}.AttributeTypes(ctx),
				},
			},
			"network": NetworkPrivateNetworkType{
				basetypes.ObjectType{
					AttrTypes: NetworkPrivateNetworkValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"floating_ip":        v.FloatingIp,
			"floating_ip_create": v.FloatingIpCreate,
			"gateway":            v.Gateway,
			"gateway_create":     v.GatewayCreate,
			"network":            v.Network,
		})

	return objVal, diags
}

func (v NetworkPrivateValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkPrivateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FloatingIp.Equal(other.FloatingIp) {
		return false
	}

	if !v.FloatingIpCreate.Equal(other.FloatingIpCreate) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.GatewayCreate.Equal(other.GatewayCreate) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	return true
}

func (v NetworkPrivateValue) Type(ctx context.Context) attr.Type {
	return NetworkPrivateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkPrivateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"floating_ip":        NetworkPrivateFloatingIpValue{}.Type(ctx),
		"floating_ip_create": NetworkPrivateFloatingIpCreateValue{}.Type(ctx),
		"gateway":            NetworkPrivateGatewayValue{}.Type(ctx),
		"gateway_create":     NetworkPrivateGatewayCreateValue{}.Type(ctx),
		"network":            NetworkPrivateNetworkValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = NetworkPrivateFloatingIpType{}

type NetworkPrivateFloatingIpType struct {
	basetypes.ObjectType
}

func (t NetworkPrivateFloatingIpType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkPrivateFloatingIpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkPrivateFloatingIpType) String() string {
	return "NetworkPrivateFloatingIpType"
}

func (t NetworkPrivateFloatingIpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkPrivateFloatingIpValue{
		Id:    idVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateFloatingIpValueNull() NetworkPrivateFloatingIpValue {
	return NetworkPrivateFloatingIpValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkPrivateFloatingIpValueUnknown() NetworkPrivateFloatingIpValue {
	return NetworkPrivateFloatingIpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkPrivateFloatingIpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkPrivateFloatingIpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkPrivateFloatingIpValue Attribute Value",
				"While creating a NetworkPrivateFloatingIpValue value, a missing attribute value was detected. "+
					"A NetworkPrivateFloatingIpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateFloatingIpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkPrivateFloatingIpValue Attribute Type",
				"While creating a NetworkPrivateFloatingIpValue value, an invalid attribute value was detected. "+
					"A NetworkPrivateFloatingIpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateFloatingIpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkPrivateFloatingIpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkPrivateFloatingIpValue Attribute Value",
				"While creating a NetworkPrivateFloatingIpValue value, an extra attribute value was detected. "+
					"A NetworkPrivateFloatingIpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkPrivateFloatingIpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkPrivateFloatingIpValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewNetworkPrivateFloatingIpValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewNetworkPrivateFloatingIpValueUnknown(), diags
	}

	return NetworkPrivateFloatingIpValue{
		Id:    idVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateFloatingIpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkPrivateFloatingIpValue {
	object, diags := NewNetworkPrivateFloatingIpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkPrivateFloatingIpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkPrivateFloatingIpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkPrivateFloatingIpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkPrivateFloatingIpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkPrivateFloatingIpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkPrivateFloatingIpValueMust(NetworkPrivateFloatingIpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkPrivateFloatingIpType) ValueType(ctx context.Context) attr.Value {
	return NetworkPrivateFloatingIpValue{}
}

var _ basetypes.ObjectValuable = NetworkPrivateFloatingIpValue{}

type NetworkPrivateFloatingIpValue struct {
	Id    ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	state attr.ValueState
}

type NetworkPrivateFloatingIpWritableValue struct {
	*NetworkPrivateFloatingIpValue `json:"-"`
	Id                             *ovhtypes.TfStringValue `json:"id,omitempty"`
}

func (v NetworkPrivateFloatingIpValue) ToCreate() *NetworkPrivateFloatingIpWritableValue {
	res := &NetworkPrivateFloatingIpWritableValue{}

	if !v.Id.IsNull() {
		res.Id = &v.Id
	}

	return res
}

func (v *NetworkPrivateFloatingIpValue) UnmarshalJSON(data []byte) error {
	type JsonNetworkPrivateFloatingIpValue NetworkPrivateFloatingIpValue

	var tmp JsonNetworkPrivateFloatingIpValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id

	v.state = attr.ValueStateKnown

	return nil
}

func (v *NetworkPrivateFloatingIpValue) MergeWith(other *NetworkPrivateFloatingIpValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v NetworkPrivateFloatingIpValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id": v.Id,
	}
}
func (v NetworkPrivateFloatingIpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkPrivateFloatingIpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkPrivateFloatingIpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkPrivateFloatingIpValue) String() string {
	return "NetworkPrivateFloatingIpValue"
}

func (v NetworkPrivateFloatingIpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id": v.Id,
		})

	return objVal, diags
}

func (v NetworkPrivateFloatingIpValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkPrivateFloatingIpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v NetworkPrivateFloatingIpValue) Type(ctx context.Context) attr.Type {
	return NetworkPrivateFloatingIpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkPrivateFloatingIpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkPrivateFloatingIpCreateType{}

type NetworkPrivateFloatingIpCreateType struct {
	basetypes.ObjectType
}

func (t NetworkPrivateFloatingIpCreateType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkPrivateFloatingIpCreateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkPrivateFloatingIpCreateType) String() string {
	return "NetworkPrivateFloatingIpCreateType"
}

func (t NetworkPrivateFloatingIpCreateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkPrivateFloatingIpCreateValue{
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateFloatingIpCreateValueNull() NetworkPrivateFloatingIpCreateValue {
	return NetworkPrivateFloatingIpCreateValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkPrivateFloatingIpCreateValueUnknown() NetworkPrivateFloatingIpCreateValue {
	return NetworkPrivateFloatingIpCreateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkPrivateFloatingIpCreateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkPrivateFloatingIpCreateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkPrivateFloatingIpCreateValue Attribute Value",
				"While creating a NetworkPrivateFloatingIpCreateValue value, a missing attribute value was detected. "+
					"A NetworkPrivateFloatingIpCreateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateFloatingIpCreateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkPrivateFloatingIpCreateValue Attribute Type",
				"While creating a NetworkPrivateFloatingIpCreateValue value, an invalid attribute value was detected. "+
					"A NetworkPrivateFloatingIpCreateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateFloatingIpCreateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkPrivateFloatingIpCreateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkPrivateFloatingIpCreateValue Attribute Value",
				"While creating a NetworkPrivateFloatingIpCreateValue value, an extra attribute value was detected. "+
					"A NetworkPrivateFloatingIpCreateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkPrivateFloatingIpCreateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkPrivateFloatingIpCreateValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewNetworkPrivateFloatingIpCreateValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return NewNetworkPrivateFloatingIpCreateValueUnknown(), diags
	}

	return NetworkPrivateFloatingIpCreateValue{
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateFloatingIpCreateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkPrivateFloatingIpCreateValue {
	object, diags := NewNetworkPrivateFloatingIpCreateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkPrivateFloatingIpCreateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkPrivateFloatingIpCreateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkPrivateFloatingIpCreateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkPrivateFloatingIpCreateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkPrivateFloatingIpCreateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkPrivateFloatingIpCreateValueMust(NetworkPrivateFloatingIpCreateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkPrivateFloatingIpCreateType) ValueType(ctx context.Context) attr.Value {
	return NetworkPrivateFloatingIpCreateValue{}
}

var _ basetypes.ObjectValuable = NetworkPrivateFloatingIpCreateValue{}

type NetworkPrivateFloatingIpCreateValue struct {
	Description ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	state       attr.ValueState
}

type NetworkPrivateFloatingIpCreateWritableValue struct {
	*NetworkPrivateFloatingIpCreateValue `json:"-"`
	Description                          *ovhtypes.TfStringValue `json:"description,omitempty"`
}

func (v NetworkPrivateFloatingIpCreateValue) ToCreate() *NetworkPrivateFloatingIpCreateWritableValue {
	res := &NetworkPrivateFloatingIpCreateWritableValue{}

	if !v.Description.IsNull() {
		res.Description = &v.Description
	}

	return res
}

func (v *NetworkPrivateFloatingIpCreateValue) UnmarshalJSON(data []byte) error {
	type JsonNetworkPrivateFloatingIpCreateValue NetworkPrivateFloatingIpCreateValue

	var tmp JsonNetworkPrivateFloatingIpCreateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Description = tmp.Description

	v.state = attr.ValueStateKnown

	return nil
}

func (v *NetworkPrivateFloatingIpCreateValue) MergeWith(other *NetworkPrivateFloatingIpCreateValue) {

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v NetworkPrivateFloatingIpCreateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"description": v.Description,
	}
}
func (v NetworkPrivateFloatingIpCreateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkPrivateFloatingIpCreateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkPrivateFloatingIpCreateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkPrivateFloatingIpCreateValue) String() string {
	return "NetworkPrivateFloatingIpCreateValue"
}

func (v NetworkPrivateFloatingIpCreateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"description": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"description": v.Description,
		})

	return objVal, diags
}

func (v NetworkPrivateFloatingIpCreateValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkPrivateFloatingIpCreateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	return true
}

func (v NetworkPrivateFloatingIpCreateValue) Type(ctx context.Context) attr.Type {
	return NetworkPrivateFloatingIpCreateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkPrivateFloatingIpCreateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkPrivateGatewayType{}

type NetworkPrivateGatewayType struct {
	basetypes.ObjectType
}

func (t NetworkPrivateGatewayType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkPrivateGatewayType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkPrivateGatewayType) String() string {
	return "NetworkPrivateGatewayType"
}

func (t NetworkPrivateGatewayType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkPrivateGatewayValue{
		Id:    idVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateGatewayValueNull() NetworkPrivateGatewayValue {
	return NetworkPrivateGatewayValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkPrivateGatewayValueUnknown() NetworkPrivateGatewayValue {
	return NetworkPrivateGatewayValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkPrivateGatewayValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkPrivateGatewayValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkPrivateGatewayValue Attribute Value",
				"While creating a NetworkPrivateGatewayValue value, a missing attribute value was detected. "+
					"A NetworkPrivateGatewayValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateGatewayValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkPrivateGatewayValue Attribute Type",
				"While creating a NetworkPrivateGatewayValue value, an invalid attribute value was detected. "+
					"A NetworkPrivateGatewayValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateGatewayValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkPrivateGatewayValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkPrivateGatewayValue Attribute Value",
				"While creating a NetworkPrivateGatewayValue value, an extra attribute value was detected. "+
					"A NetworkPrivateGatewayValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkPrivateGatewayValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkPrivateGatewayValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewNetworkPrivateGatewayValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewNetworkPrivateGatewayValueUnknown(), diags
	}

	return NetworkPrivateGatewayValue{
		Id:    idVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateGatewayValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkPrivateGatewayValue {
	object, diags := NewNetworkPrivateGatewayValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkPrivateGatewayValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkPrivateGatewayType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkPrivateGatewayValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkPrivateGatewayValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkPrivateGatewayValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkPrivateGatewayValueMust(NetworkPrivateGatewayValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkPrivateGatewayType) ValueType(ctx context.Context) attr.Value {
	return NetworkPrivateGatewayValue{}
}

var _ basetypes.ObjectValuable = NetworkPrivateGatewayValue{}

type NetworkPrivateGatewayValue struct {
	Id    ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	state attr.ValueState
}

type NetworkPrivateGatewayWritableValue struct {
	*NetworkPrivateGatewayValue `json:"-"`
	Id                          *ovhtypes.TfStringValue `json:"id,omitempty"`
}

func (v NetworkPrivateGatewayValue) ToCreate() *NetworkPrivateGatewayWritableValue {
	res := &NetworkPrivateGatewayWritableValue{}

	if !v.Id.IsNull() {
		res.Id = &v.Id
	}

	return res
}

func (v *NetworkPrivateGatewayValue) UnmarshalJSON(data []byte) error {
	type JsonNetworkPrivateGatewayValue NetworkPrivateGatewayValue

	var tmp JsonNetworkPrivateGatewayValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id

	v.state = attr.ValueStateKnown

	return nil
}

func (v *NetworkPrivateGatewayValue) MergeWith(other *NetworkPrivateGatewayValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v NetworkPrivateGatewayValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id": v.Id,
	}
}
func (v NetworkPrivateGatewayValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkPrivateGatewayValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkPrivateGatewayValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkPrivateGatewayValue) String() string {
	return "NetworkPrivateGatewayValue"
}

func (v NetworkPrivateGatewayValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id": v.Id,
		})

	return objVal, diags
}

func (v NetworkPrivateGatewayValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkPrivateGatewayValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v NetworkPrivateGatewayValue) Type(ctx context.Context) attr.Type {
	return NetworkPrivateGatewayType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkPrivateGatewayValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkPrivateGatewayCreateType{}

type NetworkPrivateGatewayCreateType struct {
	basetypes.ObjectType
}

func (t NetworkPrivateGatewayCreateType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkPrivateGatewayCreateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkPrivateGatewayCreateType) String() string {
	return "NetworkPrivateGatewayCreateType"
}

func (t NetworkPrivateGatewayCreateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be ovhtypes.TfStringValue, was: %T`, modelAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkPrivateGatewayCreateValue{
		Model: modelVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateGatewayCreateValueNull() NetworkPrivateGatewayCreateValue {
	return NetworkPrivateGatewayCreateValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkPrivateGatewayCreateValueUnknown() NetworkPrivateGatewayCreateValue {
	return NetworkPrivateGatewayCreateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkPrivateGatewayCreateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkPrivateGatewayCreateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkPrivateGatewayCreateValue Attribute Value",
				"While creating a NetworkPrivateGatewayCreateValue value, a missing attribute value was detected. "+
					"A NetworkPrivateGatewayCreateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateGatewayCreateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkPrivateGatewayCreateValue Attribute Type",
				"While creating a NetworkPrivateGatewayCreateValue value, an invalid attribute value was detected. "+
					"A NetworkPrivateGatewayCreateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateGatewayCreateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkPrivateGatewayCreateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkPrivateGatewayCreateValue Attribute Value",
				"While creating a NetworkPrivateGatewayCreateValue value, an extra attribute value was detected. "+
					"A NetworkPrivateGatewayCreateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkPrivateGatewayCreateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkPrivateGatewayCreateValueUnknown(), diags
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewNetworkPrivateGatewayCreateValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be ovhtypes.TfStringValue, was: %T`, modelAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNetworkPrivateGatewayCreateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewNetworkPrivateGatewayCreateValueUnknown(), diags
	}

	return NetworkPrivateGatewayCreateValue{
		Model: modelVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateGatewayCreateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkPrivateGatewayCreateValue {
	object, diags := NewNetworkPrivateGatewayCreateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkPrivateGatewayCreateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkPrivateGatewayCreateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkPrivateGatewayCreateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkPrivateGatewayCreateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkPrivateGatewayCreateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkPrivateGatewayCreateValueMust(NetworkPrivateGatewayCreateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkPrivateGatewayCreateType) ValueType(ctx context.Context) attr.Value {
	return NetworkPrivateGatewayCreateValue{}
}

var _ basetypes.ObjectValuable = NetworkPrivateGatewayCreateValue{}

type NetworkPrivateGatewayCreateValue struct {
	Model ovhtypes.TfStringValue `tfsdk:"model" json:"model"`
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	state attr.ValueState
}

type NetworkPrivateGatewayCreateWritableValue struct {
	*NetworkPrivateGatewayCreateValue `json:"-"`
	Model                             *ovhtypes.TfStringValue `json:"model,omitempty"`
	Name                              *ovhtypes.TfStringValue `json:"name,omitempty"`
}

func (v NetworkPrivateGatewayCreateValue) ToCreate() *NetworkPrivateGatewayCreateWritableValue {
	res := &NetworkPrivateGatewayCreateWritableValue{}

	if !v.Model.IsNull() {
		res.Model = &v.Model
	}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	return res
}

func (v *NetworkPrivateGatewayCreateValue) UnmarshalJSON(data []byte) error {
	type JsonNetworkPrivateGatewayCreateValue NetworkPrivateGatewayCreateValue

	var tmp JsonNetworkPrivateGatewayCreateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Model = tmp.Model
	v.Name = tmp.Name

	v.state = attr.ValueStateKnown

	return nil
}

func (v *NetworkPrivateGatewayCreateValue) MergeWith(other *NetworkPrivateGatewayCreateValue) {

	if (v.Model.IsUnknown() || v.Model.IsNull()) && !other.Model.IsUnknown() {
		v.Model = other.Model
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v NetworkPrivateGatewayCreateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"model": v.Model,
		"name":  v.Name,
	}
}
func (v NetworkPrivateGatewayCreateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkPrivateGatewayCreateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkPrivateGatewayCreateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkPrivateGatewayCreateValue) String() string {
	return "NetworkPrivateGatewayCreateValue"
}

func (v NetworkPrivateGatewayCreateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"model": ovhtypes.TfStringType{},
			"name":  ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"model": v.Model,
			"name":  v.Name,
		})

	return objVal, diags
}

func (v NetworkPrivateGatewayCreateValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkPrivateGatewayCreateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v NetworkPrivateGatewayCreateValue) Type(ctx context.Context) attr.Type {
	return NetworkPrivateGatewayCreateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkPrivateGatewayCreateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"model": ovhtypes.TfStringType{},
		"name":  ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkPrivateNetworkType{}

type NetworkPrivateNetworkType struct {
	basetypes.ObjectType
}

func (t NetworkPrivateNetworkType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkPrivateNetworkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkPrivateNetworkType) String() string {
	return "NetworkPrivateNetworkType"
}

func (t NetworkPrivateNetworkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be ovhtypes.TfStringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkPrivateNetworkValue{
		Id:       idVal,
		SubnetId: subnetIdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateNetworkValueNull() NetworkPrivateNetworkValue {
	return NetworkPrivateNetworkValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkPrivateNetworkValueUnknown() NetworkPrivateNetworkValue {
	return NetworkPrivateNetworkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkPrivateNetworkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkPrivateNetworkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkPrivateNetworkValue Attribute Value",
				"While creating a NetworkPrivateNetworkValue value, a missing attribute value was detected. "+
					"A NetworkPrivateNetworkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateNetworkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkPrivateNetworkValue Attribute Type",
				"While creating a NetworkPrivateNetworkValue value, an invalid attribute value was detected. "+
					"A NetworkPrivateNetworkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkPrivateNetworkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkPrivateNetworkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkPrivateNetworkValue Attribute Value",
				"While creating a NetworkPrivateNetworkValue value, an extra attribute value was detected. "+
					"A NetworkPrivateNetworkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkPrivateNetworkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkPrivateNetworkValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewNetworkPrivateNetworkValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewNetworkPrivateNetworkValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be ovhtypes.TfStringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewNetworkPrivateNetworkValueUnknown(), diags
	}

	return NetworkPrivateNetworkValue{
		Id:       idVal,
		SubnetId: subnetIdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNetworkPrivateNetworkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkPrivateNetworkValue {
	object, diags := NewNetworkPrivateNetworkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkPrivateNetworkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkPrivateNetworkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkPrivateNetworkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkPrivateNetworkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkPrivateNetworkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkPrivateNetworkValueMust(NetworkPrivateNetworkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkPrivateNetworkType) ValueType(ctx context.Context) attr.Value {
	return NetworkPrivateNetworkValue{}
}

var _ basetypes.ObjectValuable = NetworkPrivateNetworkValue{}

type NetworkPrivateNetworkValue struct {
	Id       ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	SubnetId ovhtypes.TfStringValue `tfsdk:"subnet_id" json:"subnetId"`
	state    attr.ValueState
}

type NetworkPrivateNetworkWritableValue struct {
	*NetworkPrivateNetworkValue `json:"-"`
	Id                          *ovhtypes.TfStringValue `json:"id,omitempty"`
	SubnetId                    *ovhtypes.TfStringValue `json:"subnetId,omitempty"`
}

func (v NetworkPrivateNetworkValue) ToCreate() *NetworkPrivateNetworkWritableValue {
	res := &NetworkPrivateNetworkWritableValue{}

	if !v.Id.IsNull() {
		res.Id = &v.Id
	}

	if !v.SubnetId.IsNull() {
		res.SubnetId = &v.SubnetId
	}

	return res
}

func (v *NetworkPrivateNetworkValue) UnmarshalJSON(data []byte) error {
	type JsonNetworkPrivateNetworkValue NetworkPrivateNetworkValue

	var tmp JsonNetworkPrivateNetworkValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id
	v.SubnetId = tmp.SubnetId

	v.state = attr.ValueStateKnown

	return nil
}

func (v *NetworkPrivateNetworkValue) MergeWith(other *NetworkPrivateNetworkValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.SubnetId.IsUnknown() || v.SubnetId.IsNull()) && !other.SubnetId.IsUnknown() {
		v.SubnetId = other.SubnetId
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v NetworkPrivateNetworkValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id":       v.Id,
		"subnetId": v.SubnetId,
	}
}
func (v NetworkPrivateNetworkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkPrivateNetworkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkPrivateNetworkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkPrivateNetworkValue) String() string {
	return "NetworkPrivateNetworkValue"
}

func (v NetworkPrivateNetworkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":        ovhtypes.TfStringType{},
			"subnet_id": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id":        v.Id,
			"subnet_id": v.SubnetId,
		})

	return objVal, diags
}

func (v NetworkPrivateNetworkValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkPrivateNetworkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v NetworkPrivateNetworkValue) Type(ctx context.Context) attr.Type {
	return NetworkPrivateNetworkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkPrivateNetworkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":        ovhtypes.TfStringType{},
		"subnet_id": ovhtypes.TfStringType{},
	}
}
