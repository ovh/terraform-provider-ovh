// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package cloud_project_rancher

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CloudProjectRancherResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"created_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Date of the managed Rancher service creation",
			MarkdownDescription: "Date of the managed Rancher service creation",
		},
		"current_state": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"bootstrap_password": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Sensitive:           true,
					Description:         "Bootstrap password of the managed Rancher service, returned only on creation",
					MarkdownDescription: "Bootstrap password of the managed Rancher service, returned only on creation",
				},
				"iam_auth_enabled": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Computed:            true,
					Description:         "Allows Rancher to use identities managed by OVHcloud IAM (Identity and Access Management) to control access",
					MarkdownDescription: "Allows Rancher to use identities managed by OVHcloud IAM (Identity and Access Management) to control access",
				},
				"ip_restrictions": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"cidr_block": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
								MarkdownDescription: "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
							},
							"description": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Description of the allowed CIDR block",
								MarkdownDescription: "Description of the allowed CIDR block",
							},
						},
						CustomType: CurrentStateIpRestrictionsType{
							ObjectType: types.ObjectType{
								AttrTypes: CurrentStateIpRestrictionsValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[CurrentStateIpRestrictionsValue](ctx),
					Computed:            true,
					Description:         "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
					MarkdownDescription: "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
				},
				"name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Name of the managed Rancher service",
					MarkdownDescription: "Name of the managed Rancher service",
				},
				"networking": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"egress_cidr_blocks": schema.ListAttribute{
							CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
							Computed:            true,
							Description:         "Specifies the CIDR ranges for egress IP addresses used by Rancher. Ensure these ranges are allowed in any IP restrictions for services that Rancher will access.",
							MarkdownDescription: "Specifies the CIDR ranges for egress IP addresses used by Rancher. Ensure these ranges are allowed in any IP restrictions for services that Rancher will access.",
						},
					},
					CustomType: CurrentStateNetworkingType{
						ObjectType: types.ObjectType{
							AttrTypes: CurrentStateNetworkingValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Networking properties of a managed Rancher service",
					MarkdownDescription: "Networking properties of a managed Rancher service",
				},
				"plan": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Plan of the managed Rancher service",
					MarkdownDescription: "Plan of the managed Rancher service",
				},
				"region": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Region of the managed Rancher service",
					MarkdownDescription: "Region of the managed Rancher service",
				},
				"url": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "URL of the managed Rancher service",
					MarkdownDescription: "URL of the managed Rancher service",
				},
				"usage": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"datetime": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Date of the sample",
							MarkdownDescription: "Date of the sample",
						},
						"orchestrated_vcpus": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "Total number of vCPUs orchestrated by the managed Rancher service through the downstream clusters",
							MarkdownDescription: "Total number of vCPUs orchestrated by the managed Rancher service through the downstream clusters",
						},
					},
					CustomType: CurrentStateUsageType{
						ObjectType: types.ObjectType{
							AttrTypes: CurrentStateUsageValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Latest metrics regarding the usage of the managed Rancher service",
					MarkdownDescription: "Latest metrics regarding the usage of the managed Rancher service",
				},
				"version": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Version of the managed Rancher service",
					MarkdownDescription: "Version of the managed Rancher service",
				},
			},
			CustomType: CurrentStateType{
				ObjectType: types.ObjectType{
					AttrTypes: CurrentStateValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Current configuration applied to the managed Rancher service",
			MarkdownDescription: "Current configuration applied to the managed Rancher service",
		},
		"current_tasks": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Identifier of the current task",
						MarkdownDescription: "Identifier of the current task",
					},
					"link": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Link to the task details",
						MarkdownDescription: "Link to the task details",
					},
					"status": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Current global status of the current task",
						MarkdownDescription: "Current global status of the current task",
					},
					"type": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Type of the current task",
						MarkdownDescription: "Type of the current task",
					},
				},
				CustomType: CurrentTasksType{
					ObjectType: types.ObjectType{
						AttrTypes: CurrentTasksValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[CurrentTasksValue](ctx),
			Computed:            true,
			Description:         "Asynchronous operations ongoing on the managed Rancher service",
			MarkdownDescription: "Asynchronous operations ongoing on the managed Rancher service",
		},
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Unique identifier",
			MarkdownDescription: "Unique identifier",
		},
		"project_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Project ID",
			MarkdownDescription: "Project ID",
		},
		"rancher_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Rancher ID",
			MarkdownDescription: "Rancher ID",
		},
		"resource_status": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Reflects the readiness of the managed Rancher service. A new target specification request will be accepted only in `READY` status",
			MarkdownDescription: "Reflects the readiness of the managed Rancher service. A new target specification request will be accepted only in `READY` status",
		},
		"target_spec": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"iam_auth_enabled": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Optional:            true,
					Computed:            true,
					Description:         "Allows Rancher to use identities managed by OVHcloud IAM (Identity and Access Management) to control access",
					MarkdownDescription: "Allows Rancher to use identities managed by OVHcloud IAM (Identity and Access Management) to control access",
				},
				"ip_restrictions": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"cidr_block": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Optional:            true,
								Description:         "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
								MarkdownDescription: "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
							},
							"description": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Optional:            true,
								Description:         "Description of the allowed CIDR block",
								MarkdownDescription: "Description of the allowed CIDR block",
							},
						},
						CustomType: TargetSpecIpRestrictionsType{
							ObjectType: types.ObjectType{
								AttrTypes: TargetSpecIpRestrictionsValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[TargetSpecIpRestrictionsValue](ctx),
					Computed:            true,
					Optional:            true,
					Description:         "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
					MarkdownDescription: "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
				},
				"name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Required:            true,
					Description:         "Name of the managed Rancher service",
					MarkdownDescription: "Name of the managed Rancher service",
				},
				"plan": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Required:            true,
					Description:         "Plan of the managed Rancher service. Available plans for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/plan",
					MarkdownDescription: "Plan of the managed Rancher service. Available plans for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/plan",
					Validators: []validator.String{
						stringvalidator.OneOf(
							"OVHCLOUD_EDITION",
							"STANDARD",
						),
					},
				},
				"version": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Version of the managed Rancher service. Available versions for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/version. Default is the latest version.",
					MarkdownDescription: "Version of the managed Rancher service. Available versions for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/version. Default is the latest version.",
				},
			},
			CustomType: TargetSpecType{
				ObjectType: types.ObjectType{
					AttrTypes: TargetSpecValue{}.AttributeTypes(ctx),
				},
			},
			Required:            true,
			Description:         "Target specification for the managed Rancher service",
			MarkdownDescription: "Target specification for the managed Rancher service",
		},
		"updated_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Date of the last managed Rancher service update",
			MarkdownDescription: "Date of the last managed Rancher service update",
		},
	}

	return schema.Schema{
		Description: "",
		Attributes:  attrs,
	}
}

type CloudProjectRancherModel struct {
	CreatedAt      ovhtypes.TfStringValue                        `tfsdk:"created_at" json:"createdAt"`
	CurrentState   CurrentStateValue                             `tfsdk:"current_state" json:"currentState"`
	CurrentTasks   ovhtypes.TfListNestedValue[CurrentTasksValue] `tfsdk:"current_tasks" json:"currentTasks"`
	Id             ovhtypes.TfStringValue                        `tfsdk:"id" json:"id"`
	ProjectId      ovhtypes.TfStringValue                        `tfsdk:"project_id" json:"projectId"`
	RancherId      ovhtypes.TfStringValue                        `tfsdk:"rancher_id" json:"rancherId"`
	ResourceStatus ovhtypes.TfStringValue                        `tfsdk:"resource_status" json:"resourceStatus"`
	TargetSpec     TargetSpecValue                               `tfsdk:"target_spec" json:"targetSpec"`
	UpdatedAt      ovhtypes.TfStringValue                        `tfsdk:"updated_at" json:"updatedAt"`
}

func (v *CloudProjectRancherModel) MergeWith(other *CloudProjectRancherModel) {

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if v.CurrentState.IsUnknown() && !other.CurrentState.IsUnknown() {
		v.CurrentState = other.CurrentState
	} else if !other.CurrentState.IsUnknown() {
		v.CurrentState.MergeWith(&other.CurrentState)
	}

	if (v.CurrentTasks.IsUnknown() || v.CurrentTasks.IsNull()) && !other.CurrentTasks.IsUnknown() {
		v.CurrentTasks = other.CurrentTasks
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.ProjectId.IsUnknown() || v.ProjectId.IsNull()) && !other.ProjectId.IsUnknown() {
		v.ProjectId = other.ProjectId
	}

	if (v.RancherId.IsUnknown() || v.RancherId.IsNull()) && !other.RancherId.IsUnknown() {
		v.RancherId = other.RancherId
	}

	if (v.ResourceStatus.IsUnknown() || v.ResourceStatus.IsNull()) && !other.ResourceStatus.IsUnknown() {
		v.ResourceStatus = other.ResourceStatus
	}

	if v.TargetSpec.IsUnknown() && !other.TargetSpec.IsUnknown() {
		v.TargetSpec = other.TargetSpec
	} else if !other.TargetSpec.IsUnknown() {
		v.TargetSpec.MergeWith(&other.TargetSpec)
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

}

func (v CloudProjectRancherModel) ToCreate() *CloudProjectRancherModel {
	res := &CloudProjectRancherModel{}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = *v.TargetSpec.ToCreate()
	}

	return res
}

func (v CloudProjectRancherModel) ToUpdate() *CloudProjectRancherModel {
	res := &CloudProjectRancherModel{}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = *v.TargetSpec.ToUpdate()
	}

	return res
}

func (v *CloudProjectRancherModel) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.TargetSpec.IsNull() && !v.TargetSpec.IsUnknown() {
		toMarshal["targetSpec"] = v.TargetSpec
	}

	return json.Marshal(toMarshal)
}

var _ basetypes.ObjectTypable = CurrentStateType{}

type CurrentStateType struct {
	basetypes.ObjectType
}

func (t CurrentStateType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateType) String() string {
	return "CurrentStateType"
}

func (t CurrentStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bootstrapPasswordAttribute, ok := attributes["bootstrap_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_password is missing from object`)

		return nil, diags
	}

	bootstrapPasswordVal, ok := bootstrapPasswordAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_password expected to be ovhtypes.TfStringValue, was: %T`, bootstrapPasswordAttribute))
	}

	iamAuthEnabledAttribute, ok := attributes["iam_auth_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_auth_enabled is missing from object`)

		return nil, diags
	}

	iamAuthEnabledVal, ok := iamAuthEnabledAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_auth_enabled expected to be ovhtypes.TfBoolValue, was: %T`, iamAuthEnabledAttribute))
	}

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return nil, diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	networkingAttribute, ok := attributes["networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networking is missing from object`)

		return nil, diags
	}

	networkingVal, ok := networkingAttribute.(CurrentStateNetworkingValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networking expected to be CurrentStateNetworkingValue, was: %T`, networkingAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return nil, diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(CurrentStateUsageValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be CurrentStateUsageValue, was: %T`, usageAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateValue{
		BootstrapPassword: bootstrapPasswordVal,
		IamAuthEnabled:    iamAuthEnabledVal,
		IpRestrictions:    ipRestrictionsVal,
		Name:              nameVal,
		Networking:        networkingVal,
		Plan:              planVal,
		Region:            regionVal,
		Url:               urlVal,
		Usage:             usageVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateValueNull() CurrentStateValue {
	return CurrentStateValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateValueUnknown() CurrentStateValue {
	return CurrentStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateValue Attribute Value",
				"While creating a CurrentStateValue value, a missing attribute value was detected. "+
					"A CurrentStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateValue Attribute Type",
				"While creating a CurrentStateValue value, an invalid attribute value was detected. "+
					"A CurrentStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateValue Attribute Value",
				"While creating a CurrentStateValue value, an extra attribute value was detected. "+
					"A CurrentStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateValueUnknown(), diags
	}

	bootstrapPasswordAttribute, ok := attributes["bootstrap_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_password is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	bootstrapPasswordVal, ok := bootstrapPasswordAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_password expected to be ovhtypes.TfStringValue, was: %T`, bootstrapPasswordAttribute))
	}

	iamAuthEnabledAttribute, ok := attributes["iam_auth_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_auth_enabled is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	iamAuthEnabledVal, ok := iamAuthEnabledAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_auth_enabled expected to be ovhtypes.TfBoolValue, was: %T`, iamAuthEnabledAttribute))
	}

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	networkingAttribute, ok := attributes["networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networking is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	networkingVal, ok := networkingAttribute.(CurrentStateNetworkingValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networking expected to be CurrentStateNetworkingValue, was: %T`, networkingAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(CurrentStateUsageValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be CurrentStateUsageValue, was: %T`, usageAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewCurrentStateValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateValueUnknown(), diags
	}

	return CurrentStateValue{
		BootstrapPassword: bootstrapPasswordVal,
		IamAuthEnabled:    iamAuthEnabledVal,
		IpRestrictions:    ipRestrictionsVal,
		Name:              nameVal,
		Networking:        networkingVal,
		Plan:              planVal,
		Region:            regionVal,
		Url:               urlVal,
		Usage:             usageVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateValue {
	object, diags := NewCurrentStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateValueMust(CurrentStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateValue{}
}

var _ basetypes.ObjectValuable = CurrentStateValue{}

type CurrentStateValue struct {
	BootstrapPassword ovhtypes.TfStringValue                                      `tfsdk:"bootstrap_password" json:"bootstrapPassword"`
	IamAuthEnabled    ovhtypes.TfBoolValue                                        `tfsdk:"iam_auth_enabled" json:"iamAuthEnabled"`
	IpRestrictions    ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue] `tfsdk:"ip_restrictions" json:"ipRestrictions"`
	Name              ovhtypes.TfStringValue                                      `tfsdk:"name" json:"name"`
	Networking        CurrentStateNetworkingValue                                 `tfsdk:"networking" json:"networking"`
	Plan              ovhtypes.TfStringValue                                      `tfsdk:"plan" json:"plan"`
	Region            ovhtypes.TfStringValue                                      `tfsdk:"region" json:"region"`
	Url               ovhtypes.TfStringValue                                      `tfsdk:"url" json:"url"`
	Usage             CurrentStateUsageValue                                      `tfsdk:"usage" json:"usage"`
	Version           ovhtypes.TfStringValue                                      `tfsdk:"version" json:"version"`
	state             attr.ValueState
}

func (v CurrentStateValue) ToCreate() *CurrentStateValue {
	res := &CurrentStateValue{}

	if !v.IamAuthEnabled.IsNull() {
		res.IamAuthEnabled = v.IamAuthEnabled
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v CurrentStateValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.IamAuthEnabled.IsNull() && !v.IamAuthEnabled.IsUnknown() {
		toMarshal["iamAuthEnabled"] = v.IamAuthEnabled
	}

	return json.Marshal(toMarshal)
}

func (v *CurrentStateValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateValue CurrentStateValue

	var tmp JsonCurrentStateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.BootstrapPassword = tmp.BootstrapPassword
	v.IamAuthEnabled = tmp.IamAuthEnabled
	v.IpRestrictions = tmp.IpRestrictions
	v.Name = tmp.Name
	v.Networking = tmp.Networking
	v.Plan = tmp.Plan
	v.Region = tmp.Region
	v.Url = tmp.Url
	v.Usage = tmp.Usage
	v.Version = tmp.Version

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateValue) MergeWith(other *CurrentStateValue) {

	if (v.BootstrapPassword.IsUnknown() || v.BootstrapPassword.IsNull()) && !other.BootstrapPassword.IsUnknown() {
		v.BootstrapPassword = other.BootstrapPassword
	}

	if (v.IamAuthEnabled.IsUnknown() || v.IamAuthEnabled.IsNull()) && !other.IamAuthEnabled.IsUnknown() {
		v.IamAuthEnabled = other.IamAuthEnabled
	}

	if (v.IpRestrictions.IsUnknown() || v.IpRestrictions.IsNull()) && !other.IpRestrictions.IsUnknown() {
		v.IpRestrictions = other.IpRestrictions
	} else if !other.IpRestrictions.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.IpRestrictions.Elements()
		newElems := other.IpRestrictions.Elements()

		if len(elems) != len(newElems) {
			v.IpRestrictions = other.IpRestrictions
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentStateIpRestrictionsValue)
				tmp2 := newElems[idx].(CurrentStateIpRestrictionsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.IpRestrictions = ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue]{
				ListValue: basetypes.NewListValueMust(CurrentStateIpRestrictionsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if v.Networking.IsUnknown() && !other.Networking.IsUnknown() {
		v.Networking = other.Networking
	} else if !other.Networking.IsUnknown() {
		v.Networking.MergeWith(&other.Networking)
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if v.Usage.IsUnknown() && !other.Usage.IsUnknown() {
		v.Usage = other.Usage
	} else if !other.Usage.IsUnknown() {
		v.Usage.MergeWith(&other.Usage)
	}

	if (v.Version.IsUnknown() || v.Version.IsNull()) && !other.Version.IsUnknown() {
		v.Version = other.Version
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"bootstrapPassword": v.BootstrapPassword,
		"iamAuthEnabled":    v.IamAuthEnabled,
		"ipRestrictions":    v.IpRestrictions,
		"name":              v.Name,
		"networking":        v.Networking,
		"plan":              v.Plan,
		"region":            v.Region,
		"url":               v.Url,
		"usage":             v.Usage,
		"version":           v.Version,
	}
}
func (v CurrentStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["bootstrap_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["iam_auth_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_restrictions"] = basetypes.ListType{
		ElemType: CurrentStateIpRestrictionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networking"] = basetypes.ObjectType{
		AttrTypes: CurrentStateNetworkingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["plan"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.ObjectType{
		AttrTypes: CurrentStateUsageValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.BootstrapPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootstrap_password"] = val

		val, err = v.IamAuthEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_auth_enabled"] = val

		val, err = v.IpRestrictions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_restrictions"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networking"] = val

		val, err = v.Plan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateValue) String() string {
	return "CurrentStateValue"
}

func (v CurrentStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bootstrap_password": ovhtypes.TfStringType{},
			"iam_auth_enabled":   ovhtypes.TfBoolType{},
			"ip_restrictions":    ovhtypes.NewTfListNestedType[CurrentStateIpRestrictionsValue](ctx),
			"name":               ovhtypes.TfStringType{},
			"networking": CurrentStateNetworkingType{
				basetypes.ObjectType{
					AttrTypes: CurrentStateNetworkingValue{}.AttributeTypes(ctx),
				},
			},
			"plan":   ovhtypes.TfStringType{},
			"region": ovhtypes.TfStringType{},
			"url":    ovhtypes.TfStringType{},
			"usage": CurrentStateUsageType{
				basetypes.ObjectType{
					AttrTypes: CurrentStateUsageValue{}.AttributeTypes(ctx),
				},
			},
			"version": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"bootstrap_password": v.BootstrapPassword,
			"iam_auth_enabled":   v.IamAuthEnabled,
			"ip_restrictions":    v.IpRestrictions,
			"name":               v.Name,
			"networking":         v.Networking,
			"plan":               v.Plan,
			"region":             v.Region,
			"url":                v.Url,
			"usage":              v.Usage,
			"version":            v.Version,
		})

	return objVal, diags
}

func (v CurrentStateValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BootstrapPassword.Equal(other.BootstrapPassword) {
		return false
	}

	if !v.IamAuthEnabled.Equal(other.IamAuthEnabled) {
		return false
	}

	if !v.IpRestrictions.Equal(other.IpRestrictions) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networking.Equal(other.Networking) {
		return false
	}

	if !v.Plan.Equal(other.Plan) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v CurrentStateValue) Type(ctx context.Context) attr.Type {
	return CurrentStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bootstrap_password": ovhtypes.TfStringType{},
		"iam_auth_enabled":   ovhtypes.TfBoolType{},
		"ip_restrictions":    ovhtypes.NewTfListNestedType[CurrentStateIpRestrictionsValue](ctx),
		"name":               ovhtypes.TfStringType{},
		"networking":         CurrentStateNetworkingValue{}.Type(ctx),
		"plan":               ovhtypes.TfStringType{},
		"region":             ovhtypes.TfStringType{},
		"url":                ovhtypes.TfStringType{},
		"usage":              CurrentStateUsageValue{}.Type(ctx),
		"version":            ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateIpRestrictionsType{}

type CurrentStateIpRestrictionsType struct {
	basetypes.ObjectType
}

func (t CurrentStateIpRestrictionsType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateIpRestrictionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateIpRestrictionsType) String() string {
	return "CurrentStateIpRestrictionsType"
}

func (t CurrentStateIpRestrictionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return nil, diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateIpRestrictionsValueNull() CurrentStateIpRestrictionsValue {
	return CurrentStateIpRestrictionsValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateIpRestrictionsValueUnknown() CurrentStateIpRestrictionsValue {
	return CurrentStateIpRestrictionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateIpRestrictionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateIpRestrictionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateIpRestrictionsValue Attribute Value",
				"While creating a CurrentStateIpRestrictionsValue value, a missing attribute value was detected. "+
					"A CurrentStateIpRestrictionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateIpRestrictionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateIpRestrictionsValue Attribute Type",
				"While creating a CurrentStateIpRestrictionsValue value, an invalid attribute value was detected. "+
					"A CurrentStateIpRestrictionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateIpRestrictionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateIpRestrictionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateIpRestrictionsValue Attribute Value",
				"While creating a CurrentStateIpRestrictionsValue value, an extra attribute value was detected. "+
					"A CurrentStateIpRestrictionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateIpRestrictionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	return CurrentStateIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateIpRestrictionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateIpRestrictionsValue {
	object, diags := NewCurrentStateIpRestrictionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateIpRestrictionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateIpRestrictionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateIpRestrictionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateIpRestrictionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateIpRestrictionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateIpRestrictionsValueMust(CurrentStateIpRestrictionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateIpRestrictionsType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateIpRestrictionsValue{}
}

var _ basetypes.ObjectValuable = CurrentStateIpRestrictionsValue{}

type CurrentStateIpRestrictionsValue struct {
	CidrBlock   ovhtypes.TfStringValue `tfsdk:"cidr_block" json:"cidrBlock"`
	Description ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	state       attr.ValueState
}

func (v *CurrentStateIpRestrictionsValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateIpRestrictionsValue CurrentStateIpRestrictionsValue

	var tmp JsonCurrentStateIpRestrictionsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CidrBlock = tmp.CidrBlock
	v.Description = tmp.Description

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateIpRestrictionsValue) MergeWith(other *CurrentStateIpRestrictionsValue) {

	if (v.CidrBlock.IsUnknown() || v.CidrBlock.IsNull()) && !other.CidrBlock.IsUnknown() {
		v.CidrBlock = other.CidrBlock
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateIpRestrictionsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidrBlock":   v.CidrBlock,
		"description": v.Description,
	}
}
func (v CurrentStateIpRestrictionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cidr_block"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CidrBlock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr_block"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateIpRestrictionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateIpRestrictionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateIpRestrictionsValue) String() string {
	return "CurrentStateIpRestrictionsValue"
}

func (v CurrentStateIpRestrictionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr_block":  ovhtypes.TfStringType{},
			"description": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cidr_block":  v.CidrBlock,
			"description": v.Description,
		})

	return objVal, diags
}

func (v CurrentStateIpRestrictionsValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateIpRestrictionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CidrBlock.Equal(other.CidrBlock) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	return true
}

func (v CurrentStateIpRestrictionsValue) Type(ctx context.Context) attr.Type {
	return CurrentStateIpRestrictionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateIpRestrictionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr_block":  ovhtypes.TfStringType{},
		"description": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateNetworkingType{}

type CurrentStateNetworkingType struct {
	basetypes.ObjectType
}

func (t CurrentStateNetworkingType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateNetworkingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateNetworkingType) String() string {
	return "CurrentStateNetworkingType"
}

func (t CurrentStateNetworkingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egressCidrBlocksAttribute, ok := attributes["egress_cidr_blocks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_cidr_blocks is missing from object`)

		return nil, diags
	}

	egressCidrBlocksVal, ok := egressCidrBlocksAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_cidr_blocks expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, egressCidrBlocksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateNetworkingValue{
		EgressCidrBlocks: egressCidrBlocksVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateNetworkingValueNull() CurrentStateNetworkingValue {
	return CurrentStateNetworkingValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateNetworkingValueUnknown() CurrentStateNetworkingValue {
	return CurrentStateNetworkingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateNetworkingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateNetworkingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateNetworkingValue Attribute Value",
				"While creating a CurrentStateNetworkingValue value, a missing attribute value was detected. "+
					"A CurrentStateNetworkingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateNetworkingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateNetworkingValue Attribute Type",
				"While creating a CurrentStateNetworkingValue value, an invalid attribute value was detected. "+
					"A CurrentStateNetworkingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateNetworkingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateNetworkingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateNetworkingValue Attribute Value",
				"While creating a CurrentStateNetworkingValue value, an extra attribute value was detected. "+
					"A CurrentStateNetworkingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateNetworkingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateNetworkingValueUnknown(), diags
	}

	egressCidrBlocksAttribute, ok := attributes["egress_cidr_blocks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_cidr_blocks is missing from object`)

		return NewCurrentStateNetworkingValueUnknown(), diags
	}

	egressCidrBlocksVal, ok := egressCidrBlocksAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_cidr_blocks expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, egressCidrBlocksAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateNetworkingValueUnknown(), diags
	}

	return CurrentStateNetworkingValue{
		EgressCidrBlocks: egressCidrBlocksVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateNetworkingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateNetworkingValue {
	object, diags := NewCurrentStateNetworkingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateNetworkingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateNetworkingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateNetworkingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateNetworkingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateNetworkingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateNetworkingValueMust(CurrentStateNetworkingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateNetworkingType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateNetworkingValue{}
}

var _ basetypes.ObjectValuable = CurrentStateNetworkingValue{}

type CurrentStateNetworkingValue struct {
	EgressCidrBlocks ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"egress_cidr_blocks" json:"egressCidrBlocks"`
	state            attr.ValueState
}

func (v *CurrentStateNetworkingValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateNetworkingValue CurrentStateNetworkingValue

	var tmp JsonCurrentStateNetworkingValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.EgressCidrBlocks = tmp.EgressCidrBlocks

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateNetworkingValue) MergeWith(other *CurrentStateNetworkingValue) {

	if (v.EgressCidrBlocks.IsUnknown() || v.EgressCidrBlocks.IsNull()) && !other.EgressCidrBlocks.IsUnknown() {
		v.EgressCidrBlocks = other.EgressCidrBlocks
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateNetworkingValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"egressCidrBlocks": v.EgressCidrBlocks,
	}
}
func (v CurrentStateNetworkingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["egress_cidr_blocks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.EgressCidrBlocks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress_cidr_blocks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateNetworkingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateNetworkingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateNetworkingValue) String() string {
	return "CurrentStateNetworkingValue"
}

func (v CurrentStateNetworkingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"egress_cidr_blocks": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		},
		map[string]attr.Value{
			"egress_cidr_blocks": v.EgressCidrBlocks,
		})

	return objVal, diags
}

func (v CurrentStateNetworkingValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateNetworkingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EgressCidrBlocks.Equal(other.EgressCidrBlocks) {
		return false
	}

	return true
}

func (v CurrentStateNetworkingValue) Type(ctx context.Context) attr.Type {
	return CurrentStateNetworkingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateNetworkingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress_cidr_blocks": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
	}
}

var _ basetypes.ObjectTypable = CurrentStateUsageType{}

type CurrentStateUsageType struct {
	basetypes.ObjectType
}

func (t CurrentStateUsageType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateUsageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateUsageType) String() string {
	return "CurrentStateUsageType"
}

func (t CurrentStateUsageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	datetimeAttribute, ok := attributes["datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datetime is missing from object`)

		return nil, diags
	}

	datetimeVal, ok := datetimeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datetime expected to be ovhtypes.TfStringValue, was: %T`, datetimeAttribute))
	}

	orchestratedVcpusAttribute, ok := attributes["orchestrated_vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`orchestrated_vcpus is missing from object`)

		return nil, diags
	}

	orchestratedVcpusVal, ok := orchestratedVcpusAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`orchestrated_vcpus expected to be ovhtypes.TfInt64Value, was: %T`, orchestratedVcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateUsageValue{
		Datetime:          datetimeVal,
		OrchestratedVcpus: orchestratedVcpusVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateUsageValueNull() CurrentStateUsageValue {
	return CurrentStateUsageValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateUsageValueUnknown() CurrentStateUsageValue {
	return CurrentStateUsageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateUsageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateUsageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateUsageValue Attribute Value",
				"While creating a CurrentStateUsageValue value, a missing attribute value was detected. "+
					"A CurrentStateUsageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateUsageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateUsageValue Attribute Type",
				"While creating a CurrentStateUsageValue value, an invalid attribute value was detected. "+
					"A CurrentStateUsageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateUsageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateUsageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateUsageValue Attribute Value",
				"While creating a CurrentStateUsageValue value, an extra attribute value was detected. "+
					"A CurrentStateUsageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateUsageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateUsageValueUnknown(), diags
	}

	datetimeAttribute, ok := attributes["datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datetime is missing from object`)

		return NewCurrentStateUsageValueUnknown(), diags
	}

	datetimeVal, ok := datetimeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datetime expected to be ovhtypes.TfStringValue, was: %T`, datetimeAttribute))
	}

	orchestratedVcpusAttribute, ok := attributes["orchestrated_vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`orchestrated_vcpus is missing from object`)

		return NewCurrentStateUsageValueUnknown(), diags
	}

	orchestratedVcpusVal, ok := orchestratedVcpusAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`orchestrated_vcpus expected to be ovhtypes.TfInt64Value, was: %T`, orchestratedVcpusAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateUsageValueUnknown(), diags
	}

	return CurrentStateUsageValue{
		Datetime:          datetimeVal,
		OrchestratedVcpus: orchestratedVcpusVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateUsageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateUsageValue {
	object, diags := NewCurrentStateUsageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateUsageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateUsageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateUsageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateUsageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateUsageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateUsageValueMust(CurrentStateUsageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateUsageType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateUsageValue{}
}

var _ basetypes.ObjectValuable = CurrentStateUsageValue{}

type CurrentStateUsageValue struct {
	Datetime          ovhtypes.TfStringValue `tfsdk:"datetime" json:"datetime"`
	OrchestratedVcpus ovhtypes.TfInt64Value  `tfsdk:"orchestrated_vcpus" json:"orchestratedVcpus"`
	state             attr.ValueState
}

func (v *CurrentStateUsageValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateUsageValue CurrentStateUsageValue

	var tmp JsonCurrentStateUsageValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Datetime = tmp.Datetime
	v.OrchestratedVcpus = tmp.OrchestratedVcpus

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateUsageValue) MergeWith(other *CurrentStateUsageValue) {

	if (v.Datetime.IsUnknown() || v.Datetime.IsNull()) && !other.Datetime.IsUnknown() {
		v.Datetime = other.Datetime
	}

	if (v.OrchestratedVcpus.IsUnknown() || v.OrchestratedVcpus.IsNull()) && !other.OrchestratedVcpus.IsUnknown() {
		v.OrchestratedVcpus = other.OrchestratedVcpus
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateUsageValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"datetime":          v.Datetime,
		"orchestratedVcpus": v.OrchestratedVcpus,
	}
}
func (v CurrentStateUsageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["datetime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["orchestrated_vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Datetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datetime"] = val

		val, err = v.OrchestratedVcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["orchestrated_vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateUsageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateUsageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateUsageValue) String() string {
	return "CurrentStateUsageValue"
}

func (v CurrentStateUsageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"datetime":           ovhtypes.TfStringType{},
			"orchestrated_vcpus": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"datetime":           v.Datetime,
			"orchestrated_vcpus": v.OrchestratedVcpus,
		})

	return objVal, diags
}

func (v CurrentStateUsageValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateUsageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Datetime.Equal(other.Datetime) {
		return false
	}

	if !v.OrchestratedVcpus.Equal(other.OrchestratedVcpus) {
		return false
	}

	return true
}

func (v CurrentStateUsageValue) Type(ctx context.Context) attr.Type {
	return CurrentStateUsageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateUsageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"datetime":           ovhtypes.TfStringType{},
		"orchestrated_vcpus": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = CurrentTasksType{}

type CurrentTasksType struct {
	basetypes.ObjectType
}

func (t CurrentTasksType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentTasksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentTasksType) String() string {
	return "CurrentTasksType"
}

func (t CurrentTasksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return nil, diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentTasksValue{
		Id:               idVal,
		Link:             linkVal,
		Status:           statusVal,
		CurrentTasksType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentTasksValueNull() CurrentTasksValue {
	return CurrentTasksValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentTasksValueUnknown() CurrentTasksValue {
	return CurrentTasksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentTasksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentTasksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentTasksValue Attribute Value",
				"While creating a CurrentTasksValue value, a missing attribute value was detected. "+
					"A CurrentTasksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentTasksValue Attribute Type",
				"While creating a CurrentTasksValue value, an invalid attribute value was detected. "+
					"A CurrentTasksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentTasksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentTasksValue Attribute Value",
				"While creating a CurrentTasksValue value, an extra attribute value was detected. "+
					"A CurrentTasksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentTasksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentTasksValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewCurrentTasksValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewCurrentTasksValueUnknown(), diags
	}

	return CurrentTasksValue{
		Id:               idVal,
		Link:             linkVal,
		Status:           statusVal,
		CurrentTasksType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentTasksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentTasksValue {
	object, diags := NewCurrentTasksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentTasksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentTasksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentTasksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentTasksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentTasksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentTasksValueMust(CurrentTasksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentTasksType) ValueType(ctx context.Context) attr.Value {
	return CurrentTasksValue{}
}

var _ basetypes.ObjectValuable = CurrentTasksValue{}

type CurrentTasksValue struct {
	Id               ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	Link             ovhtypes.TfStringValue `tfsdk:"link" json:"link"`
	Status           ovhtypes.TfStringValue `tfsdk:"status" json:"status"`
	CurrentTasksType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state            attr.ValueState
}

func (v *CurrentTasksValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentTasksValue CurrentTasksValue

	var tmp JsonCurrentTasksValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id
	v.Link = tmp.Link
	v.Status = tmp.Status
	v.CurrentTasksType = tmp.CurrentTasksType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentTasksValue) MergeWith(other *CurrentTasksValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Link.IsUnknown() || v.Link.IsNull()) && !other.Link.IsUnknown() {
		v.Link = other.Link
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.CurrentTasksType.IsUnknown() || v.CurrentTasksType.IsNull()) && !other.CurrentTasksType.IsUnknown() {
		v.CurrentTasksType = other.CurrentTasksType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentTasksValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id":     v.Id,
		"link":   v.Link,
		"status": v.Status,
		"type":   v.CurrentTasksType,
	}
}
func (v CurrentTasksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Link.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.CurrentTasksType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentTasksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentTasksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentTasksValue) String() string {
	return "CurrentTasksValue"
}

func (v CurrentTasksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":     ovhtypes.TfStringType{},
			"link":   ovhtypes.TfStringType{},
			"status": ovhtypes.TfStringType{},
			"type":   ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id":     v.Id,
			"link":   v.Link,
			"status": v.Status,
			"type":   v.CurrentTasksType,
		})

	return objVal, diags
}

func (v CurrentTasksValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentTasksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Link.Equal(other.Link) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.CurrentTasksType.Equal(other.CurrentTasksType) {
		return false
	}

	return true
}

func (v CurrentTasksValue) Type(ctx context.Context) attr.Type {
	return CurrentTasksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentTasksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":     ovhtypes.TfStringType{},
		"link":   ovhtypes.TfStringType{},
		"status": ovhtypes.TfStringType{},
		"type":   ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TargetSpecType{}

type TargetSpecType struct {
	basetypes.ObjectType
}

func (t TargetSpecType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecType) String() string {
	return "TargetSpecType"
}

func (t TargetSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	iamAuthEnabledAttribute, ok := attributes["iam_auth_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_auth_enabled is missing from object`)

		return nil, diags
	}

	iamAuthEnabledVal, ok := iamAuthEnabledAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_auth_enabled expected to be ovhtypes.TfBoolValue, was: %T`, iamAuthEnabledAttribute))
	}

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return nil, diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return nil, diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecValue{
		IamAuthEnabled: iamAuthEnabledVal,
		IpRestrictions: ipRestrictionsVal,
		Name:           nameVal,
		Plan:           planVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecValueNull() TargetSpecValue {
	return TargetSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecValueUnknown() TargetSpecValue {
	return TargetSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecValue Attribute Value",
				"While creating a TargetSpecValue value, a missing attribute value was detected. "+
					"A TargetSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecValue Attribute Type",
				"While creating a TargetSpecValue value, an invalid attribute value was detected. "+
					"A TargetSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecValue Attribute Value",
				"While creating a TargetSpecValue value, an extra attribute value was detected. "+
					"A TargetSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecValueUnknown(), diags
	}

	iamAuthEnabledAttribute, ok := attributes["iam_auth_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_auth_enabled is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	iamAuthEnabledVal, ok := iamAuthEnabledAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_auth_enabled expected to be ovhtypes.TfBoolValue, was: %T`, iamAuthEnabledAttribute))
	}

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewTargetSpecValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecValueUnknown(), diags
	}

	return TargetSpecValue{
		IamAuthEnabled: iamAuthEnabledVal,
		IpRestrictions: ipRestrictionsVal,
		Name:           nameVal,
		Plan:           planVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecValue {
	object, diags := NewTargetSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecValueMust(TargetSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecValue{}
}

var _ basetypes.ObjectValuable = TargetSpecValue{}

type TargetSpecValue struct {
	IamAuthEnabled ovhtypes.TfBoolValue                                      `tfsdk:"iam_auth_enabled" json:"iamAuthEnabled"`
	IpRestrictions ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue] `tfsdk:"ip_restrictions" json:"ipRestrictions"`
	Name           ovhtypes.TfStringValue                                    `tfsdk:"name" json:"name"`
	Plan           ovhtypes.TfStringValue                                    `tfsdk:"plan" json:"plan"`
	Version        ovhtypes.TfStringValue                                    `tfsdk:"version" json:"version"`
	state          attr.ValueState
}

func (v TargetSpecValue) ToCreate() *TargetSpecValue {
	res := &TargetSpecValue{}

	if !v.Name.IsNull() {
		res.Name = v.Name
	}

	if !v.Plan.IsNull() {
		res.Plan = v.Plan
	}

	if !v.Version.IsNull() {
		res.Version = v.Version
	}

	if !v.IamAuthEnabled.IsNull() {
		res.IamAuthEnabled = v.IamAuthEnabled
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v TargetSpecValue) ToUpdate() *TargetSpecValue {
	res := &TargetSpecValue{}

	if !v.Name.IsNull() {
		res.Name = v.Name
	}

	if !v.Plan.IsNull() {
		res.Plan = v.Plan
	}

	if !v.Version.IsNull() {
		res.Version = v.Version
	}

	if !v.IpRestrictions.IsNull() {
		res.IpRestrictions = v.IpRestrictions
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v TargetSpecValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.IamAuthEnabled.IsNull() && !v.IamAuthEnabled.IsUnknown() {
		toMarshal["iamAuthEnabled"] = v.IamAuthEnabled
	}
	if !v.IpRestrictions.IsNull() && !v.IpRestrictions.IsUnknown() {
		toMarshal["ipRestrictions"] = v.IpRestrictions
	}
	if !v.Name.IsNull() && !v.Name.IsUnknown() {
		toMarshal["name"] = v.Name
	}
	if !v.Plan.IsNull() && !v.Plan.IsUnknown() {
		toMarshal["plan"] = v.Plan
	}
	if !v.Version.IsNull() && !v.Version.IsUnknown() {
		toMarshal["version"] = v.Version
	}

	return json.Marshal(toMarshal)
}

func (v *TargetSpecValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecValue TargetSpecValue

	var tmp JsonTargetSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.IamAuthEnabled = tmp.IamAuthEnabled
	v.IpRestrictions = tmp.IpRestrictions
	v.Name = tmp.Name
	v.Plan = tmp.Plan
	v.Version = tmp.Version

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecValue) MergeWith(other *TargetSpecValue) {

	if (v.IamAuthEnabled.IsUnknown() || v.IamAuthEnabled.IsNull()) && !other.IamAuthEnabled.IsUnknown() {
		v.IamAuthEnabled = other.IamAuthEnabled
	}

	if (v.IpRestrictions.IsUnknown() || v.IpRestrictions.IsNull()) && !other.IpRestrictions.IsUnknown() {
		v.IpRestrictions = other.IpRestrictions
	} else if !other.IpRestrictions.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.IpRestrictions.Elements()
		newElems := other.IpRestrictions.Elements()

		if len(elems) != len(newElems) {
			v.IpRestrictions = other.IpRestrictions
		} else {
			for idx, e := range elems {
				tmp := e.(TargetSpecIpRestrictionsValue)
				tmp2 := newElems[idx].(TargetSpecIpRestrictionsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.IpRestrictions = ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue]{
				ListValue: basetypes.NewListValueMust(TargetSpecIpRestrictionsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	}

	if (v.Version.IsUnknown() || v.Version.IsNull()) && !other.Version.IsUnknown() {
		v.Version = other.Version
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"iamAuthEnabled": v.IamAuthEnabled,
		"ipRestrictions": v.IpRestrictions,
		"name":           v.Name,
		"plan":           v.Plan,
		"version":        v.Version,
	}
}
func (v TargetSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["iam_auth_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_restrictions"] = basetypes.ListType{
		ElemType: TargetSpecIpRestrictionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.IamAuthEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_auth_enabled"] = val

		val, err = v.IpRestrictions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_restrictions"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Plan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecValue) String() string {
	return "TargetSpecValue"
}

func (v TargetSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"iam_auth_enabled": ovhtypes.TfBoolType{},
			"ip_restrictions":  ovhtypes.NewTfListNestedType[TargetSpecIpRestrictionsValue](ctx),
			"name":             ovhtypes.TfStringType{},
			"plan":             ovhtypes.TfStringType{},
			"version":          ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"iam_auth_enabled": v.IamAuthEnabled,
			"ip_restrictions":  v.IpRestrictions,
			"name":             v.Name,
			"plan":             v.Plan,
			"version":          v.Version,
		})

	return objVal, diags
}

func (v TargetSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IamAuthEnabled.Equal(other.IamAuthEnabled) {
		return false
	}

	if !v.IpRestrictions.Equal(other.IpRestrictions) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Plan.Equal(other.Plan) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v TargetSpecValue) Type(ctx context.Context) attr.Type {
	return TargetSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"iam_auth_enabled": ovhtypes.TfBoolType{},
		"ip_restrictions":  ovhtypes.NewTfListNestedType[TargetSpecIpRestrictionsValue](ctx),
		"name":             ovhtypes.TfStringType{},
		"plan":             ovhtypes.TfStringType{},
		"version":          ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TargetSpecIpRestrictionsType{}

type TargetSpecIpRestrictionsType struct {
	basetypes.ObjectType
}

func (t TargetSpecIpRestrictionsType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecIpRestrictionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecIpRestrictionsType) String() string {
	return "TargetSpecIpRestrictionsType"
}

func (t TargetSpecIpRestrictionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return nil, diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecIpRestrictionsValueNull() TargetSpecIpRestrictionsValue {
	return TargetSpecIpRestrictionsValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecIpRestrictionsValueUnknown() TargetSpecIpRestrictionsValue {
	return TargetSpecIpRestrictionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecIpRestrictionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecIpRestrictionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecIpRestrictionsValue Attribute Value",
				"While creating a TargetSpecIpRestrictionsValue value, a missing attribute value was detected. "+
					"A TargetSpecIpRestrictionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecIpRestrictionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecIpRestrictionsValue Attribute Type",
				"While creating a TargetSpecIpRestrictionsValue value, an invalid attribute value was detected. "+
					"A TargetSpecIpRestrictionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecIpRestrictionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecIpRestrictionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecIpRestrictionsValue Attribute Value",
				"While creating a TargetSpecIpRestrictionsValue value, an extra attribute value was detected. "+
					"A TargetSpecIpRestrictionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecIpRestrictionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	return TargetSpecIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecIpRestrictionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecIpRestrictionsValue {
	object, diags := NewTargetSpecIpRestrictionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecIpRestrictionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecIpRestrictionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecIpRestrictionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecIpRestrictionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecIpRestrictionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecIpRestrictionsValueMust(TargetSpecIpRestrictionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecIpRestrictionsType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecIpRestrictionsValue{}
}

var _ basetypes.ObjectValuable = TargetSpecIpRestrictionsValue{}

type TargetSpecIpRestrictionsValue struct {
	CidrBlock   ovhtypes.TfStringValue `tfsdk:"cidr_block" json:"cidrBlock"`
	Description ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	state       attr.ValueState
}

func (v TargetSpecIpRestrictionsValue) ToUpdate() *TargetSpecIpRestrictionsValue {
	res := &TargetSpecIpRestrictionsValue{}

	if !v.CidrBlock.IsNull() {
		res.CidrBlock = v.CidrBlock
	}

	if !v.Description.IsNull() {
		res.Description = v.Description
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v TargetSpecIpRestrictionsValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.CidrBlock.IsNull() && !v.CidrBlock.IsUnknown() {
		toMarshal["cidrBlock"] = v.CidrBlock
	}
	if !v.Description.IsNull() && !v.Description.IsUnknown() {
		toMarshal["description"] = v.Description
	}

	return json.Marshal(toMarshal)
}

func (v *TargetSpecIpRestrictionsValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecIpRestrictionsValue TargetSpecIpRestrictionsValue

	var tmp JsonTargetSpecIpRestrictionsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CidrBlock = tmp.CidrBlock
	v.Description = tmp.Description

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecIpRestrictionsValue) MergeWith(other *TargetSpecIpRestrictionsValue) {

	if (v.CidrBlock.IsUnknown() || v.CidrBlock.IsNull()) && !other.CidrBlock.IsUnknown() {
		v.CidrBlock = other.CidrBlock
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecIpRestrictionsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidrBlock":   v.CidrBlock,
		"description": v.Description,
	}
}
func (v TargetSpecIpRestrictionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cidr_block"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CidrBlock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr_block"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecIpRestrictionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecIpRestrictionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecIpRestrictionsValue) String() string {
	return "TargetSpecIpRestrictionsValue"
}

func (v TargetSpecIpRestrictionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr_block":  ovhtypes.TfStringType{},
			"description": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cidr_block":  v.CidrBlock,
			"description": v.Description,
		})

	return objVal, diags
}

func (v TargetSpecIpRestrictionsValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecIpRestrictionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CidrBlock.Equal(other.CidrBlock) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	return true
}

func (v TargetSpecIpRestrictionsValue) Type(ctx context.Context) attr.Type {
	return TargetSpecIpRestrictionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecIpRestrictionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr_block":  ovhtypes.TfStringType{},
		"description": ovhtypes.TfStringType{},
	}
}
