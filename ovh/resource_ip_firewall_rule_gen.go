// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"

	ovhtypes "github.com/ovh/terraform-provider-ovh/v2/ovh/types"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

func IpFirewallRuleResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"action": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "Possible values for action",
				MarkdownDescription: "Possible values for action",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"deny",
						"permit",
					),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"creation_date": schema.StringAttribute{
				CustomType: ovhtypes.TfStringType{},
				Computed:   true,
			},
			"destination": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "Destination ip for your rule",
				MarkdownDescription: "Destination ip for your rule",
			},
			"destination_port": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Optional:            true,
				Computed:            true,
				Description:         "Destination port for your rule. Only with TCP/UDP protocol",
				MarkdownDescription: "Destination port for your rule. Only with TCP/UDP protocol",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
			},
			"destination_port_desc": schema.StringAttribute{
				CustomType:  ovhtypes.TfStringType{},
				Computed:    true,
				Description: "Destination port range for your rule. Only with TCP/UDP protocol",
			},
			"fragments": schema.BoolAttribute{
				CustomType:          ovhtypes.TfBoolType{},
				Optional:            true,
				Computed:            true,
				Description:         "Fragments option",
				MarkdownDescription: "Fragments option",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"ip": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "IP (v4 or v6) CIDR notation (e.g., 192.0.2.0/24)",
				MarkdownDescription: "IP (v4 or v6) CIDR notation (e.g., 192.0.2.0/24)",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"ip_on_firewall": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "IPv4 address (e.g., 192.0.2.0)",
				MarkdownDescription: "IPv4 address (e.g., 192.0.2.0)",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"protocol": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "Possible values for protocol",
				MarkdownDescription: "Possible values for protocol",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ah",
						"esp",
						"gre",
						"icmp",
						"ipv4",
						"tcp",
						"udp",
					),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"rule": schema.StringAttribute{
				CustomType: ovhtypes.TfStringType{},
				Computed:   true,
			},
			"sequence": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Required:            true,
				Description:         "Possible values for action",
				MarkdownDescription: "Possible values for action",
				Validators: []validator.Int64{
					int64validator.OneOf(
						0,
						1,
						2,
						3,
						4,
						5,
						6,
						7,
						8,
						9,
						10,
						11,
						12,
						13,
						14,
						15,
						16,
						17,
						18,
						19,
					),
				},
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
			},
			"source": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Optional:            true,
				Computed:            true,
				Description:         "IPv4 CIDR notation (e.g., 192.0.2.0/24)",
				MarkdownDescription: "IPv4 CIDR notation (e.g., 192.0.2.0/24)",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"source_port": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Optional:            true,
				Computed:            true,
				Description:         "Source port for your rule. Only with TCP/UDP protocol",
				MarkdownDescription: "Source port for your rule. Only with TCP/UDP protocol",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
			},
			"source_port_desc": schema.StringAttribute{
				CustomType:  ovhtypes.TfStringType{},
				Computed:    true,
				Description: "Source port for your rule. Only with TCP/UDP protocol",
			},
			"state": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "Current state of your rule",
				MarkdownDescription: "Current state of your rule",
			},
			"tcp_option": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Optional:            true,
				Computed:            true,
				Description:         "TCP option on your rule",
				MarkdownDescription: "TCP option on your rule",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"established",
						"syn",
					),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

type IpFirewallRuleModel struct {
	Action              ovhtypes.TfStringValue `tfsdk:"action" json:"action"`
	CreationDate        ovhtypes.TfStringValue `tfsdk:"creation_date" json:"creationDate"`
	Destination         ovhtypes.TfStringValue `tfsdk:"destination" json:"destination"`
	DestinationPort     ovhtypes.TfInt64Value  `tfsdk:"destination_port" json:"destinationPort"`
	DestinationPortDesc ovhtypes.TfStringValue `tfsdk:"destination_port_desc" json:"-"`
	Fragments           ovhtypes.TfBoolValue   `tfsdk:"fragments" json:"fragments"`
	Ip                  ovhtypes.TfStringValue `tfsdk:"ip" json:"ip"`
	IpOnFirewall        ovhtypes.TfStringValue `tfsdk:"ip_on_firewall" json:"ipOnFirewall"`
	Protocol            ovhtypes.TfStringValue `tfsdk:"protocol" json:"protocol"`
	Rule                ovhtypes.TfStringValue `tfsdk:"rule" json:"rule"`
	Sequence            ovhtypes.TfInt64Value  `tfsdk:"sequence" json:"sequence"`
	Source              ovhtypes.TfStringValue `tfsdk:"source" json:"source"`
	SourcePort          ovhtypes.TfInt64Value  `tfsdk:"source_port" json:"sourcePort"`
	SourcePortDesc      ovhtypes.TfStringValue `tfsdk:"source_port_desc" json:"-"`
	State               ovhtypes.TfStringValue `tfsdk:"state" json:"state"`
	TcpOption           ovhtypes.TfStringValue `tfsdk:"tcp_option" json:"tcpOption"`
}

// IpFirewallRuleResponseModel is used to read the API response body. We need
// a separate model to write and read because some properties don't have the
// same type everywhere.
type IpFirewallRuleResponseModel struct {
	Action              ovhtypes.TfStringValue `tfsdk:"action" json:"action"`
	CreationDate        ovhtypes.TfStringValue `tfsdk:"creation_date" json:"creationDate"`
	Destination         ovhtypes.TfStringValue `tfsdk:"destination" json:"destination"`
	DestinationPort     ovhtypes.TfInt64Value  `tfsdk:"destination_port" json:"-"`
	DestinationPortDesc ovhtypes.TfStringValue `tfsdk:"destination_port_desc" json:"destinationPort"`
	Fragments           ovhtypes.TfBoolValue   `tfsdk:"fragments" json:"fragments"`
	Ip                  ovhtypes.TfStringValue `tfsdk:"ip" json:"ip"`
	IpOnFirewall        ovhtypes.TfStringValue `tfsdk:"ip_on_firewall" json:"ipOnFirewall"`
	Protocol            ovhtypes.TfStringValue `tfsdk:"protocol" json:"protocol"`
	Rule                ovhtypes.TfStringValue `tfsdk:"rule" json:"rule"`
	Sequence            ovhtypes.TfInt64Value  `tfsdk:"sequence" json:"sequence"`
	Source              ovhtypes.TfStringValue `tfsdk:"source" json:"source"`
	SourcePort          ovhtypes.TfInt64Value  `tfsdk:"source_port" json:"-"`
	SourcePortDesc      ovhtypes.TfStringValue `tfsdk:"source_port_desc" json:"sourcePort"`
	State               ovhtypes.TfStringValue `tfsdk:"state" json:"state"`
	TcpOption           ovhtypes.TfStringValue `tfsdk:"tcp_option" json:"tcpOption"`
}

func (v *IpFirewallRuleModel) MergeWith(other *IpFirewallRuleModel) {
	if (v.Action.IsUnknown() || v.Action.IsNull()) && !other.Action.IsUnknown() {
		v.Action = other.Action
	}

	if (v.CreationDate.IsUnknown() || v.CreationDate.IsNull()) && !other.CreationDate.IsUnknown() {
		v.CreationDate = other.CreationDate
	}

	if (v.Destination.IsUnknown() || v.Destination.IsNull()) && !other.Destination.IsUnknown() {
		v.Destination = other.Destination
	}

	if (v.DestinationPort.IsUnknown() || v.DestinationPort.IsNull()) && !other.DestinationPort.IsUnknown() {
		v.DestinationPort = other.DestinationPort
	}

	if (v.Fragments.IsUnknown() || v.Fragments.IsNull()) && !other.Fragments.IsUnknown() {
		v.Fragments = other.Fragments
	}

	if (v.Ip.IsUnknown() || v.Ip.IsNull()) && !other.Ip.IsUnknown() {
		v.Ip = other.Ip
	}

	if (v.IpOnFirewall.IsUnknown() || v.IpOnFirewall.IsNull()) && !other.IpOnFirewall.IsUnknown() {
		v.IpOnFirewall = other.IpOnFirewall
	}

	if (v.Protocol.IsUnknown() || v.Protocol.IsNull()) && !other.Protocol.IsUnknown() {
		v.Protocol = other.Protocol
	}

	if (v.Rule.IsUnknown() || v.Rule.IsNull()) && !other.Rule.IsUnknown() {
		v.Rule = other.Rule
	}

	if (v.Sequence.IsUnknown() || v.Sequence.IsNull()) && !other.Sequence.IsUnknown() {
		v.Sequence = other.Sequence
	}

	if (v.Source.IsUnknown() || v.Source.IsNull()) && !other.Source.IsUnknown() {
		v.Source = other.Source
	}

	if (v.SourcePort.IsUnknown() || v.SourcePort.IsNull()) && !other.SourcePort.IsUnknown() {
		v.SourcePort = other.SourcePort
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.TcpOption.IsUnknown() || v.TcpOption.IsNull()) && !other.TcpOption.IsUnknown() {
		v.TcpOption = other.TcpOption
	}
}

func (v *IpFirewallRuleResponseModel) MergeWith(other *IpFirewallRuleModel) {
	if (v.Action.IsUnknown() || v.Action.IsNull()) && !other.Action.IsUnknown() {
		v.Action = other.Action
	}

	if (v.CreationDate.IsUnknown() || v.CreationDate.IsNull()) && !other.CreationDate.IsUnknown() {
		v.CreationDate = other.CreationDate
	}

	if (v.Destination.IsUnknown() || v.Destination.IsNull()) && !other.Destination.IsUnknown() {
		v.Destination = other.Destination
	}

	if (v.DestinationPort.IsUnknown() || v.DestinationPort.IsNull()) && !other.DestinationPort.IsUnknown() {
		v.DestinationPort = other.DestinationPort
	}

	if (v.Fragments.IsUnknown() || v.Fragments.IsNull()) && !other.Fragments.IsUnknown() {
		v.Fragments = other.Fragments
	}

	if (v.Ip.IsUnknown() || v.Ip.IsNull()) && !other.Ip.IsUnknown() {
		v.Ip = other.Ip
	}

	if (v.IpOnFirewall.IsUnknown() || v.IpOnFirewall.IsNull()) && !other.IpOnFirewall.IsUnknown() {
		v.IpOnFirewall = other.IpOnFirewall
	}

	if (v.Protocol.IsUnknown() || v.Protocol.IsNull()) && !other.Protocol.IsUnknown() {
		v.Protocol = other.Protocol
	}

	if (v.Rule.IsUnknown() || v.Rule.IsNull()) && !other.Rule.IsUnknown() {
		v.Rule = other.Rule
	}

	if (v.Sequence.IsUnknown() || v.Sequence.IsNull()) && !other.Sequence.IsUnknown() {
		v.Sequence = other.Sequence
	}

	if (v.Source.IsUnknown() || v.Source.IsNull()) && !other.Source.IsUnknown() {
		v.Source = other.Source
	}

	if (v.SourcePort.IsUnknown() || v.SourcePort.IsNull()) && !other.SourcePort.IsUnknown() {
		v.SourcePort = other.SourcePort
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.TcpOption.IsUnknown() || v.TcpOption.IsNull()) && !other.TcpOption.IsUnknown() {
		v.TcpOption = other.TcpOption
	}
}

// IpFirewallRuleWritableModel is an additional model used to create the rules.
// Field `tcpOption` has a different type compared to struct IpFirewallRuleModel because
// the field type is different in the API's request and response bodies.
type IpFirewallRuleWritableModel struct {
	Action          *ovhtypes.TfStringValue `tfsdk:"action" json:"action,omitempty"`
	DestinationPort *ovhtypes.TfInt64Value  `tfsdk:"destination_port" json:"destinationPort,omitempty"`
	Protocol        *ovhtypes.TfStringValue `tfsdk:"protocol" json:"protocol,omitempty"`
	Sequence        *ovhtypes.TfInt64Value  `tfsdk:"sequence" json:"sequence,omitempty"`
	Source          *ovhtypes.TfStringValue `tfsdk:"source" json:"source,omitempty"`
	SourcePort      *ovhtypes.TfInt64Value  `tfsdk:"source_port" json:"sourcePort,omitempty"`
	TcpOption       *TcpOptionWritableValue `tfsdk:"tcp_option" json:"tcpOption,omitempty"`
}

type TcpOptionWritableValue struct {
	Fragments *ovhtypes.TfBoolValue   `json:"fragments,omitempty"`
	Option    *ovhtypes.TfStringValue `json:"option,omitempty"`
}

func (v IpFirewallRuleModel) ToCreate() *IpFirewallRuleWritableModel {
	res := &IpFirewallRuleWritableModel{}

	if !v.Action.IsUnknown() {
		res.Action = &v.Action
	}

	if !v.DestinationPort.IsUnknown() {
		res.DestinationPort = &v.DestinationPort
	}

	if !v.Protocol.IsUnknown() {
		res.Protocol = &v.Protocol
	}

	if !v.Sequence.IsUnknown() {
		res.Sequence = &v.Sequence
	}

	if !v.Source.IsUnknown() {
		res.Source = &v.Source
	}

	if !v.SourcePort.IsUnknown() {
		res.SourcePort = &v.SourcePort
	}

	if !v.TcpOption.IsUnknown() || !v.Fragments.IsUnknown() {
		option := TcpOptionWritableValue{}

		if !v.TcpOption.IsUnknown() {
			option.Option = &v.TcpOption
		}
		if !v.Fragments.IsUnknown() {
			option.Fragments = &v.Fragments
		}

		res.TcpOption = &option
	}

	return res
}
