// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CloudProjectRancherResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"created_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Date of the managed Rancher service creation",
			MarkdownDescription: "Date of the managed Rancher service creation",
		},
		"current_state": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"bootstrap_password": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Sensitive:           true,
					Description:         "Bootstrap password of the managed Rancher service, returned only on creation",
					MarkdownDescription: "Bootstrap password of the managed Rancher service, returned only on creation",
				},
				"ip_restrictions": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"cidr_block": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
								MarkdownDescription: "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
							},
							"description": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Description of the allowed CIDR block",
								MarkdownDescription: "Description of the allowed CIDR block",
							},
						},
						CustomType: CurrentStateIpRestrictionsType{
							ObjectType: types.ObjectType{
								AttrTypes: CurrentStateIpRestrictionsValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[CurrentStateIpRestrictionsValue](ctx),
					Computed:            true,
					Description:         "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
					MarkdownDescription: "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
				},
				"name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Name of the managed Rancher service",
					MarkdownDescription: "Name of the managed Rancher service",
				},
				"networking": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"egress_cidr_blocks": schema.ListAttribute{
							CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
							Computed:            true,
							Description:         "Specifies the CIDR ranges for egress IP addresses used by Rancher. Ensure these ranges are allowed in any IP restrictions for services that Rancher will access.",
							MarkdownDescription: "Specifies the CIDR ranges for egress IP addresses used by Rancher. Ensure these ranges are allowed in any IP restrictions for services that Rancher will access.",
						},
					},
					CustomType: CurrentStateNetworkingType{
						ObjectType: types.ObjectType{
							AttrTypes: CurrentStateNetworkingValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Networking properties of a managed Rancher service",
					MarkdownDescription: "Networking properties of a managed Rancher service",
				},
				"plan": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Plan of the managed Rancher service",
					MarkdownDescription: "Plan of the managed Rancher service",
				},
				"region": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Region of the managed Rancher service",
					MarkdownDescription: "Region of the managed Rancher service",
				},
				"url": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "URL of the managed Rancher service",
					MarkdownDescription: "URL of the managed Rancher service",
				},
				"usage": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"datetime": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Date of the sample",
							MarkdownDescription: "Date of the sample",
						},
						"orchestrated_vcpus": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "Total number of vCPUs orchestrated by the managed Rancher service through the downstream clusters",
							MarkdownDescription: "Total number of vCPUs orchestrated by the managed Rancher service through the downstream clusters",
						},
					},
					CustomType: CurrentStateUsageType{
						ObjectType: types.ObjectType{
							AttrTypes: CurrentStateUsageValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Latest metrics regarding the usage of the managed Rancher service",
					MarkdownDescription: "Latest metrics regarding the usage of the managed Rancher service",
				},
				"version": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Version of the managed Rancher service",
					MarkdownDescription: "Version of the managed Rancher service",
				},
			},
			CustomType: RancherCurrentStateType{
				ObjectType: types.ObjectType{
					AttrTypes: RancherCurrentStateValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "Current configuration applied to the managed Rancher service",
			MarkdownDescription: "Current configuration applied to the managed Rancher service",
		},
		"current_tasks": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Identifier of the current task",
						MarkdownDescription: "Identifier of the current task",
					},
					"link": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Link to the task details",
						MarkdownDescription: "Link to the task details",
					},
					"status": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Current global status of the current task",
						MarkdownDescription: "Current global status of the current task",
					},
					"type": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Computed:            true,
						Description:         "Type of the current task",
						MarkdownDescription: "Type of the current task",
					},
				},
				CustomType: RancherCurrentTasksType{
					ObjectType: types.ObjectType{
						AttrTypes: RancherCurrentTasksValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[RancherCurrentTasksValue](ctx),
			Computed:            true,
			Description:         "Asynchronous operations ongoing on the managed Rancher service",
			MarkdownDescription: "Asynchronous operations ongoing on the managed Rancher service",
		},
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Unique identifier",
			MarkdownDescription: "Unique identifier",
		},
		"project_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Project ID",
			MarkdownDescription: "Project ID",
		},
		"resource_status": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Reflects the readiness of the managed Rancher service. A new target specification request will be accepted only in `READY` status",
			MarkdownDescription: "Reflects the readiness of the managed Rancher service. A new target specification request will be accepted only in `READY` status",
		},
		"target_spec": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"ip_restrictions": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"cidr_block": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Optional:            true,
								Description:         "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
								MarkdownDescription: "Allowed CIDR block (/subnet is optional, if unspecified then /32 will be used)",
							},
							"description": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Optional:            true,
								Description:         "Description of the allowed CIDR block",
								MarkdownDescription: "Description of the allowed CIDR block",
							},
						},
						CustomType: TargetSpecIpRestrictionsType{
							ObjectType: types.ObjectType{
								AttrTypes: TargetSpecIpRestrictionsValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[TargetSpecIpRestrictionsValue](ctx),
					Computed:            true,
					Optional:            true,
					Description:         "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
					MarkdownDescription: "List of allowed CIDR blocks for a managed Rancher service's IP restrictions. When empty, any IP is allowed",
				},
				"name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Required:            true,
					Description:         "Name of the managed Rancher service",
					MarkdownDescription: "Name of the managed Rancher service",
				},
				"plan": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Required:            true,
					Description:         "Plan of the managed Rancher service. Available plans for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/plan",
					MarkdownDescription: "Plan of the managed Rancher service. Available plans for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/plan",
					Validators: []validator.String{
						stringvalidator.OneOf(
							"OVHCLOUD_EDITION",
							"STANDARD",
						),
					},
				},
				"version": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Version of the managed Rancher service. Available versions for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/version. Default is the latest version.",
					MarkdownDescription: "Version of the managed Rancher service. Available versions for an existing managed Rancher can be retrieved using GET /rancher/rancherID/capabilities/version. Default is the latest version.",
				},
			},
			CustomType: RancherTargetSpecType{
				ObjectType: types.ObjectType{
					AttrTypes: RancherTargetSpecValue{}.AttributeTypes(ctx),
				},
			},
			Required:            true,
			Description:         "Target specification for the managed Rancher service",
			MarkdownDescription: "Target specification for the managed Rancher service",
		},
		"updated_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "Date of the last managed Rancher service update",
			MarkdownDescription: "Date of the last managed Rancher service update",
		},
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type CloudProjectRancherModel struct {
	CreatedAt      ovhtypes.TfStringValue                               `tfsdk:"created_at" json:"createdAt"`
	CurrentState   RancherCurrentStateValue                             `tfsdk:"current_state" json:"currentState"`
	CurrentTasks   ovhtypes.TfListNestedValue[RancherCurrentTasksValue] `tfsdk:"current_tasks" json:"currentTasks"`
	Id             ovhtypes.TfStringValue                               `tfsdk:"id" json:"id"`
	ProjectId      ovhtypes.TfStringValue                               `tfsdk:"project_id" json:"projectId"`
	ResourceStatus ovhtypes.TfStringValue                               `tfsdk:"resource_status" json:"resourceStatus"`
	TargetSpec     RancherTargetSpecValue                               `tfsdk:"target_spec" json:"targetSpec"`
	UpdatedAt      ovhtypes.TfStringValue                               `tfsdk:"updated_at" json:"updatedAt"`
}

func (v *CloudProjectRancherModel) MergeWith(other *CloudProjectRancherModel) {

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if v.CurrentState.IsUnknown() && !other.CurrentState.IsUnknown() {
		v.CurrentState = other.CurrentState
	} else if !other.CurrentState.IsUnknown() {
		v.CurrentState.MergeWith(&other.CurrentState)
	}

	if (v.CurrentTasks.IsUnknown() || v.CurrentTasks.IsNull()) && !other.CurrentTasks.IsUnknown() {
		v.CurrentTasks = other.CurrentTasks
	} else if !other.CurrentTasks.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.CurrentTasks.Elements()
		newElems := other.CurrentTasks.Elements()

		if len(elems) != len(newElems) {
			v.CurrentTasks = other.CurrentTasks
		} else {
			for idx, e := range elems {
				tmp := e.(RancherCurrentTasksValue)
				tmp2 := newElems[idx].(RancherCurrentTasksValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.CurrentTasks = ovhtypes.TfListNestedValue[RancherCurrentTasksValue]{
				ListValue: basetypes.NewListValueMust(RancherCurrentTasksValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.ProjectId.IsUnknown() || v.ProjectId.IsNull()) && !other.ProjectId.IsUnknown() {
		v.ProjectId = other.ProjectId
	}

	if (v.ResourceStatus.IsUnknown() || v.ResourceStatus.IsNull()) && !other.ResourceStatus.IsUnknown() {
		v.ResourceStatus = other.ResourceStatus
	}

	if v.TargetSpec.IsUnknown() && !other.TargetSpec.IsUnknown() {
		v.TargetSpec = other.TargetSpec
	} else if !other.TargetSpec.IsUnknown() {
		v.TargetSpec.MergeWith(&other.TargetSpec)
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

}

type CloudProjectRancherWritableModel struct {
	TargetSpec *RancherTargetSpecWritableValue `tfsdk:"target_spec" json:"targetSpec,omitempty"`
}

func (v CloudProjectRancherModel) ToCreate() *CloudProjectRancherWritableModel {
	res := &CloudProjectRancherWritableModel{}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = v.TargetSpec.ToCreate()
	}

	return res
}

func (v CloudProjectRancherModel) ToUpdate() *CloudProjectRancherWritableModel {
	res := &CloudProjectRancherWritableModel{}

	if !v.TargetSpec.IsUnknown() {
		res.TargetSpec = v.TargetSpec.ToUpdate()
	}

	return res
}

var _ basetypes.ObjectTypable = RancherCurrentStateType{}

type RancherCurrentStateType struct {
	basetypes.ObjectType
}

func (t RancherCurrentStateType) Equal(o attr.Type) bool {
	other, ok := o.(RancherCurrentStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RancherCurrentStateType) String() string {
	return "RancherCurrentStateType"
}

func (t RancherCurrentStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bootstrapPasswordAttribute, ok := attributes["bootstrap_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_password is missing from object`)

		return nil, diags
	}

	bootstrapPasswordVal, ok := bootstrapPasswordAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_password expected to be ovhtypes.TfStringValue, was: %T`, bootstrapPasswordAttribute))
	}

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return nil, diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	networkingAttribute, ok := attributes["networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networking is missing from object`)

		return nil, diags
	}

	networkingVal, ok := networkingAttribute.(CurrentStateNetworkingValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networking expected to be CurrentStateNetworkingValue, was: %T`, networkingAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return nil, diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(CurrentStateUsageValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be CurrentStateUsageValue, was: %T`, usageAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RancherCurrentStateValue{
		BootstrapPassword: bootstrapPasswordVal,
		IpRestrictions:    ipRestrictionsVal,
		Name:              nameVal,
		Networking:        networkingVal,
		Plan:              planVal,
		Region:            regionVal,
		Url:               urlVal,
		Usage:             usageVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRancherCurrentStateValueNull() RancherCurrentStateValue {
	return RancherCurrentStateValue{
		state: attr.ValueStateNull,
	}
}

func NewRancherCurrentStateValueUnknown() RancherCurrentStateValue {
	return RancherCurrentStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRancherCurrentStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RancherCurrentStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RancherCurrentStateValue Attribute Value",
				"While creating a RancherCurrentStateValue value, a missing attribute value was detected. "+
					"A RancherCurrentStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherCurrentStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RancherCurrentStateValue Attribute Type",
				"While creating a RancherCurrentStateValue value, an invalid attribute value was detected. "+
					"A RancherCurrentStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherCurrentStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RancherCurrentStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RancherCurrentStateValue Attribute Value",
				"While creating a RancherCurrentStateValue value, an extra attribute value was detected. "+
					"A RancherCurrentStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RancherCurrentStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRancherCurrentStateValueUnknown(), diags
	}

	bootstrapPasswordAttribute, ok := attributes["bootstrap_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_password is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	bootstrapPasswordVal, ok := bootstrapPasswordAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_password expected to be ovhtypes.TfStringValue, was: %T`, bootstrapPasswordAttribute))
	}

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	networkingAttribute, ok := attributes["networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networking is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	networkingVal, ok := networkingAttribute.(CurrentStateNetworkingValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networking expected to be CurrentStateNetworkingValue, was: %T`, networkingAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(CurrentStateUsageValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be CurrentStateUsageValue, was: %T`, usageAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewRancherCurrentStateValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewRancherCurrentStateValueUnknown(), diags
	}

	return RancherCurrentStateValue{
		BootstrapPassword: bootstrapPasswordVal,
		IpRestrictions:    ipRestrictionsVal,
		Name:              nameVal,
		Networking:        networkingVal,
		Plan:              planVal,
		Region:            regionVal,
		Url:               urlVal,
		Usage:             usageVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRancherCurrentStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RancherCurrentStateValue {
	object, diags := NewRancherCurrentStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRancherCurrentStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RancherCurrentStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRancherCurrentStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRancherCurrentStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRancherCurrentStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRancherCurrentStateValueMust(RancherCurrentStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RancherCurrentStateType) ValueType(ctx context.Context) attr.Value {
	return RancherCurrentStateValue{}
}

var _ basetypes.ObjectValuable = RancherCurrentStateValue{}

type RancherCurrentStateValue struct {
	BootstrapPassword ovhtypes.TfStringValue                                      `tfsdk:"bootstrap_password" json:"bootstrapPassword"`
	IpRestrictions    ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue] `tfsdk:"ip_restrictions" json:"ipRestrictions"`
	Name              ovhtypes.TfStringValue                                      `tfsdk:"name" json:"name"`
	Networking        CurrentStateNetworkingValue                                 `tfsdk:"networking" json:"networking"`
	Plan              ovhtypes.TfStringValue                                      `tfsdk:"plan" json:"plan"`
	Region            ovhtypes.TfStringValue                                      `tfsdk:"region" json:"region"`
	Url               ovhtypes.TfStringValue                                      `tfsdk:"url" json:"url"`
	Usage             CurrentStateUsageValue                                      `tfsdk:"usage" json:"usage"`
	Version           ovhtypes.TfStringValue                                      `tfsdk:"version" json:"version"`
	state             attr.ValueState
}

func (v *RancherCurrentStateValue) UnmarshalJSON(data []byte) error {
	type JsonRancherCurrentStateValue RancherCurrentStateValue

	var tmp JsonRancherCurrentStateValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.BootstrapPassword = tmp.BootstrapPassword
	v.IpRestrictions = tmp.IpRestrictions
	v.Name = tmp.Name
	v.Networking = tmp.Networking
	v.Plan = tmp.Plan
	v.Region = tmp.Region
	v.Url = tmp.Url
	v.Usage = tmp.Usage
	v.Version = tmp.Version

	v.state = attr.ValueStateKnown

	return nil
}

func (v *RancherCurrentStateValue) MergeWith(other *RancherCurrentStateValue) {

	if (v.BootstrapPassword.IsUnknown() || v.BootstrapPassword.IsNull()) && !other.BootstrapPassword.IsUnknown() {
		v.BootstrapPassword = other.BootstrapPassword
	}

	if (v.IpRestrictions.IsUnknown() || v.IpRestrictions.IsNull()) && !other.IpRestrictions.IsUnknown() {
		v.IpRestrictions = other.IpRestrictions
	} else if !other.IpRestrictions.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.IpRestrictions.Elements()
		newElems := other.IpRestrictions.Elements()

		if len(elems) != len(newElems) {
			v.IpRestrictions = other.IpRestrictions
		} else {
			for idx, e := range elems {
				tmp := e.(CurrentStateIpRestrictionsValue)
				tmp2 := newElems[idx].(CurrentStateIpRestrictionsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.IpRestrictions = ovhtypes.TfListNestedValue[CurrentStateIpRestrictionsValue]{
				ListValue: basetypes.NewListValueMust(CurrentStateIpRestrictionsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if v.Networking.IsUnknown() && !other.Networking.IsUnknown() {
		v.Networking = other.Networking
	} else if !other.Networking.IsUnknown() {
		v.Networking.MergeWith(&other.Networking)
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if v.Usage.IsUnknown() && !other.Usage.IsUnknown() {
		v.Usage = other.Usage
	} else if !other.Usage.IsUnknown() {
		v.Usage.MergeWith(&other.Usage)
	}

	if (v.Version.IsUnknown() || v.Version.IsNull()) && !other.Version.IsUnknown() {
		v.Version = other.Version
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v RancherCurrentStateValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"bootstrapPassword": v.BootstrapPassword,
		"ipRestrictions":    v.IpRestrictions,
		"name":              v.Name,
		"networking":        v.Networking,
		"plan":              v.Plan,
		"region":            v.Region,
		"url":               v.Url,
		"usage":             v.Usage,
		"version":           v.Version,
	}
}
func (v RancherCurrentStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["bootstrap_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_restrictions"] = basetypes.ListType{
		ElemType: CurrentStateIpRestrictionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networking"] = basetypes.ObjectType{
		AttrTypes: CurrentStateNetworkingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["plan"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.ObjectType{
		AttrTypes: CurrentStateUsageValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.BootstrapPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootstrap_password"] = val

		val, err = v.IpRestrictions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_restrictions"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networking"] = val

		val, err = v.Plan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RancherCurrentStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RancherCurrentStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RancherCurrentStateValue) String() string {
	return "RancherCurrentStateValue"
}

func (v RancherCurrentStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bootstrap_password": ovhtypes.TfStringType{},
			"ip_restrictions":    ovhtypes.NewTfListNestedType[CurrentStateIpRestrictionsValue](ctx),
			"name":               ovhtypes.TfStringType{},
			"networking": CurrentStateNetworkingType{
				basetypes.ObjectType{
					AttrTypes: CurrentStateNetworkingValue{}.AttributeTypes(ctx),
				},
			},
			"plan":   ovhtypes.TfStringType{},
			"region": ovhtypes.TfStringType{},
			"url":    ovhtypes.TfStringType{},
			"usage": CurrentStateUsageType{
				basetypes.ObjectType{
					AttrTypes: CurrentStateUsageValue{}.AttributeTypes(ctx),
				},
			},
			"version": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"bootstrap_password": v.BootstrapPassword,
			"ip_restrictions":    v.IpRestrictions,
			"name":               v.Name,
			"networking":         v.Networking,
			"plan":               v.Plan,
			"region":             v.Region,
			"url":                v.Url,
			"usage":              v.Usage,
			"version":            v.Version,
		})

	return objVal, diags
}

func (v RancherCurrentStateValue) Equal(o attr.Value) bool {
	other, ok := o.(RancherCurrentStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BootstrapPassword.Equal(other.BootstrapPassword) {
		return false
	}

	if !v.IpRestrictions.Equal(other.IpRestrictions) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networking.Equal(other.Networking) {
		return false
	}

	if !v.Plan.Equal(other.Plan) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v RancherCurrentStateValue) Type(ctx context.Context) attr.Type {
	return RancherCurrentStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RancherCurrentStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bootstrap_password": ovhtypes.TfStringType{},
		"ip_restrictions":    ovhtypes.NewTfListNestedType[CurrentStateIpRestrictionsValue](ctx),
		"name":               ovhtypes.TfStringType{},
		"networking":         CurrentStateNetworkingValue{}.Type(ctx),
		"plan":               ovhtypes.TfStringType{},
		"region":             ovhtypes.TfStringType{},
		"url":                ovhtypes.TfStringType{},
		"usage":              CurrentStateUsageValue{}.Type(ctx),
		"version":            ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateIpRestrictionsType{}

type CurrentStateIpRestrictionsType struct {
	basetypes.ObjectType
}

func (t CurrentStateIpRestrictionsType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateIpRestrictionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateIpRestrictionsType) String() string {
	return "CurrentStateIpRestrictionsType"
}

func (t CurrentStateIpRestrictionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return nil, diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateIpRestrictionsValueNull() CurrentStateIpRestrictionsValue {
	return CurrentStateIpRestrictionsValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateIpRestrictionsValueUnknown() CurrentStateIpRestrictionsValue {
	return CurrentStateIpRestrictionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateIpRestrictionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateIpRestrictionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateIpRestrictionsValue Attribute Value",
				"While creating a CurrentStateIpRestrictionsValue value, a missing attribute value was detected. "+
					"A CurrentStateIpRestrictionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateIpRestrictionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateIpRestrictionsValue Attribute Type",
				"While creating a CurrentStateIpRestrictionsValue value, an invalid attribute value was detected. "+
					"A CurrentStateIpRestrictionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateIpRestrictionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateIpRestrictionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateIpRestrictionsValue Attribute Value",
				"While creating a CurrentStateIpRestrictionsValue value, an extra attribute value was detected. "+
					"A CurrentStateIpRestrictionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateIpRestrictionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateIpRestrictionsValueUnknown(), diags
	}

	return CurrentStateIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateIpRestrictionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateIpRestrictionsValue {
	object, diags := NewCurrentStateIpRestrictionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateIpRestrictionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateIpRestrictionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateIpRestrictionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateIpRestrictionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateIpRestrictionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateIpRestrictionsValueMust(CurrentStateIpRestrictionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateIpRestrictionsType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateIpRestrictionsValue{}
}

var _ basetypes.ObjectValuable = CurrentStateIpRestrictionsValue{}

type CurrentStateIpRestrictionsValue struct {
	CidrBlock   ovhtypes.TfStringValue `tfsdk:"cidr_block" json:"cidrBlock"`
	Description ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	state       attr.ValueState
}

func (v *CurrentStateIpRestrictionsValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateIpRestrictionsValue CurrentStateIpRestrictionsValue

	var tmp JsonCurrentStateIpRestrictionsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CidrBlock = tmp.CidrBlock
	v.Description = tmp.Description

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateIpRestrictionsValue) MergeWith(other *CurrentStateIpRestrictionsValue) {

	if (v.CidrBlock.IsUnknown() || v.CidrBlock.IsNull()) && !other.CidrBlock.IsUnknown() {
		v.CidrBlock = other.CidrBlock
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateIpRestrictionsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidrBlock":   v.CidrBlock,
		"description": v.Description,
	}
}
func (v CurrentStateIpRestrictionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cidr_block"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CidrBlock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr_block"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateIpRestrictionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateIpRestrictionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateIpRestrictionsValue) String() string {
	return "CurrentStateIpRestrictionsValue"
}

func (v CurrentStateIpRestrictionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr_block":  ovhtypes.TfStringType{},
			"description": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cidr_block":  v.CidrBlock,
			"description": v.Description,
		})

	return objVal, diags
}

func (v CurrentStateIpRestrictionsValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateIpRestrictionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CidrBlock.Equal(other.CidrBlock) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	return true
}

func (v CurrentStateIpRestrictionsValue) Type(ctx context.Context) attr.Type {
	return CurrentStateIpRestrictionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateIpRestrictionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr_block":  ovhtypes.TfStringType{},
		"description": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = CurrentStateNetworkingType{}

type CurrentStateNetworkingType struct {
	basetypes.ObjectType
}

func (t CurrentStateNetworkingType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateNetworkingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateNetworkingType) String() string {
	return "CurrentStateNetworkingType"
}

func (t CurrentStateNetworkingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egressCidrBlocksAttribute, ok := attributes["egress_cidr_blocks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_cidr_blocks is missing from object`)

		return nil, diags
	}

	egressCidrBlocksVal, ok := egressCidrBlocksAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_cidr_blocks expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, egressCidrBlocksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateNetworkingValue{
		EgressCidrBlocks: egressCidrBlocksVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateNetworkingValueNull() CurrentStateNetworkingValue {
	return CurrentStateNetworkingValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateNetworkingValueUnknown() CurrentStateNetworkingValue {
	return CurrentStateNetworkingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateNetworkingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateNetworkingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateNetworkingValue Attribute Value",
				"While creating a CurrentStateNetworkingValue value, a missing attribute value was detected. "+
					"A CurrentStateNetworkingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateNetworkingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateNetworkingValue Attribute Type",
				"While creating a CurrentStateNetworkingValue value, an invalid attribute value was detected. "+
					"A CurrentStateNetworkingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateNetworkingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateNetworkingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateNetworkingValue Attribute Value",
				"While creating a CurrentStateNetworkingValue value, an extra attribute value was detected. "+
					"A CurrentStateNetworkingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateNetworkingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateNetworkingValueUnknown(), diags
	}

	egressCidrBlocksAttribute, ok := attributes["egress_cidr_blocks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_cidr_blocks is missing from object`)

		return NewCurrentStateNetworkingValueUnknown(), diags
	}

	egressCidrBlocksVal, ok := egressCidrBlocksAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_cidr_blocks expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, egressCidrBlocksAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateNetworkingValueUnknown(), diags
	}

	return CurrentStateNetworkingValue{
		EgressCidrBlocks: egressCidrBlocksVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateNetworkingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateNetworkingValue {
	object, diags := NewCurrentStateNetworkingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateNetworkingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateNetworkingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateNetworkingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateNetworkingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateNetworkingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateNetworkingValueMust(CurrentStateNetworkingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateNetworkingType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateNetworkingValue{}
}

var _ basetypes.ObjectValuable = CurrentStateNetworkingValue{}

type CurrentStateNetworkingValue struct {
	EgressCidrBlocks ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"egress_cidr_blocks" json:"egressCidrBlocks"`
	state            attr.ValueState
}

func (v *CurrentStateNetworkingValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateNetworkingValue CurrentStateNetworkingValue

	var tmp JsonCurrentStateNetworkingValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.EgressCidrBlocks = tmp.EgressCidrBlocks

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateNetworkingValue) MergeWith(other *CurrentStateNetworkingValue) {

	if (v.EgressCidrBlocks.IsUnknown() || v.EgressCidrBlocks.IsNull()) && !other.EgressCidrBlocks.IsUnknown() {
		v.EgressCidrBlocks = other.EgressCidrBlocks
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateNetworkingValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"egressCidrBlocks": v.EgressCidrBlocks,
	}
}
func (v CurrentStateNetworkingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["egress_cidr_blocks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.EgressCidrBlocks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress_cidr_blocks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateNetworkingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateNetworkingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateNetworkingValue) String() string {
	return "CurrentStateNetworkingValue"
}

func (v CurrentStateNetworkingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"egress_cidr_blocks": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		},
		map[string]attr.Value{
			"egress_cidr_blocks": v.EgressCidrBlocks,
		})

	return objVal, diags
}

func (v CurrentStateNetworkingValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateNetworkingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EgressCidrBlocks.Equal(other.EgressCidrBlocks) {
		return false
	}

	return true
}

func (v CurrentStateNetworkingValue) Type(ctx context.Context) attr.Type {
	return CurrentStateNetworkingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateNetworkingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress_cidr_blocks": ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
	}
}

var _ basetypes.ObjectTypable = CurrentStateUsageType{}

type CurrentStateUsageType struct {
	basetypes.ObjectType
}

func (t CurrentStateUsageType) Equal(o attr.Type) bool {
	other, ok := o.(CurrentStateUsageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CurrentStateUsageType) String() string {
	return "CurrentStateUsageType"
}

func (t CurrentStateUsageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	datetimeAttribute, ok := attributes["datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datetime is missing from object`)

		return nil, diags
	}

	datetimeVal, ok := datetimeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datetime expected to be ovhtypes.TfStringValue, was: %T`, datetimeAttribute))
	}

	orchestratedVcpusAttribute, ok := attributes["orchestrated_vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`orchestrated_vcpus is missing from object`)

		return nil, diags
	}

	orchestratedVcpusVal, ok := orchestratedVcpusAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`orchestrated_vcpus expected to be ovhtypes.TfInt64Value, was: %T`, orchestratedVcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CurrentStateUsageValue{
		Datetime:          datetimeVal,
		OrchestratedVcpus: orchestratedVcpusVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateUsageValueNull() CurrentStateUsageValue {
	return CurrentStateUsageValue{
		state: attr.ValueStateNull,
	}
}

func NewCurrentStateUsageValueUnknown() CurrentStateUsageValue {
	return CurrentStateUsageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCurrentStateUsageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CurrentStateUsageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CurrentStateUsageValue Attribute Value",
				"While creating a CurrentStateUsageValue value, a missing attribute value was detected. "+
					"A CurrentStateUsageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateUsageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CurrentStateUsageValue Attribute Type",
				"While creating a CurrentStateUsageValue value, an invalid attribute value was detected. "+
					"A CurrentStateUsageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CurrentStateUsageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CurrentStateUsageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CurrentStateUsageValue Attribute Value",
				"While creating a CurrentStateUsageValue value, an extra attribute value was detected. "+
					"A CurrentStateUsageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CurrentStateUsageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCurrentStateUsageValueUnknown(), diags
	}

	datetimeAttribute, ok := attributes["datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datetime is missing from object`)

		return NewCurrentStateUsageValueUnknown(), diags
	}

	datetimeVal, ok := datetimeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datetime expected to be ovhtypes.TfStringValue, was: %T`, datetimeAttribute))
	}

	orchestratedVcpusAttribute, ok := attributes["orchestrated_vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`orchestrated_vcpus is missing from object`)

		return NewCurrentStateUsageValueUnknown(), diags
	}

	orchestratedVcpusVal, ok := orchestratedVcpusAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`orchestrated_vcpus expected to be ovhtypes.TfInt64Value, was: %T`, orchestratedVcpusAttribute))
	}

	if diags.HasError() {
		return NewCurrentStateUsageValueUnknown(), diags
	}

	return CurrentStateUsageValue{
		Datetime:          datetimeVal,
		OrchestratedVcpus: orchestratedVcpusVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewCurrentStateUsageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CurrentStateUsageValue {
	object, diags := NewCurrentStateUsageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCurrentStateUsageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CurrentStateUsageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCurrentStateUsageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCurrentStateUsageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCurrentStateUsageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCurrentStateUsageValueMust(CurrentStateUsageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CurrentStateUsageType) ValueType(ctx context.Context) attr.Value {
	return CurrentStateUsageValue{}
}

var _ basetypes.ObjectValuable = CurrentStateUsageValue{}

type CurrentStateUsageValue struct {
	Datetime          ovhtypes.TfStringValue `tfsdk:"datetime" json:"datetime"`
	OrchestratedVcpus ovhtypes.TfInt64Value  `tfsdk:"orchestrated_vcpus" json:"orchestratedVcpus"`
	state             attr.ValueState
}

func (v *CurrentStateUsageValue) UnmarshalJSON(data []byte) error {
	type JsonCurrentStateUsageValue CurrentStateUsageValue

	var tmp JsonCurrentStateUsageValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Datetime = tmp.Datetime
	v.OrchestratedVcpus = tmp.OrchestratedVcpus

	v.state = attr.ValueStateKnown

	return nil
}

func (v *CurrentStateUsageValue) MergeWith(other *CurrentStateUsageValue) {

	if (v.Datetime.IsUnknown() || v.Datetime.IsNull()) && !other.Datetime.IsUnknown() {
		v.Datetime = other.Datetime
	}

	if (v.OrchestratedVcpus.IsUnknown() || v.OrchestratedVcpus.IsNull()) && !other.OrchestratedVcpus.IsUnknown() {
		v.OrchestratedVcpus = other.OrchestratedVcpus
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v CurrentStateUsageValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"datetime":          v.Datetime,
		"orchestratedVcpus": v.OrchestratedVcpus,
	}
}
func (v CurrentStateUsageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["datetime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["orchestrated_vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Datetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datetime"] = val

		val, err = v.OrchestratedVcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["orchestrated_vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CurrentStateUsageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CurrentStateUsageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CurrentStateUsageValue) String() string {
	return "CurrentStateUsageValue"
}

func (v CurrentStateUsageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"datetime":           ovhtypes.TfStringType{},
			"orchestrated_vcpus": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"datetime":           v.Datetime,
			"orchestrated_vcpus": v.OrchestratedVcpus,
		})

	return objVal, diags
}

func (v CurrentStateUsageValue) Equal(o attr.Value) bool {
	other, ok := o.(CurrentStateUsageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Datetime.Equal(other.Datetime) {
		return false
	}

	if !v.OrchestratedVcpus.Equal(other.OrchestratedVcpus) {
		return false
	}

	return true
}

func (v CurrentStateUsageValue) Type(ctx context.Context) attr.Type {
	return CurrentStateUsageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CurrentStateUsageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"datetime":           ovhtypes.TfStringType{},
		"orchestrated_vcpus": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = RancherCurrentTasksType{}

type RancherCurrentTasksType struct {
	basetypes.ObjectType
}

func (t RancherCurrentTasksType) Equal(o attr.Type) bool {
	other, ok := o.(RancherCurrentTasksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RancherCurrentTasksType) String() string {
	return "RancherCurrentTasksType"
}

func (t RancherCurrentTasksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return nil, diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RancherCurrentTasksValue{
		Id:                      idVal,
		Link:                    linkVal,
		Status:                  statusVal,
		RancherCurrentTasksType: typeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewRancherCurrentTasksValueNull() RancherCurrentTasksValue {
	return RancherCurrentTasksValue{
		state: attr.ValueStateNull,
	}
}

func NewRancherCurrentTasksValueUnknown() RancherCurrentTasksValue {
	return RancherCurrentTasksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRancherCurrentTasksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RancherCurrentTasksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RancherCurrentTasksValue Attribute Value",
				"While creating a RancherCurrentTasksValue value, a missing attribute value was detected. "+
					"A RancherCurrentTasksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherCurrentTasksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RancherCurrentTasksValue Attribute Type",
				"While creating a RancherCurrentTasksValue value, an invalid attribute value was detected. "+
					"A RancherCurrentTasksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherCurrentTasksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RancherCurrentTasksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RancherCurrentTasksValue Attribute Value",
				"While creating a RancherCurrentTasksValue value, an extra attribute value was detected. "+
					"A RancherCurrentTasksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RancherCurrentTasksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRancherCurrentTasksValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRancherCurrentTasksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	linkAttribute, ok := attributes["link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link is missing from object`)

		return NewRancherCurrentTasksValueUnknown(), diags
	}

	linkVal, ok := linkAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link expected to be ovhtypes.TfStringValue, was: %T`, linkAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewRancherCurrentTasksValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be ovhtypes.TfStringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewRancherCurrentTasksValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewRancherCurrentTasksValueUnknown(), diags
	}

	return RancherCurrentTasksValue{
		Id:                      idVal,
		Link:                    linkVal,
		Status:                  statusVal,
		RancherCurrentTasksType: typeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewRancherCurrentTasksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RancherCurrentTasksValue {
	object, diags := NewRancherCurrentTasksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRancherCurrentTasksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RancherCurrentTasksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRancherCurrentTasksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRancherCurrentTasksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRancherCurrentTasksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRancherCurrentTasksValueMust(RancherCurrentTasksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RancherCurrentTasksType) ValueType(ctx context.Context) attr.Value {
	return RancherCurrentTasksValue{}
}

var _ basetypes.ObjectValuable = RancherCurrentTasksValue{}

type RancherCurrentTasksValue struct {
	Id                      ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	Link                    ovhtypes.TfStringValue `tfsdk:"link" json:"link"`
	Status                  ovhtypes.TfStringValue `tfsdk:"status" json:"status"`
	RancherCurrentTasksType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state                   attr.ValueState
}

func (v *RancherCurrentTasksValue) UnmarshalJSON(data []byte) error {
	type JsonRancherCurrentTasksValue RancherCurrentTasksValue

	var tmp JsonRancherCurrentTasksValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id
	v.Link = tmp.Link
	v.Status = tmp.Status
	v.RancherCurrentTasksType = tmp.RancherCurrentTasksType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *RancherCurrentTasksValue) MergeWith(other *RancherCurrentTasksValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Link.IsUnknown() || v.Link.IsNull()) && !other.Link.IsUnknown() {
		v.Link = other.Link
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.RancherCurrentTasksType.IsUnknown() || v.RancherCurrentTasksType.IsNull()) && !other.RancherCurrentTasksType.IsUnknown() {
		v.RancherCurrentTasksType = other.RancherCurrentTasksType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v RancherCurrentTasksValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id":     v.Id,
		"link":   v.Link,
		"status": v.Status,
		"type":   v.RancherCurrentTasksType,
	}
}
func (v RancherCurrentTasksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Link.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.RancherCurrentTasksType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RancherCurrentTasksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RancherCurrentTasksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RancherCurrentTasksValue) String() string {
	return "RancherCurrentTasksValue"
}

func (v RancherCurrentTasksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":     ovhtypes.TfStringType{},
			"link":   ovhtypes.TfStringType{},
			"status": ovhtypes.TfStringType{},
			"type":   ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id":     v.Id,
			"link":   v.Link,
			"status": v.Status,
			"type":   v.RancherCurrentTasksType,
		})

	return objVal, diags
}

func (v RancherCurrentTasksValue) Equal(o attr.Value) bool {
	other, ok := o.(RancherCurrentTasksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Link.Equal(other.Link) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.RancherCurrentTasksType.Equal(other.RancherCurrentTasksType) {
		return false
	}

	return true
}

func (v RancherCurrentTasksValue) Type(ctx context.Context) attr.Type {
	return RancherCurrentTasksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RancherCurrentTasksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":     ovhtypes.TfStringType{},
		"link":   ovhtypes.TfStringType{},
		"status": ovhtypes.TfStringType{},
		"type":   ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = RancherTargetSpecType{}

type RancherTargetSpecType struct {
	basetypes.ObjectType
}

func (t RancherTargetSpecType) Equal(o attr.Type) bool {
	other, ok := o.(RancherTargetSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RancherTargetSpecType) String() string {
	return "RancherTargetSpecType"
}

func (t RancherTargetSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return nil, diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return nil, diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RancherTargetSpecValue{
		IpRestrictions: ipRestrictionsVal,
		Name:           nameVal,
		Plan:           planVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRancherTargetSpecValueNull() RancherTargetSpecValue {
	return RancherTargetSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewRancherTargetSpecValueUnknown() RancherTargetSpecValue {
	return RancherTargetSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRancherTargetSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RancherTargetSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RancherTargetSpecValue Attribute Value",
				"While creating a RancherTargetSpecValue value, a missing attribute value was detected. "+
					"A RancherTargetSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherTargetSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RancherTargetSpecValue Attribute Type",
				"While creating a RancherTargetSpecValue value, an invalid attribute value was detected. "+
					"A RancherTargetSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherTargetSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RancherTargetSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RancherTargetSpecValue Attribute Value",
				"While creating a RancherTargetSpecValue value, an extra attribute value was detected. "+
					"A RancherTargetSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RancherTargetSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRancherTargetSpecValueUnknown(), diags
	}

	ipRestrictionsAttribute, ok := attributes["ip_restrictions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_restrictions is missing from object`)

		return NewRancherTargetSpecValueUnknown(), diags
	}

	ipRestrictionsVal, ok := ipRestrictionsAttribute.(ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_restrictions expected to be ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue], was: %T`, ipRestrictionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRancherTargetSpecValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	planAttribute, ok := attributes["plan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan is missing from object`)

		return NewRancherTargetSpecValueUnknown(), diags
	}

	planVal, ok := planAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan expected to be ovhtypes.TfStringValue, was: %T`, planAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewRancherTargetSpecValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be ovhtypes.TfStringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewRancherTargetSpecValueUnknown(), diags
	}

	return RancherTargetSpecValue{
		IpRestrictions: ipRestrictionsVal,
		Name:           nameVal,
		Plan:           planVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRancherTargetSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RancherTargetSpecValue {
	object, diags := NewRancherTargetSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRancherTargetSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RancherTargetSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRancherTargetSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRancherTargetSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRancherTargetSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRancherTargetSpecValueMust(RancherTargetSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RancherTargetSpecType) ValueType(ctx context.Context) attr.Value {
	return RancherTargetSpecValue{}
}

var _ basetypes.ObjectValuable = RancherTargetSpecValue{}

type RancherTargetSpecValue struct {
	IpRestrictions ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue] `tfsdk:"ip_restrictions" json:"ipRestrictions"`
	Name           ovhtypes.TfStringValue                                    `tfsdk:"name" json:"name"`
	Plan           ovhtypes.TfStringValue                                    `tfsdk:"plan" json:"plan"`
	Version        ovhtypes.TfStringValue                                    `tfsdk:"version" json:"version"`
	state          attr.ValueState
}

type RancherTargetSpecWritableValue struct {
	*RancherTargetSpecValue `json:"-"`
	IpRestrictions          *ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue] `json:"ipRestrictions,omitempty"`
	Name                    *ovhtypes.TfStringValue                                    `json:"name,omitempty"`
	Plan                    *ovhtypes.TfStringValue                                    `json:"plan,omitempty"`
	Version                 *ovhtypes.TfStringValue                                    `json:"version,omitempty"`
}

func (v RancherTargetSpecValue) ToCreate() *RancherTargetSpecWritableValue {
	res := &RancherTargetSpecWritableValue{}

	if !v.Version.IsNull() && !v.Version.IsUnknown() {
		res.Version = &v.Version
	}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.Plan.IsNull() {
		res.Plan = &v.Plan
	}

	return res
}

func (v RancherTargetSpecValue) ToUpdate() *RancherTargetSpecWritableValue {
	res := &RancherTargetSpecWritableValue{}

	if !v.Version.IsNull() && !v.Version.IsUnknown() {
		res.Version = &v.Version
	}

	if !v.IpRestrictions.IsNull() && !v.IpRestrictions.IsUnknown() {
		res.IpRestrictions = &v.IpRestrictions
	}

	if !v.Name.IsNull() {
		res.Name = &v.Name
	}

	if !v.Plan.IsNull() {
		res.Plan = &v.Plan
	}

	return res
}

func (v *RancherTargetSpecValue) UnmarshalJSON(data []byte) error {
	type JsonRancherTargetSpecValue RancherTargetSpecValue

	var tmp JsonRancherTargetSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.IpRestrictions = tmp.IpRestrictions
	v.Name = tmp.Name
	v.Plan = tmp.Plan
	v.Version = tmp.Version

	v.state = attr.ValueStateKnown

	return nil
}

func (v *RancherTargetSpecValue) MergeWith(other *RancherTargetSpecValue) {

	if (v.IpRestrictions.IsUnknown() || v.IpRestrictions.IsNull()) && !other.IpRestrictions.IsUnknown() {
		v.IpRestrictions = other.IpRestrictions
	} else if !other.IpRestrictions.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.IpRestrictions.Elements()
		newElems := other.IpRestrictions.Elements()

		if len(elems) != len(newElems) {
			v.IpRestrictions = other.IpRestrictions
		} else {
			for idx, e := range elems {
				tmp := e.(TargetSpecIpRestrictionsValue)
				tmp2 := newElems[idx].(TargetSpecIpRestrictionsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.IpRestrictions = ovhtypes.TfListNestedValue[TargetSpecIpRestrictionsValue]{
				ListValue: basetypes.NewListValueMust(TargetSpecIpRestrictionsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	}

	if (v.Version.IsUnknown() || v.Version.IsNull()) && !other.Version.IsUnknown() {
		v.Version = other.Version
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v RancherTargetSpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"ipRestrictions": v.IpRestrictions,
		"name":           v.Name,
		"plan":           v.Plan,
		"version":        v.Version,
	}
}
func (v RancherTargetSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ip_restrictions"] = basetypes.ListType{
		ElemType: TargetSpecIpRestrictionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.IpRestrictions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_restrictions"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Plan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RancherTargetSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RancherTargetSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RancherTargetSpecValue) String() string {
	return "RancherTargetSpecValue"
}

func (v RancherTargetSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ip_restrictions": ovhtypes.NewTfListNestedType[TargetSpecIpRestrictionsValue](ctx),
			"name":            ovhtypes.TfStringType{},
			"plan":            ovhtypes.TfStringType{},
			"version":         ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"ip_restrictions": v.IpRestrictions,
			"name":            v.Name,
			"plan":            v.Plan,
			"version":         v.Version,
		})

	return objVal, diags
}

func (v RancherTargetSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(RancherTargetSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpRestrictions.Equal(other.IpRestrictions) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Plan.Equal(other.Plan) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v RancherTargetSpecValue) Type(ctx context.Context) attr.Type {
	return RancherTargetSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RancherTargetSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_restrictions": ovhtypes.NewTfListNestedType[TargetSpecIpRestrictionsValue](ctx),
		"name":            ovhtypes.TfStringType{},
		"plan":            ovhtypes.TfStringType{},
		"version":         ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = TargetSpecIpRestrictionsType{}

type TargetSpecIpRestrictionsType struct {
	basetypes.ObjectType
}

func (t TargetSpecIpRestrictionsType) Equal(o attr.Type) bool {
	other, ok := o.(TargetSpecIpRestrictionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetSpecIpRestrictionsType) String() string {
	return "TargetSpecIpRestrictionsType"
}

func (t TargetSpecIpRestrictionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return nil, diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetSpecIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecIpRestrictionsValueNull() TargetSpecIpRestrictionsValue {
	return TargetSpecIpRestrictionsValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetSpecIpRestrictionsValueUnknown() TargetSpecIpRestrictionsValue {
	return TargetSpecIpRestrictionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetSpecIpRestrictionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetSpecIpRestrictionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetSpecIpRestrictionsValue Attribute Value",
				"While creating a TargetSpecIpRestrictionsValue value, a missing attribute value was detected. "+
					"A TargetSpecIpRestrictionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecIpRestrictionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetSpecIpRestrictionsValue Attribute Type",
				"While creating a TargetSpecIpRestrictionsValue value, an invalid attribute value was detected. "+
					"A TargetSpecIpRestrictionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetSpecIpRestrictionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetSpecIpRestrictionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetSpecIpRestrictionsValue Attribute Value",
				"While creating a TargetSpecIpRestrictionsValue value, an extra attribute value was detected. "+
					"A TargetSpecIpRestrictionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetSpecIpRestrictionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	cidrBlockAttribute, ok := attributes["cidr_block"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr_block is missing from object`)

		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	cidrBlockVal, ok := cidrBlockAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr_block expected to be ovhtypes.TfStringValue, was: %T`, cidrBlockAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	if diags.HasError() {
		return NewTargetSpecIpRestrictionsValueUnknown(), diags
	}

	return TargetSpecIpRestrictionsValue{
		CidrBlock:   cidrBlockVal,
		Description: descriptionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetSpecIpRestrictionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetSpecIpRestrictionsValue {
	object, diags := NewTargetSpecIpRestrictionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetSpecIpRestrictionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetSpecIpRestrictionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetSpecIpRestrictionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetSpecIpRestrictionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetSpecIpRestrictionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetSpecIpRestrictionsValueMust(TargetSpecIpRestrictionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetSpecIpRestrictionsType) ValueType(ctx context.Context) attr.Value {
	return TargetSpecIpRestrictionsValue{}
}

var _ basetypes.ObjectValuable = TargetSpecIpRestrictionsValue{}

type TargetSpecIpRestrictionsValue struct {
	CidrBlock   ovhtypes.TfStringValue `tfsdk:"cidr_block" json:"cidrBlock"`
	Description ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	state       attr.ValueState
}

type TargetSpecIpRestrictionsWritableValue struct {
	*TargetSpecIpRestrictionsValue `json:"-"`
	CidrBlock                      *ovhtypes.TfStringValue `json:"cidrBlock,omitempty"`
	Description                    *ovhtypes.TfStringValue `json:"description,omitempty"`
}

func (v TargetSpecIpRestrictionsValue) ToUpdate() *TargetSpecIpRestrictionsWritableValue {
	res := &TargetSpecIpRestrictionsWritableValue{}

	if !v.CidrBlock.IsNull() {
		res.CidrBlock = &v.CidrBlock
	}

	if !v.Description.IsNull() {
		res.Description = &v.Description
	}

	return res
}

func (v *TargetSpecIpRestrictionsValue) UnmarshalJSON(data []byte) error {
	type JsonTargetSpecIpRestrictionsValue TargetSpecIpRestrictionsValue

	var tmp JsonTargetSpecIpRestrictionsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CidrBlock = tmp.CidrBlock
	v.Description = tmp.Description

	v.state = attr.ValueStateKnown

	return nil
}

func (v *TargetSpecIpRestrictionsValue) MergeWith(other *TargetSpecIpRestrictionsValue) {

	if (v.CidrBlock.IsUnknown() || v.CidrBlock.IsNull()) && !other.CidrBlock.IsUnknown() {
		v.CidrBlock = other.CidrBlock
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v TargetSpecIpRestrictionsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cidrBlock":   v.CidrBlock,
		"description": v.Description,
	}
}
func (v TargetSpecIpRestrictionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cidr_block"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CidrBlock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr_block"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetSpecIpRestrictionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetSpecIpRestrictionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetSpecIpRestrictionsValue) String() string {
	return "TargetSpecIpRestrictionsValue"
}

func (v TargetSpecIpRestrictionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cidr_block":  ovhtypes.TfStringType{},
			"description": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"cidr_block":  v.CidrBlock,
			"description": v.Description,
		})

	return objVal, diags
}

func (v TargetSpecIpRestrictionsValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetSpecIpRestrictionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CidrBlock.Equal(other.CidrBlock) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	return true
}

func (v TargetSpecIpRestrictionsValue) Type(ctx context.Context) attr.Type {
	return TargetSpecIpRestrictionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetSpecIpRestrictionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr_block":  ovhtypes.TfStringType{},
		"description": ovhtypes.TfStringType{},
	}
}
