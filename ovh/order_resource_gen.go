// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	legacyschema "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
)

func OrderResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"order": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"date": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Computed:   true,
					},
					"details": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									CustomType: ovhtypes.TfStringType{},
									Computed:   true,
								},
								"detail_type": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Computed:            true,
									Description:         "Product type of item in order",
									MarkdownDescription: "Product type of item in order",
								},
								"domain": schema.StringAttribute{
									CustomType: ovhtypes.TfStringType{},
									Computed:   true,
								},
								"order_detail_id": schema.Int64Attribute{
									CustomType: ovhtypes.TfInt64Type{},
									Computed:   true,
								},
								"quantity": schema.StringAttribute{
									CustomType: ovhtypes.TfStringType{},
									Computed:   true,
								},
							},
							CustomType: OrderDetailsType{
								ObjectType: types.ObjectType{
									AttrTypes: OrderDetailsValue{}.AttributeTypes(ctx),
								},
							},
						},
						CustomType: ovhtypes.NewTfListNestedType[OrderDetailsValue](ctx),
						Computed:   true,
					},
					"expiration_date": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Computed:   true,
					},
					"order_id": schema.Int64Attribute{
						CustomType: ovhtypes.TfInt64Type{},
						Computed:   true,
					},
				},
				CustomType: OrderType{
					ObjectType: types.ObjectType{
						AttrTypes: OrderValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Details about an Order",
				MarkdownDescription: "Details about an Order",
			},
			"ovh_subsidiary": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "OVH subsidiaries",
				MarkdownDescription: "OVH subsidiaries",
			},
			"plan": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"configuration": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"label": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Label for your configuration item",
										MarkdownDescription: "Label for your configuration item",
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
									"value": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Value or resource URL on API.OVH.COM of your configuration item",
										MarkdownDescription: "Value or resource URL on API.OVH.COM of your configuration item",
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
									},
								},
								CustomType: PlanConfigurationType{
									ObjectType: types.ObjectType{
										AttrTypes: PlanConfigurationValue{}.AttributeTypes(ctx),
									},
								},
							},
							CustomType: ovhtypes.NewTfListNestedType[PlanConfigurationValue](ctx),
							Optional:   true,
							Computed:   true,
						},
						"duration": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Required:            true,
							Description:         "Duration selected for the purchase of the product",
							MarkdownDescription: "Duration selected for the purchase of the product",
						},
						"item_id": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Optional:            true,
							Description:         "Cart item to be linked",
							MarkdownDescription: "Cart item to be linked",
						},
						"plan_code": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Required:            true,
							Description:         "Identifier of the option offer",
							MarkdownDescription: "Identifier of the option offer",
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"pricing_mode": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Required:            true,
							Description:         "Pricing mode selected for the purchase of the product",
							MarkdownDescription: "Pricing mode selected for the purchase of the product",
						},
						"quantity": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Optional:            true,
							Description:         "Quantity of product desired",
							MarkdownDescription: "Quantity of product desired",
						},
					},
					CustomType: PlanType{
						ObjectType: types.ObjectType{
							AttrTypes: PlanValue{}.AttributeTypes(ctx),
						},
					},
				},
				CustomType: ovhtypes.NewTfListNestedType[PlanValue](ctx),
				Optional:   true,
				Computed:   true,
			},
			"plan_option": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"configuration": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"label": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Label for your configuration item",
										MarkdownDescription: "Label for your configuration item",
									},
									"value": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Value or resource URL on API.OVH.COM of your configuration item",
										MarkdownDescription: "Value or resource URL on API.OVH.COM of your configuration item",
									},
								},
								CustomType: PlanOptionConfigurationType{
									ObjectType: types.ObjectType{
										AttrTypes: PlanOptionConfigurationValue{}.AttributeTypes(ctx),
									},
								},
							},
							CustomType: ovhtypes.NewTfListNestedType[PlanOptionConfigurationValue](ctx),
							Optional:   true,
						},
						"duration": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Required:            true,
							Description:         "Duration selected for the purchase of the product",
							MarkdownDescription: "Duration selected for the purchase of the product",
						},
						"plan_code": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Required:            true,
							Description:         "Identifier of the option offer",
							MarkdownDescription: "Identifier of the option offer",
						},
						"pricing_mode": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Required:            true,
							Description:         "Pricing mode selected for the purchase of the product",
							MarkdownDescription: "Pricing mode selected for the purchase of the product",
						},
						"quantity": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Required:            true,
							Description:         "Quantity of product desired",
							MarkdownDescription: "Quantity of product desired",
						},
					},
					CustomType: PlanOptionType{
						ObjectType: types.ObjectType{
							AttrTypes: PlanOptionValue{}.AttributeTypes(ctx),
						},
					},
				},
				CustomType: ovhtypes.NewTfListNestedType[PlanOptionValue](ctx),
				Optional:   true,
				Computed:   true,
			},
		},
	}
}

type OrderModel struct {
	Order         OrderValue                                  `tfsdk:"order" json:"order"`
	OvhSubsidiary ovhtypes.TfStringValue                      `tfsdk:"ovh_subsidiary" json:"ovhSubsidiary"`
	Plan          ovhtypes.TfListNestedValue[PlanValue]       `tfsdk:"plan" json:"plan"`
	PlanOption    ovhtypes.TfListNestedValue[PlanOptionValue] `tfsdk:"plan_option" json:"planOption"`
}

func (o *OrderModel) FromResource(d *legacyschema.ResourceData) *OrderModel {
	o.OvhSubsidiary = ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(strings.ToUpper(d.Get("ovh_subsidiary").(string)))}

	var plan []attr.Value
	nbPlans := d.Get("plan.#").(int)
	for i := 0; i < nbPlans; i++ {
		p := (PlanValue{}).FromResourceWithPath(d, fmt.Sprintf("plan.%d", i))
		plan = append(plan, p)
	}
	o.Plan = ovhtypes.TfListNestedValue[PlanValue]{
		ListValue: basetypes.NewListValueMust(PlanValue{}.Type(context.Background()), plan),
	}

	var planOptions []attr.Value
	nbPlanOptions := d.Get("plan_option.#").(int)
	for i := 0; i < nbPlanOptions; i++ {
		planOpt := (PlanOptionValue{}).FromResourceWithPath(d, fmt.Sprintf("plan_option.%d", i))
		planOptions = append(planOptions, planOpt)
	}
	o.PlanOption = ovhtypes.TfListNestedValue[PlanOptionValue]{
		ListValue: basetypes.NewListValueMust(PlanOptionValue{}.Type(context.Background()), planOptions),
	}

	return o
}

func (v *OrderModel) MergeWith(other *OrderModel) {
	if v.Order.IsUnknown() && !other.Order.IsUnknown() {
		v.Order = other.Order
	} else if !other.Order.IsUnknown() {
		v.Order.MergeWith(&other.Order)
	}

	if (v.OvhSubsidiary.IsUnknown() || v.OvhSubsidiary.IsNull()) && !other.OvhSubsidiary.IsUnknown() {
		v.OvhSubsidiary = other.OvhSubsidiary
	}

	if (v.Plan.IsUnknown() || v.Plan.IsNull()) && !other.Plan.IsUnknown() {
		v.Plan = other.Plan
	} else if !other.Plan.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Plan.Elements()
		newElems := other.Plan.Elements()

		if len(elems) != len(newElems) {
			v.Plan = other.Plan
		} else {
			for idx, e := range elems {
				tmp := e.(PlanValue)
				tmp2 := newElems[idx].(PlanValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Plan = ovhtypes.TfListNestedValue[PlanValue]{
				ListValue: basetypes.NewListValueMust(PlanValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.PlanOption.IsUnknown() || v.PlanOption.IsNull()) && !other.PlanOption.IsUnknown() {
		v.PlanOption = other.PlanOption
	} else if !other.PlanOption.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.PlanOption.Elements()
		newElems := other.PlanOption.Elements()

		if len(elems) != len(newElems) {
			v.PlanOption = other.PlanOption
		} else {
			for idx, e := range elems {
				tmp := e.(PlanOptionValue)
				tmp2 := newElems[idx].(PlanOptionValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.PlanOption = ovhtypes.TfListNestedValue[PlanOptionValue]{
				ListValue: basetypes.NewListValueMust(PlanOptionValue{}.Type(context.Background()), newSlice),
			}
		}
	}
}

type OrderWritableModel struct {
	OvhSubsidiary *ovhtypes.TfStringValue                              `tfsdk:"ovh_subsidiary" json:"ovhSubsidiary,omitempty"`
	Plan          *ovhtypes.TfListNestedValue[PlanWritableValue]       `tfsdk:"plan" json:"plan,omitempty"`
	PlanOption    *ovhtypes.TfListNestedValue[PlanOptionWritableValue] `tfsdk:"plan_option" json:"planOption,omitempty"`
}

func (v OrderModel) ToCreate() *OrderWritableModel {
	res := &OrderWritableModel{}

	if !v.OvhSubsidiary.IsUnknown() {
		res.OvhSubsidiary = &v.OvhSubsidiary
	}

	if !v.Plan.IsUnknown() {
		var createPlan []PlanWritableValue
		for _, elem := range v.Plan.Elements() {
			createPlan = append(createPlan, *elem.(PlanValue).ToCreate())
		}

		newPlan, _ := basetypes.NewListValueFrom(context.Background(), PlanWritableValue{
			PlanValue: &PlanValue{},
		}.Type(context.Background()), createPlan)
		res.Plan = &ovhtypes.TfListNestedValue[PlanWritableValue]{
			ListValue: newPlan,
		}
	}

	if !v.PlanOption.IsUnknown() {
		var createPlanOption []PlanOptionWritableValue
		for _, elem := range v.PlanOption.Elements() {
			createPlanOption = append(createPlanOption, *elem.(PlanOptionValue).ToCreate())
		}

		newPlanOption, _ := basetypes.NewListValueFrom(context.Background(), PlanOptionWritableValue{
			PlanOptionValue: &PlanOptionValue{},
		}.Type(context.Background()), createPlanOption)
		res.PlanOption = &ovhtypes.TfListNestedValue[PlanOptionWritableValue]{
			ListValue: newPlanOption,
		}
	}

	return res
}

var _ basetypes.ObjectTypable = OrderType{}

type OrderType struct {
	basetypes.ObjectType
}

func (t OrderType) Equal(o attr.Type) bool {
	other, ok := o.(OrderType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrderType) String() string {
	return "OrderType"
}

func (t OrderType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dateAttribute, ok := attributes["date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`date is missing from object`)

		return nil, diags
	}

	dateVal, ok := dateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`date expected to be ovhtypes.TfStringValue, was: %T`, dateAttribute))
	}

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return nil, diags
	}

	detailsVal, ok := detailsAttribute.(ovhtypes.TfListNestedValue[OrderDetailsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be ovhtypes.TfListNestedValue[OrderDetailsValue], was: %T`, detailsAttribute))
	}

	expirationDateAttribute, ok := attributes["expiration_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration_date is missing from object`)

		return nil, diags
	}

	expirationDateVal, ok := expirationDateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration_date expected to be ovhtypes.TfStringValue, was: %T`, expirationDateAttribute))
	}

	orderIdAttribute, ok := attributes["order_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_id is missing from object`)

		return nil, diags
	}

	orderIdVal, ok := orderIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_id expected to be ovhtypes.TfInt64Value, was: %T`, orderIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrderValue{
		Date:           dateVal,
		Details:        detailsVal,
		ExpirationDate: expirationDateVal,
		OrderId:        orderIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrderValueNull() OrderValue {
	return OrderValue{
		state: attr.ValueStateNull,
	}
}

func NewOrderValueUnknown() OrderValue {
	return OrderValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrderValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrderValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrderValue Attribute Value",
				"While creating a OrderValue value, a missing attribute value was detected. "+
					"A OrderValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrderValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrderValue Attribute Type",
				"While creating a OrderValue value, an invalid attribute value was detected. "+
					"A OrderValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrderValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrderValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrderValue Attribute Value",
				"While creating a OrderValue value, an extra attribute value was detected. "+
					"A OrderValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrderValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrderValueUnknown(), diags
	}

	dateAttribute, ok := attributes["date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`date is missing from object`)

		return NewOrderValueUnknown(), diags
	}

	dateVal, ok := dateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`date expected to be ovhtypes.TfStringValue, was: %T`, dateAttribute))
	}

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return NewOrderValueUnknown(), diags
	}

	detailsVal, ok := detailsAttribute.(ovhtypes.TfListNestedValue[OrderDetailsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be ovhtypes.TfListNestedValue[OrderDetailsValue], was: %T`, detailsAttribute))
	}

	expirationDateAttribute, ok := attributes["expiration_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration_date is missing from object`)

		return NewOrderValueUnknown(), diags
	}

	expirationDateVal, ok := expirationDateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration_date expected to be ovhtypes.TfStringValue, was: %T`, expirationDateAttribute))
	}

	orderIdAttribute, ok := attributes["order_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_id is missing from object`)

		return NewOrderValueUnknown(), diags
	}

	orderIdVal, ok := orderIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_id expected to be ovhtypes.TfInt64Value, was: %T`, orderIdAttribute))
	}

	if diags.HasError() {
		return NewOrderValueUnknown(), diags
	}

	return OrderValue{
		Date:           dateVal,
		Details:        detailsVal,
		ExpirationDate: expirationDateVal,
		OrderId:        orderIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrderValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrderValue {
	object, diags := NewOrderValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrderValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrderType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrderValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrderValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrderValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrderValueMust(OrderValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrderType) ValueType(ctx context.Context) attr.Value {
	return OrderValue{}
}

var _ basetypes.ObjectValuable = OrderValue{}

type OrderValue struct {
	Date           ovhtypes.TfStringValue                        `tfsdk:"date" json:"date"`
	Details        ovhtypes.TfListNestedValue[OrderDetailsValue] `tfsdk:"details" json:"details"`
	ExpirationDate ovhtypes.TfStringValue                        `tfsdk:"expiration_date" json:"expirationDate"`
	OrderId        ovhtypes.TfInt64Value                         `tfsdk:"order_id" json:"orderId"`
	state          attr.ValueState
}

type OrderWritableValue struct {
	*OrderValue    `json:"-"`
	Date           *ovhtypes.TfStringValue                        `json:"date,omitempty"`
	Details        *ovhtypes.TfListNestedValue[OrderDetailsValue] `json:"details,omitempty"`
	ExpirationDate *ovhtypes.TfStringValue                        `json:"expirationDate,omitempty"`
	OrderId        *ovhtypes.TfInt64Value                         `json:"orderId,omitempty"`
}

func (v OrderValue) ToCreate() *OrderWritableValue {
	res := &OrderWritableValue{}

	if !v.ExpirationDate.IsNull() {
		res.ExpirationDate = &v.ExpirationDate
	}

	if !v.OrderId.IsNull() {
		res.OrderId = &v.OrderId
	}

	if !v.Date.IsNull() {
		res.Date = &v.Date
	}

	if !v.Details.IsNull() {
		res.Details = &v.Details
	}

	return res
}

func (v *OrderValue) UnmarshalJSON(data []byte) error {
	type JsonOrderValue OrderValue

	var tmp JsonOrderValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Date = tmp.Date
	v.Details = tmp.Details
	v.ExpirationDate = tmp.ExpirationDate
	v.OrderId = tmp.OrderId

	v.state = attr.ValueStateKnown

	return nil
}

func (v *OrderValue) MergeWith(other *OrderValue) {

	if (v.Date.IsUnknown() || v.Date.IsNull()) && !other.Date.IsUnknown() {
		v.Date = other.Date
	}

	if (v.Details.IsUnknown() || v.Details.IsNull()) && !other.Details.IsUnknown() {
		v.Details = other.Details
	} else if !other.Details.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Details.Elements()
		newElems := other.Details.Elements()

		if len(elems) != len(newElems) {
			v.Details = other.Details
		} else {
			for idx, e := range elems {
				tmp := e.(OrderDetailsValue)
				tmp2 := newElems[idx].(OrderDetailsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Details = ovhtypes.TfListNestedValue[OrderDetailsValue]{
				ListValue: basetypes.NewListValueMust(OrderDetailsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.ExpirationDate.IsUnknown() || v.ExpirationDate.IsNull()) && !other.ExpirationDate.IsUnknown() {
		v.ExpirationDate = other.ExpirationDate
	}

	if (v.OrderId.IsUnknown() || v.OrderId.IsNull()) && !other.OrderId.IsUnknown() {
		v.OrderId = other.OrderId
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v OrderValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"date":           v.Date,
		"details":        v.Details,
		"expirationDate": v.ExpirationDate,
		"orderId":        v.OrderId,
	}
}
func (v OrderValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["details"] = basetypes.ListType{
		ElemType: OrderDetailsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["expiration_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["order_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Date.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["date"] = val

		val, err = v.Details.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["details"] = val

		val, err = v.ExpirationDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expiration_date"] = val

		val, err = v.OrderId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrderValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrderValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrderValue) String() string {
	return "OrderValue"
}

func (v OrderValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"date":            ovhtypes.TfStringType{},
			"details":         ovhtypes.NewTfListNestedType[OrderDetailsValue](ctx),
			"expiration_date": ovhtypes.TfStringType{},
			"order_id":        ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"date":            v.Date,
			"details":         v.Details,
			"expiration_date": v.ExpirationDate,
			"order_id":        v.OrderId,
		})

	return objVal, diags
}

func (v OrderValue) Equal(o attr.Value) bool {
	other, ok := o.(OrderValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Date.Equal(other.Date) {
		return false
	}

	if !v.Details.Equal(other.Details) {
		return false
	}

	if !v.ExpirationDate.Equal(other.ExpirationDate) {
		return false
	}

	if !v.OrderId.Equal(other.OrderId) {
		return false
	}

	return true
}

func (v OrderValue) Type(ctx context.Context) attr.Type {
	return OrderType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrderValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"date":            ovhtypes.TfStringType{},
		"details":         ovhtypes.NewTfListNestedType[OrderDetailsValue](ctx),
		"expiration_date": ovhtypes.TfStringType{},
		"order_id":        ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = OrderDetailsType{}

type OrderDetailsType struct {
	basetypes.ObjectType
}

func (t OrderDetailsType) Equal(o attr.Type) bool {
	other, ok := o.(OrderDetailsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrderDetailsType) String() string {
	return "OrderDetailsType"
}

func (t OrderDetailsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	detailTypeAttribute, ok := attributes["detail_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detail_type is missing from object`)

		return nil, diags
	}

	detailTypeVal, ok := detailTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detail_type expected to be ovhtypes.TfStringValue, was: %T`, detailTypeAttribute))
	}

	domainAttribute, ok := attributes["domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain is missing from object`)

		return nil, diags
	}

	domainVal, ok := domainAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain expected to be ovhtypes.TfStringValue, was: %T`, domainAttribute))
	}

	orderDetailIdAttribute, ok := attributes["order_detail_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_detail_id is missing from object`)

		return nil, diags
	}

	orderDetailIdVal, ok := orderDetailIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_detail_id expected to be ovhtypes.TfInt64Value, was: %T`, orderDetailIdAttribute))
	}

	quantityAttribute, ok := attributes["quantity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quantity is missing from object`)

		return nil, diags
	}

	quantityVal, ok := quantityAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quantity expected to be ovhtypes.TfStringValue, was: %T`, quantityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrderDetailsValue{
		Description:   descriptionVal,
		DetailType:    detailTypeVal,
		Domain:        domainVal,
		OrderDetailId: orderDetailIdVal,
		Quantity:      quantityVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewOrderDetailsValueNull() OrderDetailsValue {
	return OrderDetailsValue{
		state: attr.ValueStateNull,
	}
}

func NewOrderDetailsValueUnknown() OrderDetailsValue {
	return OrderDetailsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrderDetailsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrderDetailsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrderDetailsValue Attribute Value",
				"While creating a OrderDetailsValue value, a missing attribute value was detected. "+
					"A OrderDetailsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrderDetailsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrderDetailsValue Attribute Type",
				"While creating a OrderDetailsValue value, an invalid attribute value was detected. "+
					"A OrderDetailsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrderDetailsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrderDetailsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrderDetailsValue Attribute Value",
				"While creating a OrderDetailsValue value, an extra attribute value was detected. "+
					"A OrderDetailsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrderDetailsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrderDetailsValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewOrderDetailsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	detailTypeAttribute, ok := attributes["detail_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detail_type is missing from object`)

		return NewOrderDetailsValueUnknown(), diags
	}

	detailTypeVal, ok := detailTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detail_type expected to be ovhtypes.TfStringValue, was: %T`, detailTypeAttribute))
	}

	domainAttribute, ok := attributes["domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain is missing from object`)

		return NewOrderDetailsValueUnknown(), diags
	}

	domainVal, ok := domainAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain expected to be ovhtypes.TfStringValue, was: %T`, domainAttribute))
	}

	orderDetailIdAttribute, ok := attributes["order_detail_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_detail_id is missing from object`)

		return NewOrderDetailsValueUnknown(), diags
	}

	orderDetailIdVal, ok := orderDetailIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_detail_id expected to be ovhtypes.TfInt64Value, was: %T`, orderDetailIdAttribute))
	}

	quantityAttribute, ok := attributes["quantity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quantity is missing from object`)

		return NewOrderDetailsValueUnknown(), diags
	}

	quantityVal, ok := quantityAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quantity expected to be ovhtypes.TfStringValue, was: %T`, quantityAttribute))
	}

	if diags.HasError() {
		return NewOrderDetailsValueUnknown(), diags
	}

	return OrderDetailsValue{
		Description:   descriptionVal,
		DetailType:    detailTypeVal,
		Domain:        domainVal,
		OrderDetailId: orderDetailIdVal,
		Quantity:      quantityVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewOrderDetailsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrderDetailsValue {
	object, diags := NewOrderDetailsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrderDetailsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrderDetailsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrderDetailsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrderDetailsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrderDetailsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrderDetailsValueMust(OrderDetailsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrderDetailsType) ValueType(ctx context.Context) attr.Value {
	return OrderDetailsValue{}
}

var _ basetypes.ObjectValuable = OrderDetailsValue{}

type OrderDetailsValue struct {
	Description   ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	DetailType    ovhtypes.TfStringValue `tfsdk:"detail_type" json:"detailType"`
	Domain        ovhtypes.TfStringValue `tfsdk:"domain" json:"domain"`
	OrderDetailId ovhtypes.TfInt64Value  `tfsdk:"order_detail_id" json:"orderDetailId"`
	Quantity      ovhtypes.TfStringValue `tfsdk:"quantity" json:"quantity"`
	state         attr.ValueState
}

type OrderDetailsWritableValue struct {
	*OrderDetailsValue `json:"-"`
	Description        *ovhtypes.TfStringValue `json:"description,omitempty"`
	DetailType         *ovhtypes.TfStringValue `json:"detailType,omitempty"`
	Domain             *ovhtypes.TfStringValue `json:"domain,omitempty"`
	OrderDetailId      *ovhtypes.TfInt64Value  `json:"orderDetailId,omitempty"`
	Quantity           *ovhtypes.TfStringValue `json:"quantity,omitempty"`
}

func (v OrderDetailsValue) ToCreate() *OrderDetailsWritableValue {
	res := &OrderDetailsWritableValue{}

	if !v.OrderDetailId.IsNull() {
		res.OrderDetailId = &v.OrderDetailId
	}

	if !v.Quantity.IsNull() {
		res.Quantity = &v.Quantity
	}

	if !v.Description.IsNull() {
		res.Description = &v.Description
	}

	if !v.DetailType.IsNull() {
		res.DetailType = &v.DetailType
	}

	if !v.Domain.IsNull() {
		res.Domain = &v.Domain
	}

	return res
}

func (v *OrderDetailsValue) UnmarshalJSON(data []byte) error {
	type JsonOrderDetailsValue OrderDetailsValue

	var tmp JsonOrderDetailsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Description = tmp.Description
	v.DetailType = tmp.DetailType
	v.Domain = tmp.Domain
	v.OrderDetailId = tmp.OrderDetailId
	v.Quantity = tmp.Quantity

	v.state = attr.ValueStateKnown

	return nil
}

func (v *OrderDetailsValue) MergeWith(other *OrderDetailsValue) {

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.DetailType.IsUnknown() || v.DetailType.IsNull()) && !other.DetailType.IsUnknown() {
		v.DetailType = other.DetailType
	}

	if (v.Domain.IsUnknown() || v.Domain.IsNull()) && !other.Domain.IsUnknown() {
		v.Domain = other.Domain
	}

	if (v.OrderDetailId.IsUnknown() || v.OrderDetailId.IsNull()) && !other.OrderDetailId.IsUnknown() {
		v.OrderDetailId = other.OrderDetailId
	}

	if (v.Quantity.IsUnknown() || v.Quantity.IsNull()) && !other.Quantity.IsUnknown() {
		v.Quantity = other.Quantity
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v OrderDetailsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"description":   v.Description,
		"detailType":    v.DetailType,
		"domain":        v.Domain,
		"orderDetailId": v.OrderDetailId,
		"quantity":      v.Quantity,
	}
}
func (v OrderDetailsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["detail_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["order_detail_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["quantity"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DetailType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detail_type"] = val

		val, err = v.Domain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain"] = val

		val, err = v.OrderDetailId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order_detail_id"] = val

		val, err = v.Quantity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quantity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrderDetailsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrderDetailsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrderDetailsValue) String() string {
	return "OrderDetailsValue"
}

func (v OrderDetailsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"description":     ovhtypes.TfStringType{},
			"detail_type":     ovhtypes.TfStringType{},
			"domain":          ovhtypes.TfStringType{},
			"order_detail_id": ovhtypes.TfInt64Type{},
			"quantity":        ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"description":     v.Description,
			"detail_type":     v.DetailType,
			"domain":          v.Domain,
			"order_detail_id": v.OrderDetailId,
			"quantity":        v.Quantity,
		})

	return objVal, diags
}

func (v OrderDetailsValue) Equal(o attr.Value) bool {
	other, ok := o.(OrderDetailsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DetailType.Equal(other.DetailType) {
		return false
	}

	if !v.Domain.Equal(other.Domain) {
		return false
	}

	if !v.OrderDetailId.Equal(other.OrderDetailId) {
		return false
	}

	if !v.Quantity.Equal(other.Quantity) {
		return false
	}

	return true
}

func (v OrderDetailsValue) Type(ctx context.Context) attr.Type {
	return OrderDetailsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrderDetailsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":     ovhtypes.TfStringType{},
		"detail_type":     ovhtypes.TfStringType{},
		"domain":          ovhtypes.TfStringType{},
		"order_detail_id": ovhtypes.TfInt64Type{},
		"quantity":        ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = PlanType{}

type PlanType struct {
	basetypes.ObjectType
}

func (t PlanType) Equal(o attr.Type) bool {
	other, ok := o.(PlanType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlanType) String() string {
	return "PlanType"
}

func (t PlanType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return nil, diags
	}

	configurationVal, ok := configurationAttribute.(ovhtypes.TfListNestedValue[PlanConfigurationValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be ovhtypes.TfListNestedValue[PlanConfigurationValue], was: %T`, configurationAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be ovhtypes.TfStringValue, was: %T`, durationAttribute))
	}

	itemIdAttribute, ok := attributes["item_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item_id is missing from object`)

		return nil, diags
	}

	itemIdVal, ok := itemIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item_id expected to be ovhtypes.TfInt64Value, was: %T`, itemIdAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return nil, diags
	}

	planCodeVal, ok := planCodeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be ovhtypes.TfStringValue, was: %T`, planCodeAttribute))
	}

	pricingModeAttribute, ok := attributes["pricing_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pricing_mode is missing from object`)

		return nil, diags
	}

	pricingModeVal, ok := pricingModeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pricing_mode expected to be ovhtypes.TfStringValue, was: %T`, pricingModeAttribute))
	}

	quantityAttribute, ok := attributes["quantity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quantity is missing from object`)

		return nil, diags
	}

	quantityVal, ok := quantityAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quantity expected to be ovhtypes.TfInt64Value, was: %T`, quantityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlanValue{
		Configuration: configurationVal,
		Duration:      durationVal,
		ItemId:        itemIdVal,
		PlanCode:      planCodeVal,
		PricingMode:   pricingModeVal,
		Quantity:      quantityVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewPlanValueNull() PlanValue {
	return PlanValue{
		state: attr.ValueStateNull,
	}
}

func NewPlanValueUnknown() PlanValue {
	return PlanValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlanValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlanValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlanValue Attribute Value",
				"While creating a PlanValue value, a missing attribute value was detected. "+
					"A PlanValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlanValue Attribute Type",
				"While creating a PlanValue value, an invalid attribute value was detected. "+
					"A PlanValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlanValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlanValue Attribute Value",
				"While creating a PlanValue value, an extra attribute value was detected. "+
					"A PlanValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlanValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlanValueUnknown(), diags
	}

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	configurationVal, ok := configurationAttribute.(ovhtypes.TfListNestedValue[PlanConfigurationValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be ovhtypes.TfListNestedValue[PlanConfigurationValue], was: %T`, configurationAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be ovhtypes.TfStringValue, was: %T`, durationAttribute))
	}

	itemIdAttribute, ok := attributes["item_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item_id is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	itemIdVal, ok := itemIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item_id expected to be ovhtypes.TfInt64Value, was: %T`, itemIdAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	planCodeVal, ok := planCodeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be ovhtypes.TfStringValue, was: %T`, planCodeAttribute))
	}

	pricingModeAttribute, ok := attributes["pricing_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pricing_mode is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	pricingModeVal, ok := pricingModeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pricing_mode expected to be ovhtypes.TfStringValue, was: %T`, pricingModeAttribute))
	}

	quantityAttribute, ok := attributes["quantity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quantity is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	quantityVal, ok := quantityAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quantity expected to be ovhtypes.TfInt64Value, was: %T`, quantityAttribute))
	}

	if diags.HasError() {
		return NewPlanValueUnknown(), diags
	}

	return PlanValue{
		Configuration: configurationVal,
		Duration:      durationVal,
		ItemId:        itemIdVal,
		PlanCode:      planCodeVal,
		PricingMode:   pricingModeVal,
		Quantity:      quantityVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewPlanValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlanValue {
	object, diags := NewPlanValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlanValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlanType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlanValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlanValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlanValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlanValueMust(PlanValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlanType) ValueType(ctx context.Context) attr.Value {
	return PlanValue{}
}

var _ basetypes.ObjectValuable = PlanValue{}

type PlanValue struct {
	Configuration ovhtypes.TfListNestedValue[PlanConfigurationValue] `tfsdk:"configuration" json:"configuration"`
	Duration      ovhtypes.TfStringValue                             `tfsdk:"duration" json:"duration"`
	ItemId        ovhtypes.TfInt64Value                              `tfsdk:"item_id" json:"itemId"`
	PlanCode      ovhtypes.TfStringValue                             `tfsdk:"plan_code" json:"planCode"`
	PricingMode   ovhtypes.TfStringValue                             `tfsdk:"pricing_mode" json:"pricingMode"`
	Quantity      ovhtypes.TfInt64Value                              `tfsdk:"quantity" json:"quantity"`
	state         attr.ValueState
}

type PlanWritableValue struct {
	*PlanValue    `json:"-"`
	Configuration *ovhtypes.TfListNestedValue[PlanConfigurationValue] `json:"configuration,omitempty"`
	Duration      *ovhtypes.TfStringValue                             `json:"duration,omitempty"`
	ItemId        *ovhtypes.TfInt64Value                              `json:"itemId,omitempty"`
	PlanCode      *ovhtypes.TfStringValue                             `json:"planCode,omitempty"`
	PricingMode   *ovhtypes.TfStringValue                             `json:"pricingMode,omitempty"`
	Quantity      *ovhtypes.TfInt64Value                              `json:"quantity,omitempty"`
}

func (opts PlanValue) FromResourceWithPath(d *legacyschema.ResourceData, path string) PlanValue {
	opts.Duration = ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.duration", path)).(string))}
	opts.PlanCode = ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.plan_code", path)).(string))}
	opts.PricingMode = ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.pricing_mode", path)).(string))}

	nbConfigs := d.Get(fmt.Sprintf("%s.configuration.#", path)).(int)
	var configs []attr.Value
	for i := 0; i < nbConfigs; i++ {
		cfg := PlanConfigurationValue{
			state: attr.ValueStateKnown,
			Label: ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.configuration.%d.label", path, i)).(string))},
			Value: ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.configuration.%d.value", path, i)).(string))},
		}
		configs = append(configs, cfg)
	}

	opts.Configuration = ovhtypes.TfListNestedValue[PlanConfigurationValue]{
		ListValue: basetypes.NewListValueMust(PlanConfigurationValue{}.Type(context.Background()), configs),
	}

	return opts
}

func (v PlanValue) ToCreate() *PlanWritableValue {
	res := &PlanWritableValue{}

	if !v.PricingMode.IsNull() {
		res.PricingMode = &v.PricingMode
	}

	if !v.Quantity.IsNull() {
		res.Quantity = &v.Quantity
	}

	if !v.Configuration.IsNull() {
		res.Configuration = &v.Configuration
	}

	if !v.Duration.IsNull() {
		res.Duration = &v.Duration
	}

	if !v.ItemId.IsNull() {
		res.ItemId = &v.ItemId
	}

	if !v.PlanCode.IsNull() {
		res.PlanCode = &v.PlanCode
	}

	return res
}

func (v *PlanValue) UnmarshalJSON(data []byte) error {
	type JsonPlanValue PlanValue

	var tmp JsonPlanValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Configuration = tmp.Configuration
	v.Duration = tmp.Duration
	v.ItemId = tmp.ItemId
	v.PlanCode = tmp.PlanCode
	v.PricingMode = tmp.PricingMode
	v.Quantity = tmp.Quantity

	v.state = attr.ValueStateKnown

	return nil
}

func (v *PlanValue) MergeWith(other *PlanValue) {

	if (v.Configuration.IsUnknown() || v.Configuration.IsNull()) && !other.Configuration.IsUnknown() {
		v.Configuration = other.Configuration
	} else if !other.Configuration.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Configuration.Elements()
		newElems := other.Configuration.Elements()

		if len(elems) != len(newElems) {
			v.Configuration = other.Configuration
		} else {
			for idx, e := range elems {
				tmp := e.(PlanConfigurationValue)
				tmp2 := newElems[idx].(PlanConfigurationValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Configuration = ovhtypes.TfListNestedValue[PlanConfigurationValue]{
				ListValue: basetypes.NewListValueMust(PlanConfigurationValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Duration.IsUnknown() || v.Duration.IsNull()) && !other.Duration.IsUnknown() {
		v.Duration = other.Duration
	}

	if (v.ItemId.IsUnknown() || v.ItemId.IsNull()) && !other.ItemId.IsUnknown() {
		v.ItemId = other.ItemId
	}

	if (v.PlanCode.IsUnknown() || v.PlanCode.IsNull()) && !other.PlanCode.IsUnknown() {
		v.PlanCode = other.PlanCode
	}

	if (v.PricingMode.IsUnknown() || v.PricingMode.IsNull()) && !other.PricingMode.IsUnknown() {
		v.PricingMode = other.PricingMode
	}

	if (v.Quantity.IsUnknown() || v.Quantity.IsNull()) && !other.Quantity.IsUnknown() {
		v.Quantity = other.Quantity
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v PlanValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"configuration": v.Configuration,
		"duration":      v.Duration,
		"itemId":        v.ItemId,
		"planCode":      v.PlanCode,
		"pricingMode":   v.PricingMode,
		"quantity":      v.Quantity,
	}
}
func (v PlanValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["configuration"] = basetypes.ListType{
		ElemType: PlanConfigurationValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["duration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["item_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["plan_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pricing_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quantity"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Configuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configuration"] = val

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.ItemId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["item_id"] = val

		val, err = v.PlanCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_code"] = val

		val, err = v.PricingMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pricing_mode"] = val

		val, err = v.Quantity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quantity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlanValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlanValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlanValue) String() string {
	return "PlanValue"
}

func (v PlanValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"configuration": ovhtypes.NewTfListNestedType[PlanConfigurationValue](ctx),
			"duration":      ovhtypes.TfStringType{},
			"item_id":       ovhtypes.TfInt64Type{},
			"plan_code":     ovhtypes.TfStringType{},
			"pricing_mode":  ovhtypes.TfStringType{},
			"quantity":      ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"configuration": v.Configuration,
			"duration":      v.Duration,
			"item_id":       v.ItemId,
			"plan_code":     v.PlanCode,
			"pricing_mode":  v.PricingMode,
			"quantity":      v.Quantity,
		})

	return objVal, diags
}

func (v PlanValue) Equal(o attr.Value) bool {
	other, ok := o.(PlanValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Configuration.Equal(other.Configuration) {
		return false
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.ItemId.Equal(other.ItemId) {
		return false
	}

	if !v.PlanCode.Equal(other.PlanCode) {
		return false
	}

	if !v.PricingMode.Equal(other.PricingMode) {
		return false
	}

	if !v.Quantity.Equal(other.Quantity) {
		return false
	}

	return true
}

func (v PlanValue) Type(ctx context.Context) attr.Type {
	return PlanType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlanValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configuration": ovhtypes.NewTfListNestedType[PlanConfigurationValue](ctx),
		"duration":      ovhtypes.TfStringType{},
		"item_id":       ovhtypes.TfInt64Type{},
		"plan_code":     ovhtypes.TfStringType{},
		"pricing_mode":  ovhtypes.TfStringType{},
		"quantity":      ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = PlanConfigurationType{}

type PlanConfigurationType struct {
	basetypes.ObjectType
}

func (t PlanConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(PlanConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlanConfigurationType) String() string {
	return "PlanConfigurationType"
}

func (t PlanConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be ovhtypes.TfStringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlanConfigurationValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlanConfigurationValueNull() PlanConfigurationValue {
	return PlanConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewPlanConfigurationValueUnknown() PlanConfigurationValue {
	return PlanConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlanConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlanConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlanConfigurationValue Attribute Value",
				"While creating a PlanConfigurationValue value, a missing attribute value was detected. "+
					"A PlanConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlanConfigurationValue Attribute Type",
				"While creating a PlanConfigurationValue value, an invalid attribute value was detected. "+
					"A PlanConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlanConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlanConfigurationValue Attribute Value",
				"While creating a PlanConfigurationValue value, an extra attribute value was detected. "+
					"A PlanConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlanConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlanConfigurationValueUnknown(), diags
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewPlanConfigurationValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be ovhtypes.TfStringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewPlanConfigurationValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewPlanConfigurationValueUnknown(), diags
	}

	return PlanConfigurationValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlanConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlanConfigurationValue {
	object, diags := NewPlanConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlanConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlanConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlanConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlanConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlanConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlanConfigurationValueMust(PlanConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlanConfigurationType) ValueType(ctx context.Context) attr.Value {
	return PlanConfigurationValue{}
}

var _ basetypes.ObjectValuable = PlanConfigurationValue{}

type PlanConfigurationValue struct {
	Label ovhtypes.TfStringValue `tfsdk:"label" json:"label"`
	Value ovhtypes.TfStringValue `tfsdk:"value" json:"value"`
	state attr.ValueState
}

type PlanConfigurationWritableValue struct {
	*PlanConfigurationValue `json:"-"`
	Label                   *ovhtypes.TfStringValue `json:"label,omitempty"`
	Value                   *ovhtypes.TfStringValue `json:"value,omitempty"`
}

func (v PlanConfigurationValue) ToCreate() *PlanConfigurationWritableValue {
	res := &PlanConfigurationWritableValue{}

	if !v.Label.IsNull() {
		res.Label = &v.Label
	}

	if !v.Value.IsNull() {
		res.Value = &v.Value
	}

	return res
}

func (v *PlanConfigurationValue) UnmarshalJSON(data []byte) error {
	type JsonPlanConfigurationValue PlanConfigurationValue

	var tmp JsonPlanConfigurationValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Label = tmp.Label
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *PlanConfigurationValue) MergeWith(other *PlanConfigurationValue) {

	if (v.Label.IsUnknown() || v.Label.IsNull()) && !other.Label.IsUnknown() {
		v.Label = other.Label
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v PlanConfigurationValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"label": v.Label,
		"value": v.Value,
	}
}
func (v PlanConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlanConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlanConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlanConfigurationValue) String() string {
	return "PlanConfigurationValue"
}

func (v PlanConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"label": ovhtypes.TfStringType{},
			"value": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"label": v.Label,
			"value": v.Value,
		})

	return objVal, diags
}

func (v PlanConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(PlanConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v PlanConfigurationValue) Type(ctx context.Context) attr.Type {
	return PlanConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlanConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"label": ovhtypes.TfStringType{},
		"value": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = PlanOptionType{}

type PlanOptionType struct {
	basetypes.ObjectType
}

func (t PlanOptionType) Equal(o attr.Type) bool {
	other, ok := o.(PlanOptionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlanOptionType) String() string {
	return "PlanOptionType"
}

func (t PlanOptionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return nil, diags
	}

	configurationVal, ok := configurationAttribute.(ovhtypes.TfListNestedValue[PlanOptionConfigurationValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be ovhtypes.TfListNestedValue[PlanOptionConfigurationValue], was: %T`, configurationAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be ovhtypes.TfStringValue, was: %T`, durationAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return nil, diags
	}

	planCodeVal, ok := planCodeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be ovhtypes.TfStringValue, was: %T`, planCodeAttribute))
	}

	pricingModeAttribute, ok := attributes["pricing_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pricing_mode is missing from object`)

		return nil, diags
	}

	pricingModeVal, ok := pricingModeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pricing_mode expected to be ovhtypes.TfStringValue, was: %T`, pricingModeAttribute))
	}

	quantityAttribute, ok := attributes["quantity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quantity is missing from object`)

		return nil, diags
	}

	quantityVal, ok := quantityAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quantity expected to be ovhtypes.TfInt64Value, was: %T`, quantityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlanOptionValue{
		Configuration: configurationVal,
		Duration:      durationVal,
		PlanCode:      planCodeVal,
		PricingMode:   pricingModeVal,
		Quantity:      quantityVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewPlanOptionValueNull() PlanOptionValue {
	return PlanOptionValue{
		state: attr.ValueStateNull,
	}
}

func NewPlanOptionValueUnknown() PlanOptionValue {
	return PlanOptionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlanOptionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlanOptionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlanOptionValue Attribute Value",
				"While creating a PlanOptionValue value, a missing attribute value was detected. "+
					"A PlanOptionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanOptionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlanOptionValue Attribute Type",
				"While creating a PlanOptionValue value, an invalid attribute value was detected. "+
					"A PlanOptionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanOptionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlanOptionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlanOptionValue Attribute Value",
				"While creating a PlanOptionValue value, an extra attribute value was detected. "+
					"A PlanOptionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlanOptionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlanOptionValueUnknown(), diags
	}

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return NewPlanOptionValueUnknown(), diags
	}

	configurationVal, ok := configurationAttribute.(ovhtypes.TfListNestedValue[PlanOptionConfigurationValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be ovhtypes.TfListNestedValue[PlanOptionConfigurationValue], was: %T`, configurationAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewPlanOptionValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be ovhtypes.TfStringValue, was: %T`, durationAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return NewPlanOptionValueUnknown(), diags
	}

	planCodeVal, ok := planCodeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be ovhtypes.TfStringValue, was: %T`, planCodeAttribute))
	}

	pricingModeAttribute, ok := attributes["pricing_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pricing_mode is missing from object`)

		return NewPlanOptionValueUnknown(), diags
	}

	pricingModeVal, ok := pricingModeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pricing_mode expected to be ovhtypes.TfStringValue, was: %T`, pricingModeAttribute))
	}

	quantityAttribute, ok := attributes["quantity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quantity is missing from object`)

		return NewPlanOptionValueUnknown(), diags
	}

	quantityVal, ok := quantityAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quantity expected to be ovhtypes.TfInt64Value, was: %T`, quantityAttribute))
	}

	if diags.HasError() {
		return NewPlanOptionValueUnknown(), diags
	}

	return PlanOptionValue{
		Configuration: configurationVal,
		Duration:      durationVal,
		PlanCode:      planCodeVal,
		PricingMode:   pricingModeVal,
		Quantity:      quantityVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewPlanOptionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlanOptionValue {
	object, diags := NewPlanOptionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlanOptionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlanOptionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlanOptionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlanOptionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlanOptionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlanOptionValueMust(PlanOptionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlanOptionType) ValueType(ctx context.Context) attr.Value {
	return PlanOptionValue{}
}

var _ basetypes.ObjectValuable = PlanOptionValue{}

type PlanOptionValue struct {
	Configuration ovhtypes.TfListNestedValue[PlanOptionConfigurationValue] `tfsdk:"configuration" json:"configuration"`
	Duration      ovhtypes.TfStringValue                                   `tfsdk:"duration" json:"duration"`
	ItemId        ovhtypes.TfInt64Value                                    `tfsdk:"-" json:"itemId"`
	PlanCode      ovhtypes.TfStringValue                                   `tfsdk:"plan_code" json:"planCode"`
	PricingMode   ovhtypes.TfStringValue                                   `tfsdk:"pricing_mode" json:"pricingMode"`
	Quantity      ovhtypes.TfInt64Value                                    `tfsdk:"quantity" json:"quantity"`
	state         attr.ValueState
}

type PlanOptionWritableValue struct {
	*PlanOptionValue `json:"-"`
	Configuration    *ovhtypes.TfListNestedValue[PlanOptionConfigurationValue] `json:"configuration,omitempty"`
	Duration         *ovhtypes.TfStringValue                                   `json:"duration,omitempty"`
	ItemId           *ovhtypes.TfInt64Value                                    `json:"itemId,omitempty"`
	PlanCode         *ovhtypes.TfStringValue                                   `json:"planCode,omitempty"`
	PricingMode      *ovhtypes.TfStringValue                                   `json:"pricingMode,omitempty"`
	Quantity         *ovhtypes.TfInt64Value                                    `json:"quantity,omitempty"`
}

func (opts PlanOptionValue) FromResourceWithPath(d *legacyschema.ResourceData, path string) PlanOptionValue {
	opts.Duration = ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.duration", path)).(string))}
	opts.PlanCode = ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.plan_code", path)).(string))}
	opts.PricingMode = ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.pricing_mode", path)).(string))}

	nbConfigs := d.Get(fmt.Sprintf("%s.configuration.#", path)).(int)
	var configs []attr.Value
	for i := 0; i < nbConfigs; i++ {
		cfg := PlanOptionConfigurationValue{
			state: attr.ValueStateKnown,
			Label: ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.configuration.%d.label", path, i)).(string))},
			Value: ovhtypes.TfStringValue{StringValue: basetypes.NewStringValue(d.Get(fmt.Sprintf("%s.configuration.%d.value", path, i)).(string))},
		}
		configs = append(configs, cfg)
	}

	opts.Configuration = ovhtypes.TfListNestedValue[PlanOptionConfigurationValue]{
		ListValue: basetypes.NewListValueMust(PlanOptionConfigurationValue{}.Type(context.Background()), configs),
	}

	return opts
}

func (v PlanOptionValue) ToCreate() *PlanOptionWritableValue {
	res := &PlanOptionWritableValue{}

	if !v.Configuration.IsNull() {
		res.Configuration = &v.Configuration
	}

	if !v.Duration.IsNull() {
		res.Duration = &v.Duration
	}

	if !v.ItemId.IsNull() {
		res.ItemId = &v.ItemId
	}

	if !v.PlanCode.IsNull() {
		res.PlanCode = &v.PlanCode
	}

	if !v.PricingMode.IsNull() {
		res.PricingMode = &v.PricingMode
	}

	if !v.Quantity.IsNull() {
		res.Quantity = &v.Quantity
	}

	return res
}

func (v *PlanOptionValue) UnmarshalJSON(data []byte) error {
	type JsonPlanOptionValue PlanOptionValue

	var tmp JsonPlanOptionValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Configuration = tmp.Configuration
	v.Duration = tmp.Duration
	v.ItemId = tmp.ItemId
	v.PlanCode = tmp.PlanCode
	v.PricingMode = tmp.PricingMode
	v.Quantity = tmp.Quantity

	v.state = attr.ValueStateKnown

	return nil
}

func (v *PlanOptionValue) MergeWith(other *PlanOptionValue) {
	if (v.Configuration.IsUnknown() || v.Configuration.IsNull()) && !other.Configuration.IsUnknown() {
		v.Configuration = other.Configuration
	} else if !other.Configuration.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Configuration.Elements()
		newElems := other.Configuration.Elements()

		if len(elems) != len(newElems) {
			v.Configuration = other.Configuration
		} else {
			for idx, e := range elems {
				tmp := e.(PlanOptionConfigurationValue)
				tmp2 := newElems[idx].(PlanOptionConfigurationValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Configuration = ovhtypes.TfListNestedValue[PlanOptionConfigurationValue]{
				ListValue: basetypes.NewListValueMust(PlanOptionConfigurationValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.Duration.IsUnknown() || v.Duration.IsNull()) && !other.Duration.IsUnknown() {
		v.Duration = other.Duration
	}

	if v.ItemId.IsUnknown() || v.ItemId.IsNull() {
		if !other.ItemId.IsUnknown() {
			v.ItemId = other.ItemId
		} else {
			v.ItemId = ovhtypes.NewTfInt64ValueNull()
		}
	}

	if (v.PlanCode.IsUnknown() || v.PlanCode.IsNull()) && !other.PlanCode.IsUnknown() {
		v.PlanCode = other.PlanCode
	}

	if (v.PricingMode.IsUnknown() || v.PricingMode.IsNull()) && !other.PricingMode.IsUnknown() {
		v.PricingMode = other.PricingMode
	}

	if (v.Quantity.IsUnknown() || v.Quantity.IsNull()) && !other.Quantity.IsUnknown() {
		v.Quantity = other.Quantity
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v PlanOptionValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"configuration": v.Configuration,
		"duration":      v.Duration,
		"itemId":        v.ItemId,
		"planCode":      v.PlanCode,
		"pricingMode":   v.PricingMode,
		"quantity":      v.Quantity,
	}
}
func (v PlanOptionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["configuration"] = basetypes.ListType{
		ElemType: PlanOptionConfigurationValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["duration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pricing_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quantity"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Configuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configuration"] = val

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.PlanCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_code"] = val

		val, err = v.PricingMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pricing_mode"] = val

		val, err = v.Quantity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quantity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlanOptionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlanOptionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlanOptionValue) String() string {
	return "PlanOptionValue"
}

func (v PlanOptionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"configuration": ovhtypes.NewTfListNestedType[PlanOptionConfigurationValue](ctx),
			"duration":      ovhtypes.TfStringType{},
			"plan_code":     ovhtypes.TfStringType{},
			"pricing_mode":  ovhtypes.TfStringType{},
			"quantity":      ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"configuration": v.Configuration,
			"duration":      v.Duration,
			"plan_code":     v.PlanCode,
			"pricing_mode":  v.PricingMode,
			"quantity":      v.Quantity,
		})

	return objVal, diags
}

func (v PlanOptionValue) Equal(o attr.Value) bool {
	other, ok := o.(PlanOptionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Configuration.Equal(other.Configuration) {
		return false
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.ItemId.Equal(other.ItemId) {
		return false
	}

	if !v.PlanCode.Equal(other.PlanCode) {
		return false
	}

	if !v.PricingMode.Equal(other.PricingMode) {
		return false
	}

	if !v.Quantity.Equal(other.Quantity) {
		return false
	}

	return true
}

func (v PlanOptionValue) Type(ctx context.Context) attr.Type {
	return PlanOptionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlanOptionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configuration": ovhtypes.NewTfListNestedType[PlanOptionConfigurationValue](ctx),
		"duration":      ovhtypes.TfStringType{},
		"plan_code":     ovhtypes.TfStringType{},
		"pricing_mode":  ovhtypes.TfStringType{},
		"quantity":      ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = PlanOptionConfigurationType{}

type PlanOptionConfigurationType struct {
	basetypes.ObjectType
}

func (t PlanOptionConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(PlanOptionConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlanOptionConfigurationType) String() string {
	return "PlanOptionConfigurationType"
}

func (t PlanOptionConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be ovhtypes.TfStringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlanOptionConfigurationValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlanOptionConfigurationValueNull() PlanOptionConfigurationValue {
	return PlanOptionConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewPlanOptionConfigurationValueUnknown() PlanOptionConfigurationValue {
	return PlanOptionConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlanOptionConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlanOptionConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlanOptionConfigurationValue Attribute Value",
				"While creating a PlanOptionConfigurationValue value, a missing attribute value was detected. "+
					"A PlanOptionConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanOptionConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlanOptionConfigurationValue Attribute Type",
				"While creating a PlanOptionConfigurationValue value, an invalid attribute value was detected. "+
					"A PlanOptionConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanOptionConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlanOptionConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlanOptionConfigurationValue Attribute Value",
				"While creating a PlanOptionConfigurationValue value, an extra attribute value was detected. "+
					"A PlanOptionConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlanOptionConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlanOptionConfigurationValueUnknown(), diags
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewPlanOptionConfigurationValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be ovhtypes.TfStringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewPlanOptionConfigurationValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewPlanOptionConfigurationValueUnknown(), diags
	}

	return PlanOptionConfigurationValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlanOptionConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlanOptionConfigurationValue {
	object, diags := NewPlanOptionConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlanOptionConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlanOptionConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlanOptionConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlanOptionConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlanOptionConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlanOptionConfigurationValueMust(PlanOptionConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlanOptionConfigurationType) ValueType(ctx context.Context) attr.Value {
	return PlanOptionConfigurationValue{}
}

var _ basetypes.ObjectValuable = PlanOptionConfigurationValue{}

type PlanOptionConfigurationValue struct {
	Label ovhtypes.TfStringValue `tfsdk:"label" json:"label"`
	Value ovhtypes.TfStringValue `tfsdk:"value" json:"value"`
	state attr.ValueState
}

type PlanOptionConfigurationWritableValue struct {
	*PlanOptionConfigurationValue `json:"-"`
	Label                         *ovhtypes.TfStringValue `json:"label,omitempty"`
	Value                         *ovhtypes.TfStringValue `json:"value,omitempty"`
}

func (v PlanOptionConfigurationValue) ToCreate() *PlanOptionConfigurationWritableValue {
	res := &PlanOptionConfigurationWritableValue{}

	if !v.Label.IsNull() {
		res.Label = &v.Label
	}

	if !v.Value.IsNull() {
		res.Value = &v.Value
	}

	return res
}

func (v *PlanOptionConfigurationValue) UnmarshalJSON(data []byte) error {
	type JsonPlanOptionConfigurationValue PlanOptionConfigurationValue

	var tmp JsonPlanOptionConfigurationValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Label = tmp.Label
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *PlanOptionConfigurationValue) MergeWith(other *PlanOptionConfigurationValue) {

	if (v.Label.IsUnknown() || v.Label.IsNull()) && !other.Label.IsUnknown() {
		v.Label = other.Label
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v PlanOptionConfigurationValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"label": v.Label,
		"value": v.Value,
	}
}
func (v PlanOptionConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlanOptionConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlanOptionConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlanOptionConfigurationValue) String() string {
	return "PlanOptionConfigurationValue"
}

func (v PlanOptionConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"label": ovhtypes.TfStringType{},
			"value": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"label": v.Label,
			"value": v.Value,
		})

	return objVal, diags
}

func (v PlanOptionConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(PlanOptionConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v PlanOptionConfigurationValue) Type(ctx context.Context) attr.Type {
	return PlanOptionConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlanOptionConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"label": ovhtypes.TfStringType{},
		"value": ovhtypes.TfStringType{},
	}
}
