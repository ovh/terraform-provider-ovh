// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DedicatedServerSpecificationsHardwareDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"boot_mode": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "Server boot mode",
				MarkdownDescription: "Server boot mode",
			},
			"cores_per_processor": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Computed:            true,
				Description:         "number of cores per processor",
				MarkdownDescription: "number of cores per processor",
			},
			"default_hardware_raid_size": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"unit": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Computed:   true,
					},
					"value": schema.Int64Attribute{
						CustomType: ovhtypes.TfInt64Type{},
						Computed:   true,
					},
				},
				CustomType: DefaultHardwareRaidSizeType{
					ObjectType: types.ObjectType{
						AttrTypes: DefaultHardwareRaidSizeValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Default hardware raid size for this server",
				MarkdownDescription: "Default hardware raid size for this server",
			},
			"default_hardware_raid_type": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "Default hardware raid type configured on this server",
				MarkdownDescription: "Default hardware raid type configured on this server",
			},
			"description": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "commercial name of this server",
				MarkdownDescription: "commercial name of this server",
			},
			"disk_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"default_hardware_raid_size": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"unit": schema.StringAttribute{
									CustomType: ovhtypes.TfStringType{},
									Computed:   true,
								},
								"value": schema.Int64Attribute{
									CustomType: ovhtypes.TfInt64Type{},
									Computed:   true,
								},
							},
							CustomType: DiskGroupsDefaultHardwareRaidSizeType{
								ObjectType: types.ObjectType{
									AttrTypes: DiskGroupsDefaultHardwareRaidSizeValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "default hardware raid size for this disk group",
							MarkdownDescription: "default hardware raid size for this disk group",
						},
						"default_hardware_raid_type": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "default hardware raid type for this disk group",
							MarkdownDescription: "default hardware raid type for this disk group",
						},
						"description": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "human readable description of this disk group",
							MarkdownDescription: "human readable description of this disk group",
						},
						"disk_group_id": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "identifier of this disk group",
							MarkdownDescription: "identifier of this disk group",
						},
						"disk_size": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"unit": schema.StringAttribute{
									CustomType: ovhtypes.TfStringType{},
									Computed:   true,
								},
								"value": schema.Int64Attribute{
									CustomType: ovhtypes.TfInt64Type{},
									Computed:   true,
								},
							},
							CustomType: DiskGroupsDiskSizeType{
								ObjectType: types.ObjectType{
									AttrTypes: DiskGroupsDiskSizeValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "disk capacity",
							MarkdownDescription: "disk capacity",
						},
						"disk_type": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "type of the disk (SSD, SATA, SAS, ...)",
							MarkdownDescription: "type of the disk (SSD, SATA, SAS, ...)",
						},
						"number_of_disks": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "number of disks in this group",
							MarkdownDescription: "number of disks in this group",
						},
						"raid_controller": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "raid controller, if any, managing this group of disks",
							MarkdownDescription: "raid controller, if any, managing this group of disks",
						},
					},
					CustomType: DiskGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: DiskGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				CustomType:          ovhtypes.NewTfListNestedType[DiskGroupsValue](ctx),
				Computed:            true,
				Description:         "details about the groups of disks in the server",
				MarkdownDescription: "details about the groups of disks in the server",
			},
			"expansion_cards": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "expansion card description",
							MarkdownDescription: "expansion card description",
						},
						"type": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Expansion card type enum",
							MarkdownDescription: "Expansion card type enum",
						},
					},
					CustomType: ExpansionCardsType{
						ObjectType: types.ObjectType{
							AttrTypes: ExpansionCardsValue{}.AttributeTypes(ctx),
						},
					},
				},
				CustomType:          ovhtypes.NewTfListNestedType[ExpansionCardsValue](ctx),
				Computed:            true,
				Description:         "details about the server's expansion cards",
				MarkdownDescription: "details about the server's expansion cards",
			},
			"form_factor": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "Server form factor",
				MarkdownDescription: "Server form factor",
			},
			"memory_size": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"unit": schema.StringAttribute{
						CustomType: ovhtypes.TfStringType{},
						Computed:   true,
					},
					"value": schema.Int64Attribute{
						CustomType: ovhtypes.TfInt64Type{},
						Computed:   true,
					},
				},
				CustomType: MemorySizeType{
					ObjectType: types.ObjectType{
						AttrTypes: MemorySizeValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "ram capacity",
				MarkdownDescription: "ram capacity",
			},
			"motherboard": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "server motherboard",
				MarkdownDescription: "server motherboard",
			},
			"number_of_processors": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Computed:            true,
				Description:         "number of processors in this dedicated server",
				MarkdownDescription: "number of processors in this dedicated server",
			},
			"processor_architecture": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "processor architecture bit",
				MarkdownDescription: "processor architecture bit",
			},
			"processor_name": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Computed:            true,
				Description:         "processor name",
				MarkdownDescription: "processor name",
			},
			"service_name": schema.StringAttribute{
				CustomType:          ovhtypes.TfStringType{},
				Required:            true,
				Description:         "The internal name of your dedicated server",
				MarkdownDescription: "The internal name of your dedicated server",
			},
			"threads_per_processor": schema.Int64Attribute{
				CustomType:          ovhtypes.TfInt64Type{},
				Computed:            true,
				Description:         "number of threads per processor",
				MarkdownDescription: "number of threads per processor",
			},
			"usb_keys": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"unit": schema.StringAttribute{
							CustomType: ovhtypes.TfStringType{},
							Computed:   true,
						},
						"value": schema.Int64Attribute{
							CustomType: ovhtypes.TfInt64Type{},
							Computed:   true,
						},
					},
					CustomType: UsbKeysType{
						ObjectType: types.ObjectType{
							AttrTypes: UsbKeysValue{}.AttributeTypes(ctx),
						},
					},
				},
				CustomType:          ovhtypes.NewTfListNestedType[UsbKeysValue](ctx),
				Computed:            true,
				Description:         "Capacity of the USB keys installed on your server, if any",
				MarkdownDescription: "Capacity of the USB keys installed on your server, if any",
			},
		},
	}
}

type DedicatedServerSpecificationsHardwareModel struct {
	BootMode                ovhtypes.TfStringValue                          `tfsdk:"boot_mode" json:"bootMode"`
	CoresPerProcessor       ovhtypes.TfInt64Value                           `tfsdk:"cores_per_processor" json:"coresPerProcessor"`
	DefaultHardwareRaidSize DefaultHardwareRaidSizeValue                    `tfsdk:"default_hardware_raid_size" json:"defaultHardwareRaidSize"`
	DefaultHardwareRaidType ovhtypes.TfStringValue                          `tfsdk:"default_hardware_raid_type" json:"defaultHardwareRaidType"`
	Description             ovhtypes.TfStringValue                          `tfsdk:"description" json:"description"`
	DiskGroups              ovhtypes.TfListNestedValue[DiskGroupsValue]     `tfsdk:"disk_groups" json:"diskGroups"`
	ExpansionCards          ovhtypes.TfListNestedValue[ExpansionCardsValue] `tfsdk:"expansion_cards" json:"expansionCards"`
	FormFactor              ovhtypes.TfStringValue                          `tfsdk:"form_factor" json:"formFactor"`
	MemorySize              MemorySizeValue                                 `tfsdk:"memory_size" json:"memorySize"`
	Motherboard             ovhtypes.TfStringValue                          `tfsdk:"motherboard" json:"motherboard"`
	NumberOfProcessors      ovhtypes.TfInt64Value                           `tfsdk:"number_of_processors" json:"numberOfProcessors"`
	ProcessorArchitecture   ovhtypes.TfStringValue                          `tfsdk:"processor_architecture" json:"processorArchitecture"`
	ProcessorName           ovhtypes.TfStringValue                          `tfsdk:"processor_name" json:"processorName"`
	ServiceName             ovhtypes.TfStringValue                          `tfsdk:"service_name" json:"serviceName"`
	ThreadsPerProcessor     ovhtypes.TfInt64Value                           `tfsdk:"threads_per_processor" json:"threadsPerProcessor"`
	UsbKeys                 ovhtypes.TfListNestedValue[UsbKeysValue]        `tfsdk:"usb_keys" json:"usbKeys"`
}

func (v *DedicatedServerSpecificationsHardwareModel) MergeWith(other *DedicatedServerSpecificationsHardwareModel) {

	if (v.BootMode.IsUnknown() || v.BootMode.IsNull()) && !other.BootMode.IsUnknown() {
		v.BootMode = other.BootMode
	}

	if (v.CoresPerProcessor.IsUnknown() || v.CoresPerProcessor.IsNull()) && !other.CoresPerProcessor.IsUnknown() {
		v.CoresPerProcessor = other.CoresPerProcessor
	}

	if (v.DefaultHardwareRaidSize.IsUnknown() || v.DefaultHardwareRaidSize.IsNull()) && !other.DefaultHardwareRaidSize.IsUnknown() {
		v.DefaultHardwareRaidSize = other.DefaultHardwareRaidSize
	}

	if (v.DefaultHardwareRaidType.IsUnknown() || v.DefaultHardwareRaidType.IsNull()) && !other.DefaultHardwareRaidType.IsUnknown() {
		v.DefaultHardwareRaidType = other.DefaultHardwareRaidType
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.DiskGroups.IsUnknown() || v.DiskGroups.IsNull()) && !other.DiskGroups.IsUnknown() {
		v.DiskGroups = other.DiskGroups
	}

	if (v.ExpansionCards.IsUnknown() || v.ExpansionCards.IsNull()) && !other.ExpansionCards.IsUnknown() {
		v.ExpansionCards = other.ExpansionCards
	}

	if (v.FormFactor.IsUnknown() || v.FormFactor.IsNull()) && !other.FormFactor.IsUnknown() {
		v.FormFactor = other.FormFactor
	}

	if (v.MemorySize.IsUnknown() || v.MemorySize.IsNull()) && !other.MemorySize.IsUnknown() {
		v.MemorySize = other.MemorySize
	}

	if (v.Motherboard.IsUnknown() || v.Motherboard.IsNull()) && !other.Motherboard.IsUnknown() {
		v.Motherboard = other.Motherboard
	}

	if (v.NumberOfProcessors.IsUnknown() || v.NumberOfProcessors.IsNull()) && !other.NumberOfProcessors.IsUnknown() {
		v.NumberOfProcessors = other.NumberOfProcessors
	}

	if (v.ProcessorArchitecture.IsUnknown() || v.ProcessorArchitecture.IsNull()) && !other.ProcessorArchitecture.IsUnknown() {
		v.ProcessorArchitecture = other.ProcessorArchitecture
	}

	if (v.ProcessorName.IsUnknown() || v.ProcessorName.IsNull()) && !other.ProcessorName.IsUnknown() {
		v.ProcessorName = other.ProcessorName
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

	if (v.ThreadsPerProcessor.IsUnknown() || v.ThreadsPerProcessor.IsNull()) && !other.ThreadsPerProcessor.IsUnknown() {
		v.ThreadsPerProcessor = other.ThreadsPerProcessor
	}

	if (v.UsbKeys.IsUnknown() || v.UsbKeys.IsNull()) && !other.UsbKeys.IsUnknown() {
		v.UsbKeys = other.UsbKeys
	}

}

var _ basetypes.ObjectTypable = DefaultHardwareRaidSizeType{}

type DefaultHardwareRaidSizeType struct {
	basetypes.ObjectType
}

func (t DefaultHardwareRaidSizeType) Equal(o attr.Type) bool {
	other, ok := o.(DefaultHardwareRaidSizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DefaultHardwareRaidSizeType) String() string {
	return "DefaultHardwareRaidSizeType"
}

func (t DefaultHardwareRaidSizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DefaultHardwareRaidSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDefaultHardwareRaidSizeValueNull() DefaultHardwareRaidSizeValue {
	return DefaultHardwareRaidSizeValue{
		state: attr.ValueStateNull,
	}
}

func NewDefaultHardwareRaidSizeValueUnknown() DefaultHardwareRaidSizeValue {
	return DefaultHardwareRaidSizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDefaultHardwareRaidSizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DefaultHardwareRaidSizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DefaultHardwareRaidSizeValue Attribute Value",
				"While creating a DefaultHardwareRaidSizeValue value, a missing attribute value was detected. "+
					"A DefaultHardwareRaidSizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DefaultHardwareRaidSizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DefaultHardwareRaidSizeValue Attribute Type",
				"While creating a DefaultHardwareRaidSizeValue value, an invalid attribute value was detected. "+
					"A DefaultHardwareRaidSizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DefaultHardwareRaidSizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DefaultHardwareRaidSizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DefaultHardwareRaidSizeValue Attribute Value",
				"While creating a DefaultHardwareRaidSizeValue value, an extra attribute value was detected. "+
					"A DefaultHardwareRaidSizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DefaultHardwareRaidSizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDefaultHardwareRaidSizeValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewDefaultHardwareRaidSizeValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewDefaultHardwareRaidSizeValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewDefaultHardwareRaidSizeValueUnknown(), diags
	}

	return DefaultHardwareRaidSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDefaultHardwareRaidSizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DefaultHardwareRaidSizeValue {
	object, diags := NewDefaultHardwareRaidSizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDefaultHardwareRaidSizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DefaultHardwareRaidSizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDefaultHardwareRaidSizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDefaultHardwareRaidSizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDefaultHardwareRaidSizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDefaultHardwareRaidSizeValueMust(DefaultHardwareRaidSizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DefaultHardwareRaidSizeType) ValueType(ctx context.Context) attr.Value {
	return DefaultHardwareRaidSizeValue{}
}

var _ basetypes.ObjectValuable = DefaultHardwareRaidSizeValue{}

type DefaultHardwareRaidSizeValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *DefaultHardwareRaidSizeValue) UnmarshalJSON(data []byte) error {
	type JsonDefaultHardwareRaidSizeValue DefaultHardwareRaidSizeValue

	var tmp JsonDefaultHardwareRaidSizeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *DefaultHardwareRaidSizeValue) MergeWith(other *DefaultHardwareRaidSizeValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v DefaultHardwareRaidSizeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v DefaultHardwareRaidSizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DefaultHardwareRaidSizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DefaultHardwareRaidSizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DefaultHardwareRaidSizeValue) String() string {
	return "DefaultHardwareRaidSizeValue"
}

func (v DefaultHardwareRaidSizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v DefaultHardwareRaidSizeValue) Equal(o attr.Value) bool {
	other, ok := o.(DefaultHardwareRaidSizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v DefaultHardwareRaidSizeValue) Type(ctx context.Context) attr.Type {
	return DefaultHardwareRaidSizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DefaultHardwareRaidSizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = DiskGroupsType{}

type DiskGroupsType struct {
	basetypes.ObjectType
}

func (t DiskGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(DiskGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DiskGroupsType) String() string {
	return "DiskGroupsType"
}

func (t DiskGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultHardwareRaidSizeAttribute, ok := attributes["default_hardware_raid_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_hardware_raid_size is missing from object`)

		return nil, diags
	}

	defaultHardwareRaidSizeVal, ok := defaultHardwareRaidSizeAttribute.(DiskGroupsDefaultHardwareRaidSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_hardware_raid_size expected to be DiskGroupsDefaultHardwareRaidSizeValue, was: %T`, defaultHardwareRaidSizeAttribute))
	}

	defaultHardwareRaidTypeAttribute, ok := attributes["default_hardware_raid_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_hardware_raid_type is missing from object`)

		return nil, diags
	}

	defaultHardwareRaidTypeVal, ok := defaultHardwareRaidTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_hardware_raid_type expected to be ovhtypes.TfStringValue, was: %T`, defaultHardwareRaidTypeAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	diskGroupIdAttribute, ok := attributes["disk_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_group_id is missing from object`)

		return nil, diags
	}

	diskGroupIdVal, ok := diskGroupIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_group_id expected to be ovhtypes.TfInt64Value, was: %T`, diskGroupIdAttribute))
	}

	diskSizeAttribute, ok := attributes["disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_size is missing from object`)

		return nil, diags
	}

	diskSizeVal, ok := diskSizeAttribute.(DiskGroupsDiskSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_size expected to be DiskGroupsDiskSizeValue, was: %T`, diskSizeAttribute))
	}

	diskTypeAttribute, ok := attributes["disk_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_type is missing from object`)

		return nil, diags
	}

	diskTypeVal, ok := diskTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_type expected to be ovhtypes.TfStringValue, was: %T`, diskTypeAttribute))
	}

	numberOfDisksAttribute, ok := attributes["number_of_disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_of_disks is missing from object`)

		return nil, diags
	}

	numberOfDisksVal, ok := numberOfDisksAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_of_disks expected to be ovhtypes.TfInt64Value, was: %T`, numberOfDisksAttribute))
	}

	raidControllerAttribute, ok := attributes["raid_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raid_controller is missing from object`)

		return nil, diags
	}

	raidControllerVal, ok := raidControllerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raid_controller expected to be ovhtypes.TfStringValue, was: %T`, raidControllerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DiskGroupsValue{
		DefaultHardwareRaidSize: defaultHardwareRaidSizeVal,
		DefaultHardwareRaidType: defaultHardwareRaidTypeVal,
		Description:             descriptionVal,
		DiskGroupId:             diskGroupIdVal,
		DiskSize:                diskSizeVal,
		DiskType:                diskTypeVal,
		NumberOfDisks:           numberOfDisksVal,
		RaidController:          raidControllerVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewDiskGroupsValueNull() DiskGroupsValue {
	return DiskGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewDiskGroupsValueUnknown() DiskGroupsValue {
	return DiskGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDiskGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DiskGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DiskGroupsValue Attribute Value",
				"While creating a DiskGroupsValue value, a missing attribute value was detected. "+
					"A DiskGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DiskGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DiskGroupsValue Attribute Type",
				"While creating a DiskGroupsValue value, an invalid attribute value was detected. "+
					"A DiskGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DiskGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DiskGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DiskGroupsValue Attribute Value",
				"While creating a DiskGroupsValue value, an extra attribute value was detected. "+
					"A DiskGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DiskGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDiskGroupsValueUnknown(), diags
	}

	defaultHardwareRaidSizeAttribute, ok := attributes["default_hardware_raid_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_hardware_raid_size is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	defaultHardwareRaidSizeVal, ok := defaultHardwareRaidSizeAttribute.(DiskGroupsDefaultHardwareRaidSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_hardware_raid_size expected to be DiskGroupsDefaultHardwareRaidSizeValue, was: %T`, defaultHardwareRaidSizeAttribute))
	}

	defaultHardwareRaidTypeAttribute, ok := attributes["default_hardware_raid_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_hardware_raid_type is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	defaultHardwareRaidTypeVal, ok := defaultHardwareRaidTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_hardware_raid_type expected to be ovhtypes.TfStringValue, was: %T`, defaultHardwareRaidTypeAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	diskGroupIdAttribute, ok := attributes["disk_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_group_id is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	diskGroupIdVal, ok := diskGroupIdAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_group_id expected to be ovhtypes.TfInt64Value, was: %T`, diskGroupIdAttribute))
	}

	diskSizeAttribute, ok := attributes["disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_size is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	diskSizeVal, ok := diskSizeAttribute.(DiskGroupsDiskSizeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_size expected to be DiskGroupsDiskSizeValue, was: %T`, diskSizeAttribute))
	}

	diskTypeAttribute, ok := attributes["disk_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_type is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	diskTypeVal, ok := diskTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_type expected to be ovhtypes.TfStringValue, was: %T`, diskTypeAttribute))
	}

	numberOfDisksAttribute, ok := attributes["number_of_disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_of_disks is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	numberOfDisksVal, ok := numberOfDisksAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_of_disks expected to be ovhtypes.TfInt64Value, was: %T`, numberOfDisksAttribute))
	}

	raidControllerAttribute, ok := attributes["raid_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raid_controller is missing from object`)

		return NewDiskGroupsValueUnknown(), diags
	}

	raidControllerVal, ok := raidControllerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raid_controller expected to be ovhtypes.TfStringValue, was: %T`, raidControllerAttribute))
	}

	if diags.HasError() {
		return NewDiskGroupsValueUnknown(), diags
	}

	return DiskGroupsValue{
		DefaultHardwareRaidSize: defaultHardwareRaidSizeVal,
		DefaultHardwareRaidType: defaultHardwareRaidTypeVal,
		Description:             descriptionVal,
		DiskGroupId:             diskGroupIdVal,
		DiskSize:                diskSizeVal,
		DiskType:                diskTypeVal,
		NumberOfDisks:           numberOfDisksVal,
		RaidController:          raidControllerVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewDiskGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DiskGroupsValue {
	object, diags := NewDiskGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDiskGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DiskGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDiskGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDiskGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDiskGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDiskGroupsValueMust(DiskGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DiskGroupsType) ValueType(ctx context.Context) attr.Value {
	return DiskGroupsValue{}
}

var _ basetypes.ObjectValuable = DiskGroupsValue{}

type DiskGroupsValue struct {
	DefaultHardwareRaidSize DiskGroupsDefaultHardwareRaidSizeValue `tfsdk:"default_hardware_raid_size" json:"defaultHardwareRaidSize"`
	DefaultHardwareRaidType ovhtypes.TfStringValue                 `tfsdk:"default_hardware_raid_type" json:"defaultHardwareRaidType"`
	Description             ovhtypes.TfStringValue                 `tfsdk:"description" json:"description"`
	DiskGroupId             ovhtypes.TfInt64Value                  `tfsdk:"disk_group_id" json:"diskGroupId"`
	DiskSize                DiskGroupsDiskSizeValue                `tfsdk:"disk_size" json:"diskSize"`
	DiskType                ovhtypes.TfStringValue                 `tfsdk:"disk_type" json:"diskType"`
	NumberOfDisks           ovhtypes.TfInt64Value                  `tfsdk:"number_of_disks" json:"numberOfDisks"`
	RaidController          ovhtypes.TfStringValue                 `tfsdk:"raid_controller" json:"raidController"`
	state                   attr.ValueState
}

func (v *DiskGroupsValue) UnmarshalJSON(data []byte) error {
	type JsonDiskGroupsValue DiskGroupsValue

	var tmp JsonDiskGroupsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DefaultHardwareRaidSize = tmp.DefaultHardwareRaidSize
	v.DefaultHardwareRaidType = tmp.DefaultHardwareRaidType
	v.Description = tmp.Description
	v.DiskGroupId = tmp.DiskGroupId
	v.DiskSize = tmp.DiskSize
	v.DiskType = tmp.DiskType
	v.NumberOfDisks = tmp.NumberOfDisks
	v.RaidController = tmp.RaidController

	v.state = attr.ValueStateKnown

	return nil
}

func (v *DiskGroupsValue) MergeWith(other *DiskGroupsValue) {

	if (v.DefaultHardwareRaidSize.IsUnknown() || v.DefaultHardwareRaidSize.IsNull()) && !other.DefaultHardwareRaidSize.IsUnknown() {
		v.DefaultHardwareRaidSize = other.DefaultHardwareRaidSize
	}

	if (v.DefaultHardwareRaidType.IsUnknown() || v.DefaultHardwareRaidType.IsNull()) && !other.DefaultHardwareRaidType.IsUnknown() {
		v.DefaultHardwareRaidType = other.DefaultHardwareRaidType
	}

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.DiskGroupId.IsUnknown() || v.DiskGroupId.IsNull()) && !other.DiskGroupId.IsUnknown() {
		v.DiskGroupId = other.DiskGroupId
	}

	if (v.DiskSize.IsUnknown() || v.DiskSize.IsNull()) && !other.DiskSize.IsUnknown() {
		v.DiskSize = other.DiskSize
	}

	if (v.DiskType.IsUnknown() || v.DiskType.IsNull()) && !other.DiskType.IsUnknown() {
		v.DiskType = other.DiskType
	}

	if (v.NumberOfDisks.IsUnknown() || v.NumberOfDisks.IsNull()) && !other.NumberOfDisks.IsUnknown() {
		v.NumberOfDisks = other.NumberOfDisks
	}

	if (v.RaidController.IsUnknown() || v.RaidController.IsNull()) && !other.RaidController.IsUnknown() {
		v.RaidController = other.RaidController
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v DiskGroupsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"defaultHardwareRaidSize": v.DefaultHardwareRaidSize,
		"defaultHardwareRaidType": v.DefaultHardwareRaidType,
		"description":             v.Description,
		"diskGroupId":             v.DiskGroupId,
		"diskSize":                v.DiskSize,
		"diskType":                v.DiskType,
		"numberOfDisks":           v.NumberOfDisks,
		"raidController":          v.RaidController,
	}
}
func (v DiskGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["default_hardware_raid_size"] = basetypes.ObjectType{
		AttrTypes: DiskGroupsDefaultHardwareRaidSizeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["default_hardware_raid_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk_group_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disk_size"] = basetypes.ObjectType{
		AttrTypes: DiskGroupsDiskSizeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["disk_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["number_of_disks"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["raid_controller"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DefaultHardwareRaidSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_hardware_raid_size"] = val

		val, err = v.DefaultHardwareRaidType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_hardware_raid_type"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DiskGroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_group_id"] = val

		val, err = v.DiskSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_size"] = val

		val, err = v.DiskType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_type"] = val

		val, err = v.NumberOfDisks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_of_disks"] = val

		val, err = v.RaidController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["raid_controller"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DiskGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DiskGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DiskGroupsValue) String() string {
	return "DiskGroupsValue"
}

func (v DiskGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"default_hardware_raid_size": DiskGroupsDefaultHardwareRaidSizeType{
				basetypes.ObjectType{
					AttrTypes: DiskGroupsDefaultHardwareRaidSizeValue{}.AttributeTypes(ctx),
				},
			},
			"default_hardware_raid_type": ovhtypes.TfStringType{},
			"description":                ovhtypes.TfStringType{},
			"disk_group_id":              ovhtypes.TfInt64Type{},
			"disk_size": DiskGroupsDiskSizeType{
				basetypes.ObjectType{
					AttrTypes: DiskGroupsDiskSizeValue{}.AttributeTypes(ctx),
				},
			},
			"disk_type":       ovhtypes.TfStringType{},
			"number_of_disks": ovhtypes.TfInt64Type{},
			"raid_controller": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"default_hardware_raid_size": v.DefaultHardwareRaidSize,
			"default_hardware_raid_type": v.DefaultHardwareRaidType,
			"description":                v.Description,
			"disk_group_id":              v.DiskGroupId,
			"disk_size":                  v.DiskSize,
			"disk_type":                  v.DiskType,
			"number_of_disks":            v.NumberOfDisks,
			"raid_controller":            v.RaidController,
		})

	return objVal, diags
}

func (v DiskGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(DiskGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultHardwareRaidSize.Equal(other.DefaultHardwareRaidSize) {
		return false
	}

	if !v.DefaultHardwareRaidType.Equal(other.DefaultHardwareRaidType) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DiskGroupId.Equal(other.DiskGroupId) {
		return false
	}

	if !v.DiskSize.Equal(other.DiskSize) {
		return false
	}

	if !v.DiskType.Equal(other.DiskType) {
		return false
	}

	if !v.NumberOfDisks.Equal(other.NumberOfDisks) {
		return false
	}

	if !v.RaidController.Equal(other.RaidController) {
		return false
	}

	return true
}

func (v DiskGroupsValue) Type(ctx context.Context) attr.Type {
	return DiskGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DiskGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_hardware_raid_size": DiskGroupsDefaultHardwareRaidSizeValue{}.Type(ctx),
		"default_hardware_raid_type": ovhtypes.TfStringType{},
		"description":                ovhtypes.TfStringType{},
		"disk_group_id":              ovhtypes.TfInt64Type{},
		"disk_size":                  DiskGroupsDiskSizeValue{}.Type(ctx),
		"disk_type":                  ovhtypes.TfStringType{},
		"number_of_disks":            ovhtypes.TfInt64Type{},
		"raid_controller":            ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = DiskGroupsDefaultHardwareRaidSizeType{}

type DiskGroupsDefaultHardwareRaidSizeType struct {
	basetypes.ObjectType
}

func (t DiskGroupsDefaultHardwareRaidSizeType) Equal(o attr.Type) bool {
	other, ok := o.(DiskGroupsDefaultHardwareRaidSizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DiskGroupsDefaultHardwareRaidSizeType) String() string {
	return "DiskGroupsDefaultHardwareRaidSizeType"
}

func (t DiskGroupsDefaultHardwareRaidSizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DiskGroupsDefaultHardwareRaidSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDiskGroupsDefaultHardwareRaidSizeValueNull() DiskGroupsDefaultHardwareRaidSizeValue {
	return DiskGroupsDefaultHardwareRaidSizeValue{
		state: attr.ValueStateNull,
	}
}

func NewDiskGroupsDefaultHardwareRaidSizeValueUnknown() DiskGroupsDefaultHardwareRaidSizeValue {
	return DiskGroupsDefaultHardwareRaidSizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDiskGroupsDefaultHardwareRaidSizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DiskGroupsDefaultHardwareRaidSizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DiskGroupsDefaultHardwareRaidSizeValue Attribute Value",
				"While creating a DiskGroupsDefaultHardwareRaidSizeValue value, a missing attribute value was detected. "+
					"A DiskGroupsDefaultHardwareRaidSizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DiskGroupsDefaultHardwareRaidSizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DiskGroupsDefaultHardwareRaidSizeValue Attribute Type",
				"While creating a DiskGroupsDefaultHardwareRaidSizeValue value, an invalid attribute value was detected. "+
					"A DiskGroupsDefaultHardwareRaidSizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DiskGroupsDefaultHardwareRaidSizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DiskGroupsDefaultHardwareRaidSizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DiskGroupsDefaultHardwareRaidSizeValue Attribute Value",
				"While creating a DiskGroupsDefaultHardwareRaidSizeValue value, an extra attribute value was detected. "+
					"A DiskGroupsDefaultHardwareRaidSizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DiskGroupsDefaultHardwareRaidSizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDiskGroupsDefaultHardwareRaidSizeValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewDiskGroupsDefaultHardwareRaidSizeValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewDiskGroupsDefaultHardwareRaidSizeValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewDiskGroupsDefaultHardwareRaidSizeValueUnknown(), diags
	}

	return DiskGroupsDefaultHardwareRaidSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDiskGroupsDefaultHardwareRaidSizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DiskGroupsDefaultHardwareRaidSizeValue {
	object, diags := NewDiskGroupsDefaultHardwareRaidSizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDiskGroupsDefaultHardwareRaidSizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DiskGroupsDefaultHardwareRaidSizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDiskGroupsDefaultHardwareRaidSizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDiskGroupsDefaultHardwareRaidSizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDiskGroupsDefaultHardwareRaidSizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDiskGroupsDefaultHardwareRaidSizeValueMust(DiskGroupsDefaultHardwareRaidSizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DiskGroupsDefaultHardwareRaidSizeType) ValueType(ctx context.Context) attr.Value {
	return DiskGroupsDefaultHardwareRaidSizeValue{}
}

var _ basetypes.ObjectValuable = DiskGroupsDefaultHardwareRaidSizeValue{}

type DiskGroupsDefaultHardwareRaidSizeValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *DiskGroupsDefaultHardwareRaidSizeValue) UnmarshalJSON(data []byte) error {
	type JsonDiskGroupsDefaultHardwareRaidSizeValue DiskGroupsDefaultHardwareRaidSizeValue

	var tmp JsonDiskGroupsDefaultHardwareRaidSizeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *DiskGroupsDefaultHardwareRaidSizeValue) MergeWith(other *DiskGroupsDefaultHardwareRaidSizeValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v DiskGroupsDefaultHardwareRaidSizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) String() string {
	return "DiskGroupsDefaultHardwareRaidSizeValue"
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) Equal(o attr.Value) bool {
	other, ok := o.(DiskGroupsDefaultHardwareRaidSizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) Type(ctx context.Context) attr.Type {
	return DiskGroupsDefaultHardwareRaidSizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DiskGroupsDefaultHardwareRaidSizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = DiskGroupsDiskSizeType{}

type DiskGroupsDiskSizeType struct {
	basetypes.ObjectType
}

func (t DiskGroupsDiskSizeType) Equal(o attr.Type) bool {
	other, ok := o.(DiskGroupsDiskSizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DiskGroupsDiskSizeType) String() string {
	return "DiskGroupsDiskSizeType"
}

func (t DiskGroupsDiskSizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DiskGroupsDiskSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDiskGroupsDiskSizeValueNull() DiskGroupsDiskSizeValue {
	return DiskGroupsDiskSizeValue{
		state: attr.ValueStateNull,
	}
}

func NewDiskGroupsDiskSizeValueUnknown() DiskGroupsDiskSizeValue {
	return DiskGroupsDiskSizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDiskGroupsDiskSizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DiskGroupsDiskSizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DiskGroupsDiskSizeValue Attribute Value",
				"While creating a DiskGroupsDiskSizeValue value, a missing attribute value was detected. "+
					"A DiskGroupsDiskSizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DiskGroupsDiskSizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DiskGroupsDiskSizeValue Attribute Type",
				"While creating a DiskGroupsDiskSizeValue value, an invalid attribute value was detected. "+
					"A DiskGroupsDiskSizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DiskGroupsDiskSizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DiskGroupsDiskSizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DiskGroupsDiskSizeValue Attribute Value",
				"While creating a DiskGroupsDiskSizeValue value, an extra attribute value was detected. "+
					"A DiskGroupsDiskSizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DiskGroupsDiskSizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDiskGroupsDiskSizeValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewDiskGroupsDiskSizeValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewDiskGroupsDiskSizeValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewDiskGroupsDiskSizeValueUnknown(), diags
	}

	return DiskGroupsDiskSizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDiskGroupsDiskSizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DiskGroupsDiskSizeValue {
	object, diags := NewDiskGroupsDiskSizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDiskGroupsDiskSizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DiskGroupsDiskSizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDiskGroupsDiskSizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDiskGroupsDiskSizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDiskGroupsDiskSizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDiskGroupsDiskSizeValueMust(DiskGroupsDiskSizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DiskGroupsDiskSizeType) ValueType(ctx context.Context) attr.Value {
	return DiskGroupsDiskSizeValue{}
}

var _ basetypes.ObjectValuable = DiskGroupsDiskSizeValue{}

type DiskGroupsDiskSizeValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *DiskGroupsDiskSizeValue) UnmarshalJSON(data []byte) error {
	type JsonDiskGroupsDiskSizeValue DiskGroupsDiskSizeValue

	var tmp JsonDiskGroupsDiskSizeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *DiskGroupsDiskSizeValue) MergeWith(other *DiskGroupsDiskSizeValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v DiskGroupsDiskSizeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v DiskGroupsDiskSizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DiskGroupsDiskSizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DiskGroupsDiskSizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DiskGroupsDiskSizeValue) String() string {
	return "DiskGroupsDiskSizeValue"
}

func (v DiskGroupsDiskSizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v DiskGroupsDiskSizeValue) Equal(o attr.Value) bool {
	other, ok := o.(DiskGroupsDiskSizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v DiskGroupsDiskSizeValue) Type(ctx context.Context) attr.Type {
	return DiskGroupsDiskSizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DiskGroupsDiskSizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = ExpansionCardsType{}

type ExpansionCardsType struct {
	basetypes.ObjectType
}

func (t ExpansionCardsType) Equal(o attr.Type) bool {
	other, ok := o.(ExpansionCardsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExpansionCardsType) String() string {
	return "ExpansionCardsType"
}

func (t ExpansionCardsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExpansionCardsValue{
		Description:        descriptionVal,
		ExpansionCardsType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewExpansionCardsValueNull() ExpansionCardsValue {
	return ExpansionCardsValue{
		state: attr.ValueStateNull,
	}
}

func NewExpansionCardsValueUnknown() ExpansionCardsValue {
	return ExpansionCardsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExpansionCardsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExpansionCardsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExpansionCardsValue Attribute Value",
				"While creating a ExpansionCardsValue value, a missing attribute value was detected. "+
					"A ExpansionCardsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExpansionCardsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExpansionCardsValue Attribute Type",
				"While creating a ExpansionCardsValue value, an invalid attribute value was detected. "+
					"A ExpansionCardsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExpansionCardsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExpansionCardsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExpansionCardsValue Attribute Value",
				"While creating a ExpansionCardsValue value, an extra attribute value was detected. "+
					"A ExpansionCardsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExpansionCardsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExpansionCardsValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewExpansionCardsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be ovhtypes.TfStringValue, was: %T`, descriptionAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewExpansionCardsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be ovhtypes.TfStringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewExpansionCardsValueUnknown(), diags
	}

	return ExpansionCardsValue{
		Description:        descriptionVal,
		ExpansionCardsType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewExpansionCardsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExpansionCardsValue {
	object, diags := NewExpansionCardsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExpansionCardsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExpansionCardsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExpansionCardsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExpansionCardsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExpansionCardsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExpansionCardsValueMust(ExpansionCardsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExpansionCardsType) ValueType(ctx context.Context) attr.Value {
	return ExpansionCardsValue{}
}

var _ basetypes.ObjectValuable = ExpansionCardsValue{}

type ExpansionCardsValue struct {
	Description        ovhtypes.TfStringValue `tfsdk:"description" json:"description"`
	ExpansionCardsType ovhtypes.TfStringValue `tfsdk:"type" json:"type"`
	state              attr.ValueState
}

func (v *ExpansionCardsValue) UnmarshalJSON(data []byte) error {
	type JsonExpansionCardsValue ExpansionCardsValue

	var tmp JsonExpansionCardsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Description = tmp.Description
	v.ExpansionCardsType = tmp.ExpansionCardsType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ExpansionCardsValue) MergeWith(other *ExpansionCardsValue) {

	if (v.Description.IsUnknown() || v.Description.IsNull()) && !other.Description.IsUnknown() {
		v.Description = other.Description
	}

	if (v.ExpansionCardsType.IsUnknown() || v.ExpansionCardsType.IsNull()) && !other.ExpansionCardsType.IsUnknown() {
		v.ExpansionCardsType = other.ExpansionCardsType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ExpansionCardsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"description": v.Description,
		"type":        v.ExpansionCardsType,
	}
}
func (v ExpansionCardsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.ExpansionCardsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExpansionCardsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExpansionCardsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExpansionCardsValue) String() string {
	return "ExpansionCardsValue"
}

func (v ExpansionCardsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"description": ovhtypes.TfStringType{},
			"type":        ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"description": v.Description,
			"type":        v.ExpansionCardsType,
		})

	return objVal, diags
}

func (v ExpansionCardsValue) Equal(o attr.Value) bool {
	other, ok := o.(ExpansionCardsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.ExpansionCardsType.Equal(other.ExpansionCardsType) {
		return false
	}

	return true
}

func (v ExpansionCardsValue) Type(ctx context.Context) attr.Type {
	return ExpansionCardsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExpansionCardsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": ovhtypes.TfStringType{},
		"type":        ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = MemorySizeType{}

type MemorySizeType struct {
	basetypes.ObjectType
}

func (t MemorySizeType) Equal(o attr.Type) bool {
	other, ok := o.(MemorySizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MemorySizeType) String() string {
	return "MemorySizeType"
}

func (t MemorySizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MemorySizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemorySizeValueNull() MemorySizeValue {
	return MemorySizeValue{
		state: attr.ValueStateNull,
	}
}

func NewMemorySizeValueUnknown() MemorySizeValue {
	return MemorySizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMemorySizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MemorySizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MemorySizeValue Attribute Value",
				"While creating a MemorySizeValue value, a missing attribute value was detected. "+
					"A MemorySizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemorySizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MemorySizeValue Attribute Type",
				"While creating a MemorySizeValue value, an invalid attribute value was detected. "+
					"A MemorySizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemorySizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MemorySizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MemorySizeValue Attribute Value",
				"While creating a MemorySizeValue value, an extra attribute value was detected. "+
					"A MemorySizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MemorySizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMemorySizeValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewMemorySizeValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewMemorySizeValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewMemorySizeValueUnknown(), diags
	}

	return MemorySizeValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemorySizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MemorySizeValue {
	object, diags := NewMemorySizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMemorySizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MemorySizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMemorySizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMemorySizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMemorySizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMemorySizeValueMust(MemorySizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MemorySizeType) ValueType(ctx context.Context) attr.Value {
	return MemorySizeValue{}
}

var _ basetypes.ObjectValuable = MemorySizeValue{}

type MemorySizeValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *MemorySizeValue) UnmarshalJSON(data []byte) error {
	type JsonMemorySizeValue MemorySizeValue

	var tmp JsonMemorySizeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *MemorySizeValue) MergeWith(other *MemorySizeValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v MemorySizeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v MemorySizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MemorySizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MemorySizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MemorySizeValue) String() string {
	return "MemorySizeValue"
}

func (v MemorySizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v MemorySizeValue) Equal(o attr.Value) bool {
	other, ok := o.(MemorySizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v MemorySizeValue) Type(ctx context.Context) attr.Type {
	return MemorySizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MemorySizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = UsbKeysType{}

type UsbKeysType struct {
	basetypes.ObjectType
}

func (t UsbKeysType) Equal(o attr.Type) bool {
	other, ok := o.(UsbKeysType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsbKeysType) String() string {
	return "UsbKeysType"
}

func (t UsbKeysType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsbKeysValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewUsbKeysValueNull() UsbKeysValue {
	return UsbKeysValue{
		state: attr.ValueStateNull,
	}
}

func NewUsbKeysValueUnknown() UsbKeysValue {
	return UsbKeysValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsbKeysValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsbKeysValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsbKeysValue Attribute Value",
				"While creating a UsbKeysValue value, a missing attribute value was detected. "+
					"A UsbKeysValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbKeysValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsbKeysValue Attribute Type",
				"While creating a UsbKeysValue value, an invalid attribute value was detected. "+
					"A UsbKeysValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbKeysValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsbKeysValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsbKeysValue Attribute Value",
				"While creating a UsbKeysValue value, an extra attribute value was detected. "+
					"A UsbKeysValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsbKeysValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsbKeysValueUnknown(), diags
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewUsbKeysValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be ovhtypes.TfStringValue, was: %T`, unitAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewUsbKeysValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfInt64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewUsbKeysValueUnknown(), diags
	}

	return UsbKeysValue{
		Unit:  unitVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewUsbKeysValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsbKeysValue {
	object, diags := NewUsbKeysValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsbKeysValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsbKeysType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsbKeysValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsbKeysValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsbKeysValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsbKeysValueMust(UsbKeysValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsbKeysType) ValueType(ctx context.Context) attr.Value {
	return UsbKeysValue{}
}

var _ basetypes.ObjectValuable = UsbKeysValue{}

type UsbKeysValue struct {
	Unit  ovhtypes.TfStringValue `tfsdk:"unit" json:"unit"`
	Value ovhtypes.TfInt64Value  `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *UsbKeysValue) UnmarshalJSON(data []byte) error {
	type JsonUsbKeysValue UsbKeysValue

	var tmp JsonUsbKeysValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Unit = tmp.Unit
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *UsbKeysValue) MergeWith(other *UsbKeysValue) {

	if (v.Unit.IsUnknown() || v.Unit.IsNull()) && !other.Unit.IsUnknown() {
		v.Unit = other.Unit
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v UsbKeysValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"unit":  v.Unit,
		"value": v.Value,
	}
}
func (v UsbKeysValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsbKeysValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsbKeysValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsbKeysValue) String() string {
	return "UsbKeysValue"
}

func (v UsbKeysValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"unit":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"unit":  v.Unit,
			"value": v.Value,
		})

	return objVal, diags
}

func (v UsbKeysValue) Equal(o attr.Value) bool {
	other, ok := o.(UsbKeysValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v UsbKeysValue) Type(ctx context.Context) attr.Type {
	return UsbKeysType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsbKeysValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"unit":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfInt64Type{},
	}
}
